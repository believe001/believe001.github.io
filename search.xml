<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++中的static的作用</title>
    <url>/2019/10/10/C++%E4%B8%AD%E7%9A%84static%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<p><strong><font color=black size=6> C++中的static的作用</font></strong><br><strong><font color=gray size=4> C++中的关键字static,顾名思义表示静止，静态，下面是C++中static的一些常见应用</font></strong></p>
<p><strong><font color=black size=5> <strong>一，作用于函数内部的局部变量</strong></font></strong><br><strong>局部作用域静态变量的特点：当一个函数返回后，下一次再调用时，该变量还会保持上一回的值，函数内部的静态变量只开辟一次空间，且不会因为多次调用产生副本，也不会因为函数返回而失效</font></strong><br><strong><font color=gray size=4> 例如：<br>如果我想实现fun（）函数功能：在函数内部定义count计数器，打印出每次调用它的次数，你可能会这样写，如下<br></font></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//不加关键字static</span></span><br><span class="line">	count++;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;count=&quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Calling the “fun()”for the first time! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">fun</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Calling the “fun()”for the second time! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><font color=gray size=4>我们预计结果为：<br>第一次调用，打印出结果 1<br>第二次调用，打印出结果 2<br>我们试着运行后，结果并不是我们想要的，如下图：</font></p>
<p><img src="https://img-blog.csdnimg.cn/20190928110634465.png" alt="在这里插入图片描述"><br><strong><font color=gray size=4>两次运行结果都是1，这是为什么呢，原来是每次调用函数结束后，count值会失效，当再次调用函数时，count值会重新生成，初始值为1，这就达不到我们想要的结果，那该怎么办呢？这时候就需要static关键字作用的静态变量，如下：</font></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//static 作用的静态变量</span></span><br><span class="line">	count++;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;count=&quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;calling the “fun()”for the first time! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">fun</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;calling the “fun()”for the second time! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">fun</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color=gray size=4>运行结果跟我们想要的结果就一致啦</font></strong><br><img src="https://img-blog.csdnimg.cn/20190928111301941.png" alt="在这里插入图片描述"><br><strong><font color=gray size=4>另外，普通局部变量如果未赋予初值，编译器会报错</font></strong><br><img src="https://img-blog.csdnimg.cn/2019092811184860.png" alt="在这里插入图片描述"><br><strong><font color=gray size=4>报错如下：</font></strong><br><img src="https://img-blog.csdnimg.cn/20190928111931406.png" alt="在这里插入图片描述"><br><strong><font color=gray size=4>当局部变量加上static 后，定义时未赋予初值时，会默认初始化0</font></strong><br><img src="https://img-blog.csdnimg.cn/20190928111553204.png" alt="在这里插入图片描述"><br><strong><font color=black size=5> 二，作用于类的成员，解决同一个类的不同对象之间数据和函数共享问题</font></strong><br><strong><font  color=black size=5><strong>1，作用于类的数据成员，使其成为静态数据成员</strong></font></strong><br><strong><font  color=gray size=5>静态成员在每一个类中只有一个副本，由该类所有对象共同维护和使用，从而实现同一个类的不同对象数据共享。需要注意的是，如下<br></font></strong></p>
<p><strong><font  color=black size=4><strong>访问静态数据成员方式：类名：：标识符<br>对静态数据成员初始化：在类定义外进行</strong></font></strong></p>
<p><strong><font color=gray size=4> 之所以进行类名：：标识符进行访问，是因为静态数据成语哪不属于任何一个对象，而在类外进行定义是因为需要以这种方式专门为他们分配空间。<br>举例说明：<br>直接在类内定义静态数据成员，编译器会报错</font></strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190928121247746.png" alt="在这里插入图片描述"><br><strong><font color=gray size=4>错误如下：</font></strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190928121355249.png" alt="在这里插入图片描述"><br><strong><font color=gray size=4>正确做法：</font></strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190928121626382.png" alt="在这里插入图片描述"><br><strong><font color=gray size=4>下面通过一段代码，理解一下对于“同一个类的不同对象数据共享”的理解，代码如下：</font></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;	<span class="comment">//Point类定义</span></span><br><span class="line"><span class="keyword">public</span>:	<span class="comment">//外部接口</span></span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123; <span class="comment">//构造函数</span></span><br><span class="line">		<span class="comment">//在构造函数中对count累加，所有对象共同维护同一个count</span></span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Point</span>(Point &amp;p) &#123;	<span class="comment">//拷贝构造函数</span></span><br><span class="line">		x = p.x;</span><br><span class="line">		y = p.y;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Point</span>() &#123; count--; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showCount</span><span class="params">()</span> </span>&#123;		<span class="comment">//输出静态数据成员</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;  Object count = &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:	<span class="comment">//私有数据成员</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> count;	<span class="comment">//静态数据成员声明，用于记录点的个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Point::count = <span class="number">0</span>;	<span class="comment">//静态数据成员定义和初始化，使用类名限定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;	<span class="comment">//主函数</span></span><br><span class="line">	<span class="function">Point <span class="title">a</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;	<span class="comment">//定义对象a，其构造函数回使count增1</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Point A: &quot;</span> &lt;&lt; a.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a.<span class="built_in">getY</span>();</span><br><span class="line">	a.<span class="built_in">showCount</span>();	<span class="comment">//输出对象个数</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Point <span class="title">b</span><span class="params">(a)</span></span>;	<span class="comment">//定义对象b，其构造函数回使count增1</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Point B: &quot;</span> &lt;&lt; b.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b.<span class="built_in">getY</span>();</span><br><span class="line">	b.<span class="built_in">showCount</span>();	<span class="comment">//输出对象个数</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Point A: &quot;</span> &lt;&lt; a.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a.<span class="built_in">getY</span>();</span><br><span class="line">	a.<span class="built_in">showCount</span>();	<span class="comment">//输出对象个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><font color=gray size=4>输出结果：</font></strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190928152113737.png" alt="在这里插入图片描述"><br><strong><font color=gray size=4>这里的Point类里面的A,B对象共有的属性object count 都是2 。该运行结果清晰的显示了同一个类的不同对象数据共享的理解。</font></strong></p>
<p><strong><font  color=black size=5> <strong>2，作用于类的函数成员，使其成为静态函数成员</strong></font></strong><br><strong><font  color=gray size=5> 静态成员函数就是使用static关键字声明的函数成员，同静态数据成员一样，静态成员函数也属于整个类，由该类所有对象共同拥有，为所有对象共享</font></strong></p>
<p> <strong><font  color=black size=4>（1）</strong>静态成员函数主要用于处理该类的静态数据成员，可以直接调用静态数据成员。如果访问非静态成员，要通过对象来访问。例子如下：**<br></font>**</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">(A a)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">(A a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; x;<span class="comment">//对x的引用是错误的</span></span><br><span class="line">	cout &lt;&lt; a.x;<span class="comment">//正确</span></span><br><span class="line">	cout &lt;&lt; y;<span class="comment">//对x的引用是正确的的,引用静态数据成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><font color=gray size=4>上面代码中报错如下：</font></strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190928160250116.png" alt="在这里插入图片描述"><br><strong><font color=gray size=4><strong>所以，静态成员函数访问非静态成员，一定要通过对象来访问</strong></font></strong></p>
<p><strong><font  color=black size=4>（2）如果想在类外调用静态成员函数呢？——类外代码一般使用类名和作用域操作符来调用静态成员函数。</font></strong></p>
<p><strong><font color=gray size=4><strong>访问方式：</strong>一般通过</strong>类名：：函数名调用<strong>，也可用类.函数名调用<br>举例说明，如下：</font></strong></p>
<p><img src="https://img-blog.csdnimg.cn/2019092815524685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODUwOTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong><font color=black size=5> <strong>三，总结：</strong></font></strong><br><strong><font color=gray size=4><strong>当static作用于非类内函数的局部变量时，每次函数调用不会随着函数返回而失效，当static作用于类内成员时，由该类所有对象共同维护和使用，从而实现同一个类的不同对象数据共享。</strong></font></strong></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++函数章节知识点浅析</title>
    <url>/2019/10/04/C++%E5%87%BD%E6%95%B0%E7%AB%A0%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="C-函数章节知识点浅析"><a href="#C-函数章节知识点浅析" class="headerlink" title="C++函数章节知识点浅析"></a>C++函数章节知识点浅析</h2><h2 id="一，为什么要用函数"><a href="#一，为什么要用函数" class="headerlink" title="一，为什么要用函数"></a><strong>一，为什么要用函数</strong></h2><p>1，可重用性：函数是定义好的，可重用的功能模块，可以方便在程序中多次调用。<br>2，使程序简洁明了：函数可以将一个比较复杂的程序系统的分为若干块简洁的模块，减少程序整体复杂性，便于分工合作和修改维护。<br><strong>例如，求x的平方加y的平方的值：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">double <span class="title function_">fun</span>(double x)<span class="comment">//定义一个求平方的函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">	double x, y,re;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	re = <span class="title function_">fun</span>(x) + <span class="title function_">fun</span>(y);<span class="comment">//分别调用fun()函数，再实现求和</span></span><br><span class="line">	cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二，为什么要用函数重载"><a href="#二，为什么要用函数重载" class="headerlink" title="二，为什么要用函数重载"></a><strong>二，为什么要用函数重载</strong></h2><p>1，C++允许功能相近的函数在相同的作用域内以相同函数名声明，从而形成重载。方便使用，便于记忆。</p>
<p><strong>当参数类型变多时，如果不使用重载函数，就会使函数名变多，调用时要找到相应的函数名，十分繁琐，下面举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//当参数类型变化时，需要重新定义不同名字的函数，使得声明函数和调用函数变得麻烦</span><br><span class="line">int add1(int x,int y);</span><br><span class="line">float add2(foat x,float y);</span><br><span class="line">double add3(doublex,double y);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>利用重载函数实现上面功能：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//形参类型不同，定义相同名字函数，实现重载函数功能，调用时系统会自动调用相应参数类型的函数</span><br><span class="line">int add(int x,int y);</span><br><span class="line">float add(float x,float y);</span><br><span class="line">double add(double x,double y);</span><br></pre></td></tr></table></figure>


<h2 id="三，什么是值传递"><a href="#三，什么是值传递" class="headerlink" title="三，什么是值传递"></a><strong>三，什么是值传递</strong></h2><p>值传递是指在调用函数时将实际参数复制一份传递到函数中，<strong>这样在函数中如果对参数进行修改，将不会影响到实际参数</strong><br><strong>举例说明</strong>（超级经典的例子，哈哈）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span>(<span class="params">int a, int b</span>)</span><br><span class="line">&#123;</span><br><span class="line">	int t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">	int x = <span class="number">5</span>,y=<span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;   y=&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	<span class="title function_">swap</span>(x, y);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;   y=&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong><br><img src="https://img-blog.csdnimg.cn/20190914130922793.png" alt="输出结果"><br><strong>结果分析：</strong><br>swap函数由于是值传递，其实并没有将主函数中的两个值交换，因为实参传递给形参时，<strong>形参重新开辟了一个存储空间，储存和实参相同的值</strong>，<strong>swap函数中操作的其实是形参的值，并不会影响实参。</strong></p>
<h2 id="四，什么是地址传递"><a href="#四，什么是地址传递" class="headerlink" title="四，什么是地址传递"></a><strong>四，什么是地址传递</strong></h2><p>地址传递是指当调用一个过程时，是把实参变量的内存地址传递给被调用过程的形参，也就是说<strong>形参与实参使用相同地址的内存单元。因此当在被调用过程中改变形参的值，就等于改变了实参的值。</strong><br><strong>举例：</strong>（只需要把上面swap函数稍微改一下就可以实现交换功能啦！）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void swap(int *a, int *b)//通过地址传递</span><br><span class="line">&#123;</span><br><span class="line">	int t = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong><br><img src="https://img-blog.csdnimg.cn/20190914131930616.png" alt="结果"><br><strong>结果分析：</strong><br>通过地址传递，<strong>形参与实参使用相同地址的内存单元</strong>。对形参的操作其实就是对实参的操作，<strong>因此当在被调用过程中改变形参的值，就等于改变了实参的值</strong></p>
<p><strong>地址传递的特性：</strong><br>1，形参与实参使用相同地址的内存单元。因此当在被调用过程中改变形参的值，就等于改变了实参的值。<br>2，可以节省形实结合时多余的内存开销，因为只需要传给实参一个地址就行了，来看一个例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span>(int *a)<span class="comment">//通过地址传递</span></span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">		<span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*(a + j) &lt; *(a + j + <span class="number">1</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				t = *(a + j);</span><br><span class="line">				*(a + j) = *(a + j + <span class="number">1</span>);</span><br><span class="line">				*(a + j + <span class="number">1</span>) = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">	int a[<span class="number">10</span>] = &#123; <span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">7</span> &#125;;</span><br><span class="line">	<span class="title function_">sort</span>(a);</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过地址传递，只需将数组首地址传递给形参，就可以进行排序，这样大大节省了内存开支。</strong></p>
<h2 id="五，设计实验和教案，分析如何编写递归函数"><a href="#五，设计实验和教案，分析如何编写递归函数" class="headerlink" title="五，设计实验和教案，分析如何编写递归函数"></a><strong>五，设计实验和教案，分析如何编写递归函数</strong></h2><p><strong>定义：函数直接或间接地调用自身，称为递归调用。</strong><br><strong>举例，求4！的值是多少？：</strong></p>
<p><strong>编写递归函数两大关键：</strong><br>1，把问题分解为小部分，使其能够调用自身函数<br>可以这样分解：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy54dWV0YW5neC5jb20vYXNzZXQtdjE6VHNpbmdodWFYKzAwNzQwMDQzWF8yMDE1X1QyK3NwK3R5cGVAYXNzZXQrYmxvY2svaW1hZ2UwMDJkaWd1aS5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>2，确保最终分解出来的问题，是一个已知解的问题，即设置出口函数。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy54dWV0YW5neC5jb20vYXNzZXQtdjE6VHNpbmdodWFYKzAwNzQwMDQzWF8yMDE1X1QyK3NwK3R5cGVAYXNzZXQrYmxvY2svaW1hZ2UwMDNkaWd1aS5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>例子一：</strong><br><strong>求n!的值。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned fac(unsigned n)</span><br><span class="line">&#123;</span><br><span class="line">unsigned f;</span><br><span class="line">if(n==0)//关键！设置出口</span><br><span class="line">f=1;</span><br><span class="line">else </span><br><span class="line">f=fac(n-1)*n;//调用自身</span><br><span class="line">return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>例子二（（难度较大））：</strong></p>
<p><strong>汉诺塔问题：<br>分析：有三根针A，B，C，将n个盘子从A针上移到C针上可以分解为下面三个步骤</strong><br><strong>1，将A中上n-1个盘子移到B针上（借助C针）：这是一个递归过程，无需考虑细节<br>2，把A针上剩下的一个盘子移到C针上：可以直接做到，递归出口<br>3，将B针上的n-1盘子移到C针上（借助A针）：这是一个递归过程，无需考虑细节</strong></p>
<p>用hanoi函数实现1，3过程，move函数实现2过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void move(char src, char dest)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; src &lt;&lt; &quot;--&gt;&quot; &lt;&lt; dest &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//把n个盘子从src针移动到dest针，以medium针作为中介</span><br><span class="line">void hanoi(int n, char src, char medium, char dest)</span><br><span class="line">&#123;</span><br><span class="line">	if (n == 1)//递归出口</span><br><span class="line">		move(src, dest);</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		hanoi(n - 1, src, dest, medium);</span><br><span class="line">		move(src, dest);</span><br><span class="line">		hanoi(n - 1, medium, src, dest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类的继承方式探究</title>
    <url>/2019/10/10/C++%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="一，继承方式简介"><a href="#一，继承方式简介" class="headerlink" title="一，继承方式简介"></a>一，继承方式简介</h2><p><strong>1，三种继承方式：<br>公有继承<br>私有继承<br>保护继承<br>2，不同继承方式的影响主要体现在：<br>（1）派生类成员对基类成员的访问权限<br>（2）通过派生类对象对基类成员的访问权限</strong></p>
<h2 id="二，公有继承"><a href="#二，公有继承" class="headerlink" title="二，公有继承"></a>二，公有继承</h2><p><strong>1，公有继承(public)<br>（1）继承的派生类访问控制<br>基类的public和protected成员可以直接访问，但是基类的private成员，不可直接访问。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">getA</span>();<span class="comment">//基类的public成员在派生类中访问属性不变</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		a = <span class="number">2</span>;<span class="comment">//基类的private成员在派生类中不可以访问，编译器报错</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		c = <span class="number">2</span>;<span class="comment">//基类的protected成员在派生类可以访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里强调一下基类的private成员，在派生类中不可直接访问。编译器会报错：<br><img src="https://img-blog.csdnimg.cn/20191010193437323.png" alt="在这里插入图片描述"></p>
<p><strong>（2）通过派生类的对象：只能访问public成员。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">testPublic</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Testing public member&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">testPrivate</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Testing private member&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">testProtected</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Testing protected member&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.<span class="built_in">testPublic</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过派生类的对象，只能访问基类public成员。其他成员是不可见的，如下图<br><img src="https://img-blog.csdnimg.cn/20191010194715729.png" alt="在这里插入图片描述"></p>
<h2 id="三，私有继承（private）"><a href="#三，私有继承（private）" class="headerlink" title="三，私有继承（private）"></a>三，私有继承（private）</h2><p><strong>(1)派生类中的成员函数访问权限：<br>可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；下面设计实验验证：</strong><br><img src="https://img-blog.csdnimg.cn/20191010195942960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODUwOTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>报错如下：<br><img src="https://img-blog.csdnimg.cn/20191010200012195.png" alt="在这里插入图片描述"></p>
<p><strong>(2)派生类的对象访问权限：<br>不能直接访问从基类继承的任何成员。这是因为基类的public和protected成员，被私有继承后，都以private身份出现在派生类中。<br>实验验证：</strong><br><img src="https://img-blog.csdnimg.cn/2019101020054456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODUwOTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="四，保护继承-protected"><a href="#四，保护继承-protected" class="headerlink" title="四，保护继承(protected)"></a>四，保护继承(protected)</h2><p><strong>（1）派生类中的成员函数访问权限：<br>可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员，这点和public,private一样，但我们还需要实验验证一下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">testPublic</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Testing public member&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">testPrivate</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Testing private member&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">testProtected</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Testing protected member&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">protected</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; <span class="built_in">testPublic</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; <span class="built_in">testProtected</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123; <span class="built_in">testPrivate</span>(); &#125;<span class="comment">//基类的private成员在派生类中不可以访问，编译器报错</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基类的私有成员在派生类还是不能访问<br><img src="https://img-blog.csdnimg.cn/20191010201119430.png" alt="在这里插入图片描述"></p>
<p><strong>（2）通过派生类的对象：<br>不能直接访问从基类继承的任何成员。这是因为基类的public和protected成员继承后都以protected身份出现在派生类中。而protected成员在类外都是不能调用的。看一个例子：</strong><br><img src="https://img-blog.csdnimg.cn/20191010201711556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODUwOTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（3）特点：<br>对建立其所在类对象的模块来说，它与 private 成员的性质相同。如下图解释：<br><img src="https://img-blog.csdnimg.cn/2019101020305984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODUwOTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于其派生类来说，它与 public 成员的性质相同。见下例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">testProtected</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; <span class="built_in">testProtected</span>(); &#125;<span class="comment">//对于其派生类来说，它与 public 成员的性质相同,即可以在类中被访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>既实现了数据隐藏，又方便继承，实现代码重用。</p>
<h2 id="五，三者对比总结："><a href="#五，三者对比总结：" class="headerlink" title="五，三者对比总结："></a>五，三者对比总结：</h2><p><strong>看了这三种继承方式访问属性是不是有点晕？将三者继承方式进行对比总结一下，便于记忆。<br>1，三者共同点：不论以何种方式继承，派生类中成员函数都可以访问基类中public,protected成员，但是都不可以访问private成员。<br>2，不同点：除了公有继承方式通过派生类的对象可以访问基类中的pubic成员外（且只能访问public成员），其他继承方式在通过派生类的对象不可以访问基类中任何数据成员。</strong></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>未检测到VituralTechnology开启解决方法</title>
    <url>/2020/03/14/%E6%9C%AA%E6%A3%80%E6%B5%8B%E5%88%B0VituralTechnology%E5%BC%80%E5%90%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 



<p><strong>本人笔记本上最近安装模拟器的时候遇到该软件提示检测到未开启virtual technology（以前也遇到过，当时让我朋友帮忙搞了一晚上也没解决），但是进入bios中查看又的确是开启状态–enable，（进入bios具体方法自己百度哈）进入电脑任务管理器中查看也是开启的（如下图），在网上查询过试过许多解决方法都没用，终于在某平台看到一个看似非常奇葩的操作，竟然神奇的解决了我的问题，分享给大家希望能够帮助到大家</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200314151044629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODUwOTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>方法：<ul><li>进入bios，关闭VT，F10保存自动重启，直接按关机键（一次不行按两次，让电脑关机）</li><li>等到关机后，再按一下开机，进入bios开启VT,F10保存自动重启，按下关机键，关机后，再按一下开机，就搞定了</li></ul></strong></p>
<p>这个方法主要针对bios开启vt但是软件上检测不到已经开启了vt。</p>
<p>另外附上其他也许可行的解决方法（对于我的电脑没用）：<br>1，和windows自带的hyper-v冲突了<br><br>2，360核晶防护引擎的问题</p>
]]></content>
      <categories>
        <category>解决方法</category>
      </categories>
      <tags>
        <tag>解决方法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符指针修改字符、字符数组修改字符、String类修改字符</title>
    <url>/2019/12/12/%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E3%80%81String%E7%B1%BB%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="1，-字符指针有初始值时，不能修改其中字符的值"><a href="#1，-字符指针有初始值时，不能修改其中字符的值" class="headerlink" title="1， 字符指针有初始值时，不能修改其中字符的值"></a>1， 字符指针有初始值时，不能修改其中字符的值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *p1 = <span class="string">&quot;nihao&quot;</span>;<span class="comment">//字符指针赋值给字符指针只能读不能修改字符的值</span></span><br><span class="line">	<span class="type">char</span> *p2 = p1;</span><br><span class="line">	p1[<span class="number">0</span>] = <span class="string">&#x27;m&#x27;</span>;<span class="comment">//尝试修改，会报错</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>会报错：</strong><br><img src="https://img-blog.csdnimg.cn/20191212112934212.png" alt="在这里插入图片描述"></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为<code>char *</code> 字符指针，指向的数据存储在静态存储区，里面的值不允许修改。相当于<code>const char  *</code>表示指针指向内存区域不能修改。也就是上面的字符串nihao不能修改。</p>
<h2 id="2，字符指针赋值给另外一个字符指针，接受字符串的指针也只能进行读取操作。"><a href="#2，字符指针赋值给另外一个字符指针，接受字符串的指针也只能进行读取操作。" class="headerlink" title="2，字符指针赋值给另外一个字符指针，接受字符串的指针也只能进行读取操作。"></a>2，字符指针赋值给另外一个字符指针，接受字符串的指针也只能进行读取操作。</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *p1 = <span class="string">&quot;nihao&quot;</span>;<span class="comment">//字符指针赋值给字符指针只能读不能修改字符的值</span></span><br><span class="line">	<span class="type">char</span> *p2 = p1;</span><br><span class="line">	p2[<span class="number">0</span>] = <span class="string">&#x27;m&#x27;</span>;<span class="comment">//尝试修改，会报错</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样报错：访问权限的问题<br><img src="https://img-blog.csdnimg.cn/20191212113141568.png" alt="在这里插入图片描述"></p>
<h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>这里原因跟上面一样，只不过将<code>char *</code>赋值给另一个<code>char *</code>,本质上还是尝试修改一个<code>const char *</code>.也不允许修改。</p>
<h2 id="3，如果想要对字符指针里面的值进行操作怎么办呢？（最简单的方法直接看4-）"><a href="#3，如果想要对字符指针里面的值进行操作怎么办呢？（最简单的方法直接看4-）" class="headerlink" title="3，如果想要对字符指针里面的值进行操作怎么办呢？（最简单的方法直接看4.）"></a>3，如果想要对字符指针里面的值进行操作怎么办呢？（最简单的方法直接看4.）</h2><h3 id="申请动态内存（在堆中，属于动态存储区，允许修改）malloc（c）或者new-C"><a href="#申请动态内存（在堆中，属于动态存储区，允许修改）malloc（c）或者new-C" class="headerlink" title="- 申请动态内存（在堆中，属于动态存储区，允许修改）malloc（c）或者new(C++)"></a>- 申请动态内存（在堆中，属于动态存储区，允许修改）malloc（c）或者new(C++)</h3><h3 id="将静态数据区数据复制到动态内存中进行修改"><a href="#将静态数据区数据复制到动态内存中进行修改" class="headerlink" title="- 将静态数据区数据复制到动态内存中进行修改"></a>- 将静态数据区数据复制到动态内存中进行修改</h3><p>看例子：<br><strong>1）用C语言中<code>strcpy</code>函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *p1 = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">	<span class="type">char</span> *p2=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(p1)+<span class="number">1</span>];<span class="comment">//new 开辟一段新的内存，注意要加上1，要加上字符串末尾‘\0’</span></span><br><span class="line">	<span class="built_in">strcpy</span>(p2, p1);<span class="comment">//调用字符串copy函数,将静态内存区数据复制到动态内存中。</span></span><br><span class="line">	p2[<span class="number">0</span>] = <span class="string">&#x27;m&#x27;</span>;<span class="comment">//对新开辟的内存进行操作</span></span><br><span class="line">	cout &lt;&lt; p2&lt;&lt;endl;<span class="comment">//输出操作后的结果</span></span><br><span class="line">	cout &lt;&lt; p1&lt;&lt;endl;<span class="comment">//对原来字符串没有影响，原来字符串可以看做常量，不能修改。</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h3><p>为什么这里字符指针可以修改？因为<code>char * =new</code> 在堆中new（malloc和new一样的效果）了一块内存，该内存是动态存储区，允许修改值。<br><strong>2）可以用C++中string 类解决</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a= <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">	string b = a;</span><br><span class="line">	b[<span class="number">2</span>] = <span class="string">&#x27;M&#x27;</span>;<span class="comment">//将一个string a赋值给另外一个string b后，可以对b进行操作，对原来那个string a类没影响。</span></span><br><span class="line">	<span class="comment">/*a[1] = &#x27;M&#x27;;*/</span></span><br><span class="line">	cout &lt;&lt; b&lt;&lt;endl;<span class="comment">//输出操作结果</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//对原来那个string a类没影响，验证结果</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191212115404776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODUwOTE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4，直接用char-定义字符变量，允许修改某个字符"><a href="#4，直接用char-定义字符变量，允许修改某个字符" class="headerlink" title="4，直接用char []定义字符变量，允许修改某个字符"></a>4，直接用char []定义字符变量，允许修改某个字符</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>] = <span class="string">&quot;nimao&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="string">&#x27;h&#x27;</span>;<span class="comment">//直接修改。因为定义了一个字符数组。字符数组放在栈内存中，属于动态内存区，允许修改。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(a); i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h3><p>因为定义了一个字符数组<code>char a[10]</code>。字符数组放在栈内存中，属于动态内存区，允许修改。</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><h2 id="需要了解的c语言几个存储区"><a href="#需要了解的c语言几个存储区" class="headerlink" title="需要了解的c语言几个存储区"></a>需要了解的c语言几个存储区</h2><h3 id="动态存储区"><a href="#动态存储区" class="headerlink" title="动态存储区"></a>动态存储区</h3><p>包括堆存储区、栈存储区。</p>
<ul>
<li>你需要知道的是:堆一般是留给程序员用的，比如我们new一个数组，malloc数组，都是存放在堆中，用完后我们需要自己delete清理内存（虽然系统也会帮忙自动垃圾清理）。</li>
<li>定义一个数组，是放在栈储存区。栈一般是系统自己用的，像递归执行每一层执行状态都存储在栈存储区中。</li>
</ul>
<h3 id="静态存储区"><a href="#静态存储区" class="headerlink" title="静态存储区"></a>静态存储区</h3><p>存放常量、静态变量、全局变量</p>
<h3 id="程序区"><a href="#程序区" class="headerlink" title="程序区"></a>程序区</h3><p>存放程序语句</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/qian27enjoy/article/details/82624031">动态存储区、静态存储区、堆和栈的区别</a></p>
<h2 id="注意char-和char-区别"><a href="#注意char-和char-区别" class="headerlink" title="注意char * 和char []区别"></a>注意char * 和char []区别</h2><p>char *不可以修改某个字符，char []可以修改某个字符。</p>
<h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/kaituorensheng/archive/2012/10/23/2736069.html">char *a 与char a[] 的区别</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2019/07/21/hello-Hexo/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>Clean and generate and deploy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo d --g</span><br></pre></td></tr></table></figure>

<p>Don’t send referrer info to load image</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-referrer&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure>

<p>按照年份移动md文件进制定的年份文件夹</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grep -r <span class="string">&quot;date: 2020-&quot;</span> *.md -l | xargs mv -v -t <span class="number">2020</span>/</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://muxiner.github.io/organize-files/">https://muxiner.github.io/organize-files/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA常见IO模型 BIO、NIO、AIO总结</title>
    <url>/2022/01/20/JAVA%E5%B8%B8%E8%A7%81IO%E6%A8%A1%E5%9E%8B%20BIO%E3%80%81NIO%E3%80%81AIO%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><p>Blocking IO 同步阻塞型IO。当系统进行IO读写的时候，会阻塞，直到IO读写完毕。比如调用系统Read后，需要将内核空间的数据读取到用户空间。需要等待内核空间 数据准备，数据就绪，拷贝数据，线程一直处于阻塞状态，直到拷贝数据完成。如下图：<br><img src="https://img-blog.csdnimg.cn/direct/05d5cb0a1bc440f3a6d28f283b4fb3f7.png" alt="在这里插入图片描述"><br>BIO这种方式是一个连接对应着一个线程，会造成线程阻塞。当连接数目少的时候还能支撑住，当连接数一多会导致阻塞时间过程，影响系统的性能。因此阻塞型IO只是用于少量连接的情况。<br>为了使用大量连接的情况，又设计了非阻塞型IO-NIO模型。</p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>NIO同步非阻塞型IO，系统在进行读写的过程中不会阻塞，系统性能更高。非阻塞型IO采用了多路复用的原理，将多个连接注册到一个selector上，通过一个线程就能管理多个连接。通过selector轮询的方式看那个连接上有请求，对该请求分配一个线程。这样就大大提高的效率。<br><img src="https://img-blog.csdnimg.cn/direct/3f3fbb7e6bb24e539e54eca1907c62e9.png" alt="在这里插入图片描述"></p>
<p>非阻塞型IO特别适用于连接数目多，且连接时间较短的常用，比如聊天服务器。</p>
<h1 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h1><p>AIO为异步IO。异步IO是基于事件和回调机制来实现的。当应用程序发起IO请求后，立马返回，可以进行其他操作。当系统IO完成后，会通知该线程，该线程继续执行之后的操作。<br><img src="https://img-blog.csdnimg.cn/direct/404a39a40c4248f6aa4d59480d370477.png" alt="在这里插入图片描述"><br>目前AIO应用不是很广泛。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://img-blog.csdnimg.cn/direct/b66b2464131e40f394c7af04412743da.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC初识</title>
    <url>/2022/01/18/JDBC%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 



<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JDBC(java database connectivity)是java访问数据库的<strong>操作规范</strong>，实质上就是一个<strong>接口</strong>，具体的<strong>实现类（数据库驱动）</strong>由各个具体的<strong>数据库厂商</strong>实现。</p>
<h2 id="JDBC核心API"><a href="#JDBC核心API" class="headerlink" title="JDBC核心API"></a>JDBC核心API</h2><table>
<thead>
<tr>
<th align="left">接口或者类</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DriverManager类</td>
<td align="left">管理和注册数据库驱动（DriverManager.registerDriver）、获取数据库连接对象(DriverManager.getConnection)</td>
</tr>
<tr>
<td align="left">Connection接口</td>
<td align="left">连接对象，可以创建Statement和PreparedStatement对象（con.createStatement）</td>
</tr>
<tr>
<td align="left">Statement接口</td>
<td align="left">SQL语句对象，将SQL语句发送给数据库服务器</td>
</tr>
<tr>
<td align="left">PreparedStatement接口</td>
<td align="left">SQL语句对象，是Statement子接口，预编译对象，可以防止SQL注入</td>
</tr>
<tr>
<td align="left">ResultSet接口</td>
<td align="left">用于封装数据库查询的结果集，返回给客户端的java服务器。用next方法是游标。用getXxx方法获取该行不同字段结果</td>
</tr>
</tbody></table>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="导入驱动Jar包"><a href="#导入驱动Jar包" class="headerlink" title="导入驱动Jar包"></a>导入驱动Jar包</h3><p>新建文件夹lib,然后将Jar包放在该文件夹下，右键选择添加成library(Add as Library)</p>
<h3 id="加载和注册驱动"><a href="#加载和注册驱动" class="headerlink" title="加载和注册驱动"></a>加载和注册驱动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>为何可以这样注册驱动？我们知道将<code>com.mysql.jdbc.Driver</code>加载进内存，会自动执行给类中静态代码块。</p>
<p>在该类的静态代码块中有注册驱动的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Driver接口，所有数据库厂商必须实现的接口，表示这是一个驱动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//该类加载进内存，会执行静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：从JDBC3开始，目前已经普遍使用的版本，可以不用注册驱动直接使用。因为导入的驱动Jar包中META-INF文件中有对应的注册驱动配置</p>
<h2 id="详解JDBC重要的API"><a href="#详解JDBC重要的API" class="headerlink" title="详解JDBC重要的API"></a>详解JDBC重要的API</h2><h3 id="DriverManager类"><a href="#DriverManager类" class="headerlink" title="DriverManager类"></a>DriverManager类</h3><p>驱动管理，用于注册驱动（Class将驱动类加载，自动执行注册驱动）或者<strong>获取连接对象</strong></p>
<h4 id="获取连接对象"><a href="#获取连接对象" class="headerlink" title="获取连接对象"></a>获取连接对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection con=DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/db1&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="连接数据库的-URL-地址格式"><a href="#连接数据库的-URL-地址格式" class="headerlink" title="连接数据库的 URL 地址格式"></a>连接数据库的 URL 地址格式</h4><p>协议名：子协议：&#x2F;&#x2F;服务器或者IP地址：端口号&#x2F;数据库名?参数&#x3D;参数值</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/db3?msg=hello</span></span><br></pre></td></tr></table></figure>

<p>如果默认本机3306端口可以省略localhost:3306</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">///db3</span></span><br></pre></td></tr></table></figure>

<h4 id="乱码处理"><a href="#乱码处理" class="headerlink" title="乱码处理"></a>乱码处理</h4><p>如果数据库出现乱码，可以指定参数？characterEncoding&#x3D;utf8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/数据库?characterEncoding=utf8</span></span><br></pre></td></tr></table></figure>

<h4 id="案例1使用用户名、密码、URL-得到连接对象"><a href="#案例1使用用户名、密码、URL-得到连接对象" class="headerlink" title="案例1使用用户名、密码、URL 得到连接对象"></a>案例1使用用户名、密码、URL 得到连接对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 得到连接对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/day24&quot;</span>;</span><br><span class="line"> <span class="comment">//1) 使用用户名、密码、URL 得到连接对象</span></span><br><span class="line"> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"> <span class="comment">//com.mysql.jdbc.JDBC4Connection@68de145</span></span><br><span class="line"> System.out.println(connection);</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例2使用属性文件和-url-得到连接对象"><a href="#案例2使用属性文件和-url-得到连接对象" class="headerlink" title="案例2使用属性文件和 url 得到连接对象"></a>案例2使用属性文件和 url 得到连接对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"> <span class="comment">//url 连接字符串</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/day24&quot;</span>;</span><br><span class="line"> <span class="comment">//属性对象</span></span><br><span class="line"> <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"> <span class="comment">//把用户名和密码放在 info 对象中</span></span><br><span class="line">  info.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line"> info.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line"> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, info);</span><br><span class="line"> <span class="comment">//com.mysql.jdbc.JDBC4Connection@68de145</span></span><br><span class="line"> System.out.println(connection);</span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Connection接口"><a href="#Connection接口" class="headerlink" title="Connection接口"></a>Connection接口</h3><p>Connection 接口，具体的实现类由数据库的厂商实现，代表一个连接对象。</p>
<h4 id="接口中的方法"><a href="#接口中的方法" class="headerlink" title="接口中的方法"></a>接口中的方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### Statement接口</span><br><span class="line"></span><br><span class="line">代表语句对象，用于**发送SQL语句给服务器**，用于执行静态SQL语句并返回它生成结果的对象。</span><br><span class="line"></span><br><span class="line">#### 接口中的方法</span><br><span class="line"></span><br><span class="line">executeUpdate 更新</span><br><span class="line"></span><br><span class="line">executeQuery 查询</span><br><span class="line"></span><br><span class="line">### PreparedStatement接口</span><br><span class="line"></span><br><span class="line">代表语句对象，用于**发送SQL语句给服务器**，这里的SQL语句参数要用？代替。用于执行**动态**SQL语句并返回它生成结果的对象。</span><br><span class="line"></span><br><span class="line">#### 可以防止SQL注入</span><br><span class="line"></span><br><span class="line">本质上是和服务器协调固定了SQL语句的结构，防止了SQL注入。</span><br><span class="line"></span><br><span class="line">#### 接口中的方法</span><br><span class="line"></span><br><span class="line">setXxx 设置？对应的参数</span><br><span class="line"></span><br><span class="line">### ResultSet接口</span><br><span class="line"></span><br><span class="line">结果集对象，封装了查询结果</span><br><span class="line"></span><br><span class="line">#### 接口中的方法</span><br><span class="line"></span><br><span class="line">#####  boolean next()</span><br><span class="line"></span><br><span class="line">游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</span><br><span class="line"></span><br><span class="line">##### getXxx(参数) 获取数据</span><br><span class="line"></span><br><span class="line">Xxx：代表数据类型   如： int getInt() ,	String getString()</span><br><span class="line">参数</span><br><span class="line"></span><br><span class="line">1. int：代表列的编号,从1开始   如： getString(1)</span><br><span class="line">2. String：代表列名称。 如： getDouble(&quot;balance&quot;)</span><br><span class="line"></span><br><span class="line">## JDBC连接数据库步骤</span><br><span class="line"></span><br><span class="line">- 导入数据库驱动jar包</span><br><span class="line">- 加载注册驱动</span><br><span class="line">- 获取连接对象</span><br><span class="line">- 创建语句对象statement</span><br><span class="line">- 定义sql，利用statement对象给数据库服务器发送执行</span><br><span class="line">- 返回执行结果</span><br><span class="line">- 关闭statement、connecttion、（resultSet）</span><br><span class="line"></span><br><span class="line">## 抽取JDBC工具类 ： JDBCUtils</span><br><span class="line"></span><br><span class="line">主要是为了简化书写</span><br><span class="line"></span><br><span class="line">### 步骤</span><br><span class="line"></span><br><span class="line">- 定义jdbc.properties配置文件,包括```url、user、password、driver```属性</span><br><span class="line">- 定义类，定义静态方法</span><br><span class="line">  - 定义property对象，读取配置文件属性</span><br><span class="line">  - 加载注册jdbc(静态代码块)</span><br><span class="line">  - 定义获取连接对象静态方法</span><br><span class="line">  - 定义close方法</span><br><span class="line"></span><br><span class="line">### 代码</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class JDBCUtils &#123;</span><br><span class="line">    private static String url;</span><br><span class="line">    private static String user;</span><br><span class="line">    private static String password;</span><br><span class="line">    private static String driver;</span><br><span class="line">    /**</span><br><span class="line">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span><br><span class="line">     */</span><br><span class="line">    static&#123;</span><br><span class="line">        //读取资源文件，获取值。</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //1. 创建Properties集合类。</span><br><span class="line">            Properties pro = new Properties();</span><br><span class="line"></span><br><span class="line">            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span><br><span class="line">            ClassLoader classLoader = JDBCUtils.class.getClassLoader();</span><br><span class="line">            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);</span><br><span class="line">            String path = res.getPath();</span><br><span class="line">            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span><br><span class="line">            //2. 加载文件</span><br><span class="line">           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));</span><br><span class="line">            pro.load(new FileReader(path));</span><br><span class="line"></span><br><span class="line">            //3. 获取数据，赋值</span><br><span class="line">            url = pro.getProperty(&quot;url&quot;);</span><br><span class="line">            user = pro.getProperty(&quot;user&quot;);</span><br><span class="line">            password = pro.getProperty(&quot;password&quot;);</span><br><span class="line">            driver = pro.getProperty(&quot;driver&quot;);</span><br><span class="line">            //4. 注册驱动</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     /**</span><br><span class="line">     * 获取连接</span><br><span class="line">     * @return 连接对象</span><br><span class="line">     */</span><br><span class="line">    public static Connection getConnection() throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">        return DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放资源</span><br><span class="line">     * @param stmt</span><br><span class="line">     * @param conn</span><br><span class="line">     */</span><br><span class="line">    public static void close(Statement stmt,Connection conn)&#123;</span><br><span class="line">        if( stmt != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if( conn != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBCUtils使用"><a href="#JDBCUtils使用" class="headerlink" title="JDBCUtils使用"></a>JDBCUtils使用</h3><p>直接使用静态类JDBCUtils静态方法创建连接对象。最后使用该类的close关闭statement、connection、resultset对象</p>
<p>如果需要修改JDBCUtils配置在jdbc.properties进行修改。</p>
<h2 id="案例通过查询user表，实现查询登录功能"><a href="#案例通过查询user表，实现查询登录功能" class="headerlink" title="案例通过查询user表，实现查询登录功能"></a>案例通过查询user表，实现查询登录功能</h2><h3 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h3><ol>
<li>使用JDBCUtils对象连接数据库</li>
<li>查询user数据库表，如果查询有结果，则表示成功登录</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username ,String password)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(username == <span class="literal">null</span> || password == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接数据库判断是否登录成功</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span>  <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//1.获取连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn =  JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = &#x27;&quot;</span>+username+<span class="string">&quot;&#x27; and password = &#x27;&quot;</span>+password+<span class="string">&quot;&#x27; &quot;</span>;</span><br><span class="line">            <span class="comment">//3.获取执行sql的对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.执行查询</span></span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            <span class="comment">//5.判断</span></span><br><span class="line">           <span class="comment">/* if(rs.next())&#123;//如果有下一行，则返回true</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">            &#125;else&#123;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">           <span class="keyword">return</span> rs.next();<span class="comment">//如果有下一行，则返回true</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(rs,stmt,conn);</span><br><span class="line">        &#125;		        </span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h2><h3 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h3><p>一个包含多个步骤的业务，我们期望他要么全部执行成功，要么同时执行失败。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li>开启事务 setAutoCommit(false)</li>
<li>成功，手动commit，提交事务</li>
<li>失败(捕获到异常)，手动rollback，回滚事务</li>
</ul>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo10</span> &#123;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	        <span class="type">PreparedStatement</span> <span class="variable">pstmt1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	        <span class="type">PreparedStatement</span> <span class="variable">pstmt2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            <span class="comment">//1.获取连接</span></span><br><span class="line">	            conn = JDBCUtils.getConnection();</span><br><span class="line">	            <span class="comment">//开启事务</span></span><br><span class="line">	            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">	</span><br><span class="line">	            <span class="comment">//2.定义sql</span></span><br><span class="line">	            <span class="comment">//2.1 张三 - 500</span></span><br><span class="line">	            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;</span><br><span class="line">	            <span class="comment">//2.2 李四 + 500</span></span><br><span class="line">	            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update account set balance = balance + ? where id = ?&quot;</span>;</span><br><span class="line">	            <span class="comment">//3.获取执行sql对象</span></span><br><span class="line">	            pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">	            pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">	            <span class="comment">//4. 设置参数</span></span><br><span class="line">	            pstmt1.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">	            pstmt1.setInt(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	            pstmt2.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">	            pstmt2.setInt(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">	            <span class="comment">//5.执行sql</span></span><br><span class="line">	            pstmt1.executeUpdate();</span><br><span class="line">	            <span class="comment">// 手动制造异常</span></span><br><span class="line">	            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	            pstmt2.executeUpdate();</span><br><span class="line">	            <span class="comment">//提交事务</span></span><br><span class="line">	            conn.commit();</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	            <span class="comment">//事务回滚</span></span><br><span class="line">	            <span class="keyword">try</span> &#123;</span><br><span class="line">	                <span class="keyword">if</span>(conn != <span class="literal">null</span>) &#123;</span><br><span class="line">	                    conn.rollback();</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">	                e1.printStackTrace();</span><br><span class="line">	            &#125;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">	        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	            JDBCUtils.close(pstmt1,conn);</span><br><span class="line">	            JDBCUtils.close(pstmt2,<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.黑马JDBC笔记</p>
<h1 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h1><p>数据库连接池是一个存放<strong>connection连接对象</strong>的池子（<strong>容器</strong>）。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>当系统初始化后，容器被创建，容器会申请一些连接对象存放在该容器中，当用户访问数据库的时候，直接从池子中申请，用完后归还到池子中去。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li>节约资源</li>
<li>用户访问高效</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>标准的接口是DataSource，包含方法</p>
<ul>
<li>获取连接getConnection</li>
<li>归还连接close</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>一般是由数据库厂商来实现</p>
<ul>
<li>C3P0数据库连接池技术</li>
<li>Druid（阿里巴巴提供）</li>
</ul>
<h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><h2 id="C3P0数据库连接池技术"><a href="#C3P0数据库连接池技术" class="headerlink" title="C3P0数据库连接池技术"></a>C3P0数据库连接池技术</h2><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>导入jar包（注意要导入数据库连接池的jar包，还要导入数据库驱动jar包）</li>
<li>在src（classPath）下定义配置文件，可以配置driverName,user,password,maxSize等</li>
<li>定义一个类文件使用<ul>
<li><code>ds=new ComboPooledDataSource</code>直接new一个连接池</li>
<li>数据库连接池直接getConnection获取连接对象</li>
</ul>
</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dataSource.c3p0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataSource ds=<span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;other1c3p0&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">            System.out.println(con);</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Druid（阿里巴巴提供）常用"><a href="#Druid（阿里巴巴提供）常用" class="headerlink" title="Druid（阿里巴巴提供）常用"></a>Druid（阿里巴巴提供）常用</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>导入jar包（注意要导入数据库连接池的jar包，还要导入数据库驱动jar包）</li>
<li>在src（classPath）下定义配置文件，可以配置driverName,user,password,maxSize等</li>
<li>定义一个类文件使用<ul>
<li><code>ds=DruidDataSourceFactory.createDataSource(pro)</code>这里是通过工厂类来生成连接池</li>
<li>数据库连接池直接getConnection获取连接对象</li>
</ul>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dataSource.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Properties pro=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">rs</span> <span class="operator">=</span> Demo01.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            pro.load(rs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">            String sql=<span class="string">&quot;SELECT * FROM emp;&quot;</span>;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">            <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="抽取成工具类DruidUtils"><a href="#抽取成工具类DruidUtils" class="headerlink" title="抽取成工具类DruidUtils"></a>抽取成工具类DruidUtils</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li>获取数据库连接池</li>
<li>获取连接对象</li>
<li>关闭对象</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dataSource.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * druid工具类</span></span><br><span class="line"><span class="comment"> * 1.获取连接对象</span></span><br><span class="line"><span class="comment"> * 2.关闭连接对象</span></span><br><span class="line"><span class="comment"> * 3.获取数据库连接池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">rs</span> <span class="operator">=</span> DruidUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            pro.load(rs);</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);<span class="comment">//初始化数据池对象</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> con</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet rs, Statement stmt, Connection con)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Statement stmt, Connection con)</span> &#123;</span><br><span class="line">        DruidUtils.close(<span class="literal">null</span>, stmt, con);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Spring-JDBC（JDBCTemplate）常用"><a href="#Spring-JDBC（JDBCTemplate）常用" class="headerlink" title="Spring  JDBC（JDBCTemplate）常用"></a>Spring  JDBC（JDBCTemplate）常用</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>Spring框架对JDBC的简单封装。提供了JDBCTemplate对象简化JDBC的开发。JDBCTemplate对象能自动close对象，极大方便了操作。</p>
<h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>导入jar包</p>
</li>
<li><p>创建JDBCTemplate对象。<strong>参数为数据库连接池DataSource</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource ds= DruidUtils.getDataSource();</span><br><span class="line">JdbcTemplate tmp=<span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(ds);</span><br></pre></td></tr></table></figure>

</li>
<li><p>调用方法来实现</p>
<ul>
<li>update</li>
<li>query（查询，通过BeanPropertyRowMapper封装成对象列表）</li>
<li>queryForObeject（查询，通过BeanPropertyRowMapper封装成对象）</li>
<li>queryForMap</li>
<li>queryForList</li>
</ul>
</li>
</ol>
<h2 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dataSource.jdbctmplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.dataSource.domain.Emp;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.dataSource.utils.DruidUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTemplateDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DataSource ds= DruidUtils.getDataSource();</span><br><span class="line">        JdbcTemplate tmp=<span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(ds);</span><br><span class="line">        String sql=<span class="string">&quot;SELECT * FROM emp where id=1001&quot;</span>;</span><br><span class="line">        <span class="comment">//封装成对象，参数用BeanPropertyRowMapper接口</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> tmp.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Emp.class));</span><br><span class="line">        System.out.println(emp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String sql1=<span class="string">&quot;SELECT * FROM emp;&quot;</span>;</span><br><span class="line">        <span class="comment">//封装成对象列表，参数用BeanPropertyRowMapper接口</span></span><br><span class="line">        List&lt;Emp&gt; emps = tmp.query(sql1, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Emp.class));</span><br><span class="line">        <span class="keyword">for</span> (Emp emp1 : emps) &#123;</span><br><span class="line">            System.out.println(emp1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询总的数据条数</span></span><br><span class="line">        String sql2=<span class="string">&quot;SELECT count(id) FROM emp;&quot;</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> tmp.queryForObject(sql2, Long.class);</span><br><span class="line">        System.out.println(num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/2022/01/12/Java%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 





<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>所谓注解，跟注释类似，用来对代码中的类、方法、属性进行说明。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li><p>编写文档：通过代码里面标识的注解来生成文档javadoc命令</p>
</li>
<li><p>代码分析：可以通过反射机制，得知该类、方法、属性是否有注解。比如可以通过反射，调用getAnnotation函数获取该注解然后进行解析注解中的属性。</p>
</li>
<li><p>编译检查：通过注解能够让编译器自动进行编译检查，比如@overide可以检查是否是重载函数</p>
<p>可以暂时理解为一个可以存放数据（注解的属性）的“特殊对象”。他的作用主要体现在可以解析他的属性值。看完《自定义注解》就明白了。</p>
</li>
</ol>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解就是标识注解的注解。也就是系统中定义好的注解，方便我们自定义注解的时候对该自定义注解进行描述。</p>
<p>这里只介绍两种最常用的元注解</p>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>这个元注解表示被描述的注解@Anno的适用范围,也就是说@Anno可以作用于类（TYPE）还是属性(FIELD)，又或是方法(METHOD)</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>Retention中文维持，表示被描述的注解的保持时间。我们一般设置为RUNTIME,表示时间是从字节码到JVM读取的时间段都能保持。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.example.example01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span><span class="comment">//被修饰的注解作用范围</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//被修饰的注解保持时间，RUNTIME表示从字节码到jVM读取阶段</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAno &#123;</span><br><span class="line">    <span class="comment">//属性列表，本质是方法</span></span><br><span class="line">    String <span class="title function_">className</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">methodName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="定义注解的格式"><a href="#定义注解的格式" class="headerlink" title="定义注解的格式"></a>定义注解的格式</h3><ol>
<li>通过@interface表示是一个注解（本质上是一个接口）</li>
<li>注解内部是属性列表，跟定义成员方法一样，返回值+函数名。</li>
<li>注解上面是元注解，用来限定该注解的特性，比如作用范围、保持时间等。</li>
</ol>
<h3 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h3><p>解析注解就是读取注解的属性。具体步骤</p>
<ul>
<li>创建字节码对象</li>
<li>字节码对象调用getAnnotation获取</li>
</ul>
<h2 id="案例1-通过注解获取类名和方法，并执行类中的方法"><a href="#案例1-通过注解获取类名和方法，并执行类中的方法" class="headerlink" title="案例1-通过注解获取类名和方法，并执行类中的方法"></a>案例1-通过注解获取类名和方法，并执行类中的方法</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>获取字节码对象</li>
<li>字节码对象调用getAnnotation获取注解对象，然后获取注解对象属性值类名和方法名</li>
<li>利用反射执行类中方法</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>MyAno.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.example.example01;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line">        <span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span><span class="comment">//被修饰的注解作用范围</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="comment">//被修饰的注解保持时间，RUNTIME表示从字节码到jVM读取阶段</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAno &#123;</span><br><span class="line">    <span class="comment">//属性列表，本质是方法</span></span><br><span class="line">    String <span class="title function_">className</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">methodName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.example.example01;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAno(className = &quot;cn.itcast.example.domain.Cat&quot;,methodName =&quot;shout&quot; )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;Main&gt; cls = Main.class;<span class="comment">//通过字节码获取注解对象</span></span><br><span class="line">        <span class="type">MyAno</span> <span class="variable">ano</span> <span class="operator">=</span> cls.getAnnotation(MyAno.class);<span class="comment">//获取注解对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> ano.className();</span><br><span class="line">        <span class="type">String</span> <span class="variable">mn</span> <span class="operator">=</span> ano.methodName();</span><br><span class="line">        Class&lt;?&gt; cls1 = Class.forName(cn);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls1.getConstructor().newInstance();</span><br><span class="line">        cls1.getMethod(mn).invoke(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Cat.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.example.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Dog.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.example.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;哇哦哇哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="案例2-通过注解实现测试框架，测试Calculator中的各个方法"><a href="#案例2-通过注解实现测试框架，测试Calculator中的各个方法" class="headerlink" title="案例2-通过注解实现测试框架，测试Calculator中的各个方法"></a>案例2-通过注解实现测试框架，测试Calculator中的各个方法</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>自定义一个方法注解</li>
<li>在需要测试的方法上加上注解</li>
<li>在测试类中利用反射机制获取Calculator字节码对象，获取该对象的所有方法对象。</li>
<li>方法对象调用getAnnotation获取注解，根据注解有无执行该方法对象。（主要利用了反射机制）</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>Calculator.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.example.example02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="comment">//加法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        str.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;1 + 0 =&quot;</span> + (<span class="number">1</span> + <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 - 0 =&quot;</span> + (<span class="number">1</span> - <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//乘法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mul</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 * 0 =&quot;</span> + (<span class="number">1</span> * <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除法</span></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">div</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 / 0 =&quot;</span> + (<span class="number">1</span> / <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;永无bug...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Check.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.example.example02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>TestCheck.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.example.example02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCheck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> calculator.getClass();</span><br><span class="line">        Method[] declaredMethods = cls.getDeclaredMethods();</span><br><span class="line"><span class="comment">//        FileWriter fw = new FileWriter(&quot;bug1.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;bug.txt&quot;</span>));</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,erorNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(declaredMethod);</span></span><br><span class="line">            <span class="type">Check</span> <span class="variable">annotation</span> <span class="operator">=</span> declaredMethod.getAnnotation(Check.class);</span><br><span class="line">           <span class="comment">//如果有注解</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span>!=annotation)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    declaredMethod.invoke(calculator);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    fw.write(declaredMethod.getName()+<span class="string">&quot;出异常了&quot;</span>);</span><br><span class="line">                    fw.newLine();</span><br><span class="line">                    fw.write(e.getCause().toString());</span><br><span class="line">                    fw.newLine();</span><br><span class="line">                    fw.write(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">                    fw.newLine();</span><br><span class="line">                    erorNum++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        fw.write(<span class="string">&quot;一共测试了&quot;</span>+sum+<span class="string">&quot;个函数&quot;</span>);</span><br><span class="line">        fw.newLine();</span><br><span class="line">        fw.write(<span class="string">&quot;出错了&quot;</span>+erorNum+<span class="string">&quot;个函数&quot;</span>);</span><br><span class="line">        fw.newLine();</span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际开发过程中我们一般是使用注解，一般不会去自定义注解，但是我们需要知道注解本质就是一个接口，在接口中定义一些方法列表（在注解中称为属性列表）。</p>
<p>可以利用反射机制获取注解，从而解析注解得到里面的属性。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>初学Netty SeverBootstrap和Bootstrap踩坑</title>
    <url>/2022/12/23/NettySeverBootstrap%E5%92%8CBootstrap%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="错误描述no-further-information-127-0-0-1-8090"><a href="#错误描述no-further-information-127-0-0-1-8090" class="headerlink" title="错误描述no further information: &#x2F;127.0.0.1:8090"></a>错误描述no further information: &#x2F;127.0.0.1:8090</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: no further information: /127.0.0.1:8090</span><br></pre></td></tr></table></figure>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>看到问题很明显，连接失败？刚开始以为是ip+端口号写错了，检查发现没有错误。<br>后来才发现server端ServerBootstrap写错成了客户端的BootStrap<br>将</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br></pre></td></tr></table></figure>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>SeverBootstrap和Bootstrap都是Netty的启动类，他们的主要作用就是配置相关参数（IP,端口等）并启动整个Netty服务。<br>ServerBootstrap:<strong>用于服务端的启动</strong><br>Boostrap：<strong>用于客户端的启动</strong></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy 快速入门</title>
    <url>/2022/01/25/Numpy%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 



<h1 id="一-Numpy概述"><a href="#一-Numpy概述" class="headerlink" title="一 Numpy概述"></a>一 Numpy概述</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>​	开源的python科学计算库</p>
<p>​	用于快速处理任意维度的数组</p>
<p>​	Numpy中存储对象ndarray</p>
<h2 id="2-创建"><a href="#2-创建" class="headerlink" title="2.创建"></a>2.创建</h2><p>np.array</p>
<h2 id="3-优势"><a href="#3-优势" class="headerlink" title="3.优势"></a>3.优势</h2><p>内存块风格，一体化存储</p>
<p>支持并行化运算</p>
<p>效率高与纯python–底层使用了c</p>
<h1 id="二-N维数组-ndarray"><a href="#二-N维数组-ndarray" class="headerlink" title="二 N维数组 ndarray"></a>二 N维数组 ndarray</h1><h2 id="1-ndarray的属性"><a href="#1-ndarray的属性" class="headerlink" title="1.ndarray的属性"></a>1.ndarray的属性</h2><p>属性名字            属性解释</p>
<p>ndarray.shape     数组维度元组</p>
<p>ndarray.ndim       数组维度</p>
<p>ndarray.size         数组中元素数量</p>
<p>ndarray.itemsize  一个数组元素的长度</p>
<p>ndarray.dtype		数组元素的类型</p>
<h2 id="2-ndarray的类型"><a href="#2-ndarray的类型" class="headerlink" title="2.ndarray的类型"></a>2.ndarray的类型</h2><ul>
<li><p>bool</p>
</li>
<li><p>int</p>
</li>
<li><p>float</p>
</li>
<li><p>str</p>
<p>注意：若不指定，整数默认int64,float64</p>
</li>
</ul>
<h1 id="三-基本操作"><a href="#三-基本操作" class="headerlink" title="三 基本操作"></a>三 基本操作</h1><h2 id="1-生成数组的方法"><a href="#1-生成数组的方法" class="headerlink" title="1.生成数组的方法"></a>1.生成数组的方法</h2><p> 生成0,1的方法</p>
<ul>
<li>np.ones()</li>
<li>np.ones_like()</li>
<li>np.zeros()</li>
</ul>
<h3 id="1-2-从现有的数组中生成"><a href="#1-2-从现有的数组中生成" class="headerlink" title="1.2 从现有的数组中生成"></a>1.2 从现有的数组中生成</h3><p>np.array–深拷贝</p>
<p>np.asarray–浅拷贝</p>
<h3 id="1-3生成固定范围的数组"><a href="#1-3生成固定范围的数组" class="headerlink" title="1.3生成固定范围的数组"></a>1.3生成固定范围的数组</h3><ul>
<li><p>np.linspace()</p>
<p>生成等间距的n个</p>
</li>
<li><p>np.arange()</p>
<p>每隔多少个生成数据</p>
</li>
<li><p>np.logspace</p>
<p>生成以10的N次幂的数据</p>
</li>
</ul>
<h3 id="1-4生成随机数组"><a href="#1-4生成随机数组" class="headerlink" title="1.4生成随机数组"></a>1.4生成随机数组</h3><h4 id="均匀分布生成"><a href="#均匀分布生成" class="headerlink" title="均匀分布生成"></a>均匀分布生成</h4><p>np.random.uniform()</p>
<p>参数：low,high,size</p>
<h4 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h4><p>np.random.normal()</p>
<p>参数：均值，方差，size</p>
<p>均值：图形的左右位置</p>
<p>方差：图像是瘦还是胖</p>
<p>​	值越小，图形瘦高，数据越集中</p>
<p>​	值越大，图形矮胖，数据越分散</p>
<h2 id="2-数组的索引、切片"><a href="#2-数组的索引、切片" class="headerlink" title="2.数组的索引、切片"></a>2.数组的索引、切片</h2><p>直接索引</p>
<p>先对行进行索引，再对列进行索引</p>
<h2 id="3-类型的修改"><a href="#3-类型的修改" class="headerlink" title="3.类型的修改"></a>3.类型的修改</h2><p>对象.astype</p>
<h2 id="4-数组去重"><a href="#4-数组去重" class="headerlink" title="4.数组去重"></a>4.数组去重</h2><p>np.unique()</p>
<h1 id="四-ndarray运算"><a href="#四-ndarray运算" class="headerlink" title="四 ndarray运算"></a>四 ndarray运算</h1><h2 id="1-逻辑运算"><a href="#1-逻辑运算" class="headerlink" title="1.逻辑运算"></a>1.逻辑运算</h2><p>大于，小于直接进行判断</p>
<p>赋值：满足要求，直接进行赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>]])</span><br><span class="line">a &gt;= <span class="number">4</span></span><br><span class="line">a[a &gt;= <span class="number">4</span>] = <span class="number">0</span> <span class="comment"># 可以根据bool进行赋值</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<h2 id="2-通用判断函数"><a href="#2-通用判断函数" class="headerlink" title="2.通用判断函数"></a>2.通用判断函数</h2><p>np.all()</p>
<p>所有满足要求，才返回True</p>
<p>np.any()</p>
<p>只有一个满足要求，就返回True</p>
<h2 id="3-三元运算符"><a href="#3-三元运算符" class="headerlink" title="3.三元运算符"></a>3.三元运算符</h2><p>np.where()</p>
<p>满足要求赋值第一个值，否则赋值第二个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>]])</span><br><span class="line">np.where(a&gt;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)<span class="comment"># 第一个参数逻辑判断，第二三个参数赋对应的值</span></span><br></pre></td></tr></table></figure>

<p>np.logical_and()</p>
<p>np.logical_or()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>]])</span><br><span class="line">np.where(np.logical_and(a&gt;=<span class="number">4</span>,a&lt;=<span class="number">5</span>),<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-统计运算"><a href="#4-统计运算" class="headerlink" title="4.统计运算"></a>4.统计运算</h2><p>min</p>
<p>max</p>
<p>midian–中位数</p>
<p>mean–平均值</p>
<p>std–标准差</p>
<p>var–方差</p>
<p>argmax–最大值下标</p>
<p>argmin–最小值下标</p>
<h1 id="五-矩阵"><a href="#五-矩阵" class="headerlink" title="五 矩阵"></a>五 矩阵</h1><h2 id="1-矩阵和向量"><a href="#1-矩阵和向量" class="headerlink" title="1.矩阵和向量"></a>1.矩阵和向量</h2><p>矩阵：二维数组</p>
<p>向量：一维数组，行向量和列向量</p>
<h2 id="2-加法和标量乘法"><a href="#2-加法和标量乘法" class="headerlink" title="2.加法和标量乘法"></a>2.加法和标量乘法</h2><p>加法：对应位置相加</p>
<p>乘法：标量和每个位置的元素相乘</p>
<h2 id="3-矩阵向量乘法"><a href="#3-矩阵向量乘法" class="headerlink" title="3.矩阵向量乘法"></a>3.矩阵向量乘法</h2><p>【M行，N列】x【N行，O列】&#x3D;【M行，O列】</p>
<h2 id="4-矩阵乘法性质"><a href="#4-矩阵乘法性质" class="headerlink" title="4.矩阵乘法性质"></a>4.矩阵乘法性质</h2><p>满足结合律不满足交换律</p>
<h2 id="5-单位矩阵"><a href="#5-单位矩阵" class="headerlink" title="5.单位矩阵"></a>5.单位矩阵</h2><p>对角线为1，其他位置为0的矩阵</p>
<h2 id="6-逆矩阵"><a href="#6-逆矩阵" class="headerlink" title="6.逆矩阵"></a>6.逆矩阵</h2><p>矩阵A*举证B&#x3D;单位矩阵I</p>
<p>那么A和B互为逆矩阵</p>
<h2 id="7-转置"><a href="#7-转置" class="headerlink" title="7.转置"></a>7.转置</h2><p>行列互换</p>
<h1 id="六-数组间运算"><a href="#六-数组间运算" class="headerlink" title="六 数组间运算"></a>六 数组间运算</h1><h2 id="1-数组和数字是直接可以进行运算"><a href="#1-数组和数字是直接可以进行运算" class="headerlink" title="1.数组和数字是直接可以进行运算"></a>1.数组和数字是直接可以进行运算</h2><h2 id="2-数组和数组"><a href="#2-数组和数组" class="headerlink" title="2.数组和数组"></a>2.数组和数组</h2><p>满足广播机制</p>
<p>​	纬度相同</p>
<p>​	shape对应位置为1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">arr2 = np.array([[<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">1</span>]])</span><br><span class="line">arr1+arr2</span><br></pre></td></tr></table></figure>



<h2 id="3-矩阵乘法api"><a href="#3-矩阵乘法api" class="headerlink" title="3.矩阵乘法api"></a>3.矩阵乘法api</h2><p>​	np.dot–点乘</p>
<p>​	np.matmul–矩阵相乘</p>
<p>注意：np.dot既可以进行标量相乘，也可以进行向量乘法。np.matnul只能进行向量乘法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">num=<span class="number">3</span></span><br><span class="line">arr2 = np.array([[<span class="number">2</span>], [<span class="number">2</span>]])</span><br><span class="line">res1=np.dot(arr1,<span class="number">1</span>)</span><br><span class="line">res1</span><br><span class="line">res2=np.dot(arr1,arr2)</span><br><span class="line">res2</span><br><span class="line">res3=np.matmul(arr1,arr2)<span class="comment">#只能两个矩阵相乘</span></span><br><span class="line">res3==res2</span><br></pre></td></tr></table></figure>

<h1 id="numpy官网文档"><a href="#numpy官网文档" class="headerlink" title="numpy官网文档"></a><a href="https://numpy.org/doc/stable/reference/routines.array-creation.html">numpy官网文档</a></h1>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas快速入门</title>
    <url>/2022/01/29/Pandas%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 



<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>开源的数据挖掘库</p>
<p>用于数据探索</p>
<p>封装了matplotlib,numpy</p>
<h2 id="案例知识点"><a href="#案例知识点" class="headerlink" title="案例知识点"></a>案例知识点</h2><p>pd.DataFrame(ndarray)–创建DataFrame</p>
<p>pd.date_range()–创建日期</p>
<p>参数： start–开始日期</p>
<p>​			end–结束日期</p>
<p>​			perios–时间跨度</p>
<p>​			freq –统计时间方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_change=np.random.normal(<span class="number">0</span>,<span class="number">1</span>,(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">stock_change</span><br><span class="line">stock_code=[<span class="string">&quot;第&#123;&#125;股票&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(stock_change.shape[<span class="number">0</span>])]</span><br><span class="line">stock_time=pd.date_range(start=<span class="string">&quot;20210103&quot;</span>,periods=stock_change.shape[<span class="number">1</span>])</span><br><span class="line">stock_c=pd.DataFrame(stock_change,index=stock_code, columns=stock_time)</span><br><span class="line">stock_c</span><br></pre></td></tr></table></figure>

<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象.shape</span><br><span class="line">对象.values</span><br><span class="line">对象.index</span><br><span class="line">对象.columns</span><br><span class="line">对象.T --转置</span><br><span class="line">对象.head --查看前几行</span><br><span class="line">对象.tail --查看后几行</span><br></pre></td></tr></table></figure>

<h2 id="DataFrame设置索引"><a href="#DataFrame设置索引" class="headerlink" title="DataFrame设置索引"></a>DataFrame设置索引</h2><h3 id="修改行列索引"><a href="#修改行列索引" class="headerlink" title="修改行列索引"></a>修改行列索引</h3><p>必须整行或者整列去进行修改,直接通过属性更改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_i=[<span class="string">&quot;股票&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(stock_change.shape[<span class="number">0</span>])]</span><br><span class="line">stock_c.index=stock_i</span><br><span class="line">stock_c</span><br></pre></td></tr></table></figure>



<h3 id="重设索引"><a href="#重设索引" class="headerlink" title="重设索引"></a>重设索引</h3><p>对象.reset_index()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_c.reset_index(drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h1 id="基本数据操作"><a href="#基本数据操作" class="headerlink" title="基本数据操作"></a>基本数据操作</h1><h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><ol>
<li><p>直接 –先列后行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_data[<span class="string">&quot;open&quot;</span>][<span class="string">&quot;2018-02-27&quot;</span>] <span class="comment"># 注意pandas中必须是先行后列,这种方式不可以切片</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>loc –先行后列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用先行后列必须使用loc</span></span><br><span class="line">stock_data.loc[<span class="string">&quot;2018-02-27&quot;</span>:<span class="string">&quot;2018-02-14&quot;</span>,<span class="string">&quot;open&quot;</span>]</span><br></pre></td></tr></table></figure>

</li>
<li><p>iloc–先行后列，索引值的下标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_data.iloc[:<span class="number">3</span>,:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

</li>
<li><p>下标和索引混合使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_data.loc[stock_data.index[<span class="number">0</span>:<span class="number">2</span>],(<span class="string">&quot;high&quot;</span>,<span class="string">&quot;low&quot;</span>)] <span class="comment"># 如果要数字和字符串混合用，使用loc。数字这里用属性进行切片</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_data.iloc[:<span class="number">3</span>,stock_data.columns.get_indexer([<span class="string">&quot;close&quot;</span>,<span class="string">&quot;volume&quot;</span>])]</span><br></pre></td></tr></table></figure>

<h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><ol>
<li><p>[]方式或者.属性方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_data[<span class="string">&quot;volume&quot;</span>]=<span class="number">100</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">stock_data.volume=<span class="number">100</span></span><br><span class="line">stock_data[<span class="string">&quot;volume&quot;</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ol>
<li><p>dataframe</p>
<p>对象.sort_values（）</p>
<p>对象.sort_index()</p>
<p>参数：by 接受多个值</p>
</li>
<li><p>series</p>
<p>对象.sort_values（）</p>
<p>对象.sort_index()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stock_data.sort_values(by=[<span class="string">&quot;open&quot;</span>],ascending=<span class="literal">False</span>).head()</span><br><span class="line">stock_data.sort_index(ascending=<span class="literal">False</span>).head()</span><br><span class="line">stock_data[<span class="string">&quot;open&quot;</span>].sort_values().head()</span><br><span class="line">stock_data[<span class="string">&quot;open&quot;</span>].sort_index().head()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>方法add,sub..</p>
<p>也可以直接用符号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data=pd.read_csv(<span class="string">&quot;./data/test.csv&quot;</span>)</span><br><span class="line">data.head()</span><br><span class="line">data[<span class="string">&quot;close&quot;</span>].add(<span class="number">4</span>).head()</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol>
<li><p>逻辑运算符号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">&quot;open&quot;</span>]&gt;<span class="number">23</span></span><br><span class="line">data[data[<span class="string">&quot;open&quot;</span>]&gt;<span class="number">23</span>].head()</span><br><span class="line"><span class="comment">## 多个判断条件</span></span><br><span class="line">data[(data[<span class="string">&quot;open&quot;</span>]&gt;<span class="number">23</span>)&amp;(data[<span class="string">&quot;high&quot;</span>]&gt;<span class="number">25</span>)].head()</span><br></pre></td></tr></table></figure>

</li>
<li><p>逻辑运算函数</p>
</li>
</ol>
<ul>
<li><p>dataframe.query(“”)</p>
</li>
<li><p>series.isin</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.query(<span class="string">&quot;open&gt;23.53 &amp; high&gt;25&quot;</span>).head()</span><br><span class="line">data[<span class="string">&quot;open&quot;</span>].isin([<span class="number">23.5</span>])</span><br><span class="line">data[data[<span class="string">&quot;open&quot;</span>].isin([<span class="number">23.5</span>])].head()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><ol>
<li><p>对象.describe()</p>
</li>
<li><p>统计函数</p>
<ul>
<li>sum</li>
<li>mean</li>
<li>mode–众数</li>
<li>idxmin–最大值的索引</li>
<li>idxmax–最小值的索引</li>
</ul>
</li>
<li><p>累计统计函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cumsum</td>
<td align="center">计算前n个数的和</td>
</tr>
<tr>
<td align="center">cummax</td>
<td align="center">计算前n个数的max</td>
</tr>
<tr>
<td align="center">cummin</td>
<td align="center">计算前n个数的min</td>
</tr>
<tr>
<td align="center">cumprod</td>
<td align="center">计算前n个数的积</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>apply(func,axis&#x3D;0)</p>
<p>定义一个对列，最大值－最小值的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[[<span class="string">&quot;open&quot;</span>, <span class="string">&quot;high&quot;</span>, <span class="string">&quot;close&quot;</span>]].apply(<span class="keyword">lambda</span> x: x.<span class="built_in">max</span>()-x.<span class="built_in">min</span>())</span><br></pre></td></tr></table></figure>

<h2 id="pandas画图"><a href="#pandas画图" class="headerlink" title="pandas画图"></a>pandas画图</h2><p>DataFrame.plot()</p>
<p>参数：kind</p>
<ul>
<li>line–折线图</li>
<li>bar</li>
<li>barh–条形图</li>
<li>hist–直方图</li>
<li>pie</li>
<li>scatter</li>
</ul>
<h2 id="文件读取和存储"><a href="#文件读取和存储" class="headerlink" title="文件读取和存储"></a>文件读取和存储</h2><ol>
<li><p>csv</p>
<ul>
<li><p>读取–pd.read_csv</p>
<p>参数：</p>
<p>usecols</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd=pd.read_csv(<span class="string">&quot;./data/stock_day.csv&quot;</span>,sep=<span class="string">&quot;,&quot;</span>,usecols=[<span class="string">&quot;open&quot;</span>,<span class="string">&quot;high&quot;</span>])<span class="comment">#可以指定读取哪几行</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>存储–pd.to_csv</p>
<p>参数：</p>
<p>columns–保存哪列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.to_csv(<span class="string">&quot;./data/stock_day_open.csv&quot;</span>,columns=[<span class="string">&quot;open&quot;</span>],index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>hdf(推荐使用)</p>
<p>读取–pd.read_hdf()</p>
<p>写入–pd.to_hdf()</p>
<p>​			参数：orient–按照什么方式进行读取或者写入</p>
<p>​						lines–是否按照行读取和写入</p>
<p>注意：保存文件是*.h5（后缀名）</p>
<p>好处：</p>
<ul>
<li>压缩方式，读取效率快</li>
<li>压缩后，节省空间</li>
<li>支持跨平台</li>
</ul>
</li>
<li><p>json</p>
<p>读取-pd.read_json()</p>
<p>写入–pd.to_json()</p>
</li>
</ol>
<h2 id="缺失值-处理"><a href="#缺失值-处理" class="headerlink" title="缺失值-处理"></a>缺失值-处理</h2><ol>
<li><p>判断数据是否为NaN</p>
<p>np.any(np.isnull(movie))–如果有一个缺失值，就返回True</p>
<p>np.all(np.notnull(movie))–如果有一个缺失值返回False</p>
</li>
<li><p>处理方式</p>
<p>存在缺失值nan,并且是np.nan</p>
<ul>
<li><p>删除存在缺失值的行–dropna(axis&#x3D;’rows’)</p>
</li>
<li><p>替换缺失值–fillna(value,inplace&#x3D;True)</p>
<p>value:替换成的值</p>
<p>inplace:True会修改原来数据</p>
</li>
</ul>
<p>其他符号比如？</p>
<p>​	利用replace函数替换</p>
<p>​		参数：to_place–替换前的值</p>
<p>​					value–替换后的值</p>
</li>
</ol>
<h2 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h2><ol>
<li><p>什么是数据离散化</p>
<p>把一些连续数据分到某个区间，最后用不同的符号或者数字表达</p>
</li>
<li><p>数据离散化api</p>
<p>pd.qcut()  –把数据大致分为数量相等的几类</p>
<p>pd.cut（）–指定分组间隔</p>
<p>数量统计：</p>
<p>​					对象.value_counts</p>
</li>
<li><p>one-hot编码</p>
<p>就是把数据转换成0,1统计类型</p>
<p>别名：哑变量，热独编码</p>
<p>api:    pd.get_dummies()</p>
</li>
</ol>
<h2 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h2><p>pd.concat()  –参数axis&#x3D;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat([left,right],join=<span class="string">&#x27;inner&#x27;</span>,axis=<span class="number">1</span>,ignore_index=<span class="number">0</span>)<span class="comment"># 内连接默认是index，好像不能调节</span></span><br></pre></td></tr></table></figure>

<p>pd.merge()</p>
<p>​			left   –左表</p>
<p>​			right  –右表</p>
<p>​			on     –指定键</p>
<p>​			how   – 按照什么方式进行拼接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left,right,how=<span class="string">&quot;inner&quot;</span>,on=[<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;key2&quot;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h2><ol>
<li><p>什么是交叉表，透视表</p>
<p>就是探索两列数据之间的关系</p>
</li>
<li><p>pd.crosstab()</p>
<p>返回具体数量</p>
</li>
<li><p>对象.privot_table（数据透视表）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.pivot_table(index=<span class="string">&#x27;weekday&#x27;</span>,values=<span class="string">&#x27;p_c1&#x27;</span>,aggfunc=np.mean)  <span class="comment"># index表示索引，values表示要查看的值,aggcunc表示聚合函数的操作</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><a href="https://www.cnblogs.com/Yanjy-OnlyOne/p/11195621.html">Api参数详解链接</a></p>
<h2 id="分组和聚合"><a href="#分组和聚合" class="headerlink" title="分组和聚合"></a>分组和聚合</h2><ol>
<li><p>对象.groupby()</p>
<p>参数：as_index 是否进行索引</p>
<p>注意：分组后一定要聚合，下面有常用的两种方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.groupby([<span class="string">&quot;color&quot;</span>])[<span class="string">&#x27;price1&#x27;</span>].mean() <span class="comment">#对颜色分组对prices1进行聚合</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col.groupby([<span class="string">&quot;color&quot;</span>]).count()</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat&amp;Servlet快速入门</title>
    <url>/2022/02/06/Tomcat&amp;Servlet%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>





<h2 id="web概念"><a href="#web概念" class="headerlink" title="web概念"></a>web概念</h2><ol>
<li><p>软件架构</p>
<p>C&#x2F;S:客户端&#x2F;服务器端</p>
<p>B&#x2F;s:浏览器&#x2F;服务器端</p>
</li>
<li><p>资源分类</p>
<ul>
<li><p>静态资源</p>
<p>所有用户访问后得到的结果是一样的，即被称为静态资源，比如html、css、javascript</p>
</li>
<li><p>动态资源</p>
<p>每个用户访问后得到的结果是不一样的，被称为动态资源。动态资源访问后需要转换为静态资源返回给浏览器端。比如：servlet、jsp、asp</p>
</li>
</ul>
</li>
<li><p>网络通信三要素</p>
<ul>
<li><p>IP</p>
<p>电子设备在网络中的唯一标识</p>
</li>
<li><p>端口</p>
<p>应用程序在计算机中的唯一标识</p>
</li>
<li><p>网络协议</p>
<p>规定了数据传输的规则</p>
<p>tcp:安全协议，三次握手。HTTP、FTP、SMTP、POP3</p>
<p>udp:不安全协议，速度快。DHCP、DNS、RIP、SNTP</p>
</li>
</ul>
</li>
</ol>
<h2 id="web服务器软件"><a href="#web服务器软件" class="headerlink" title="web服务器软件"></a>web服务器软件</h2><ol>
<li><p>服务器</p>
<p>安装了服务器软件的计算机</p>
</li>
<li><p>服务器软件</p>
<p>接受用户请求、处理用户请求、做出响应</p>
</li>
<li><p>web服务器软件</p>
<p>接受用户请求、处理用户请求、做出响应。在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目。</p>
<p>Tomcat就是一种web服务器软件。</p>
</li>
</ol>
<h2 id="Tomcat使用"><a href="#Tomcat使用" class="headerlink" title="Tomcat使用"></a>Tomcat使用</h2><ol>
<li><p>部署项目</p>
<ul>
<li><p>直接放在webapps目录下即可，访问的时候文件夹&#x2F;文件名</p>
</li>
<li><p>简化部署，将项目打包成一个war包，将war包放在webapps目录下，war包会自动解压缩，访问方式同上</p>
</li>
<li><p>配置conf&#x2F;server.xml文件，可以将项目放在任意目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	在&lt;Host&gt;标签体中配置</span><br><span class="line">&lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>docBase:项目存放的路径 </p>
<p>path：虚拟目录</p>
</li>
<li><p>热部署方式(推荐)</p>
<p>在conf&#x2F;Catalina&#x2F;localhost创建一个name.xml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Context docBase=&quot;D:\hello&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>虚拟目录就是name</p>
</li>
</ul>
</li>
</ol>
<h2 id="java动态项目"><a href="#java动态项目" class="headerlink" title="java动态项目"></a>java动态项目</h2><p><img src="https://img-blog.csdnimg.cn/5e87f0cfbf9c452cbd1ad6bd54f48de9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>WEB-INF目录</p>
<p>–web.xml		  核心配置文件</p>
<p>–classes目录    放置字节码文件的目录</p>
<p>–lib目录			 放置依赖的jar包</p>
<h2 id="IDEA集成Tomcat"><a href="#IDEA集成Tomcat" class="headerlink" title="IDEA集成Tomcat"></a>IDEA集成Tomcat</h2><p><img src="https://img-blog.csdnimg.cn/3be4235f4c7a4898a9568e49c4fc20e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="servlet（server-applet）"><a href="#servlet（server-applet）" class="headerlink" title="servlet（server applet）"></a>servlet（server applet）</h2><ol>
<li><p>概念</p>
<p>运行在服务端的小程序</p>
<p>本质上是一个接口，定义了java类被浏览器访问到的规则</p>
</li>
<li><p>快速入门</p>
<ul>
<li><p>创建一个javaEE项目</p>
</li>
<li><p>定义一个类实现servlet接口</p>
</li>
<li><p>实现抽象方法</p>
</li>
<li><p>配置servlet</p>
<p>在web.xml文件中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.web.servlet.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>执行原理</p>
<ul>
<li>服务器解析浏览器输入的路径，解析URL路径，获取servlet资源路径</li>
<li>查找web.xml，看是否有对应的<url-pattern>中的内容</li>
<li>如果有，再找到配置文件中对应的servlet的全类名，将该类字节码对象加载进内存，并创建字节码对象</li>
<li>调用其方法</li>
</ul>
</li>
<li><p>servlet3.0支持注解配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/requestDemo2&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="IDEA与tomcat配置"><a href="#IDEA与tomcat配置" class="headerlink" title="IDEA与tomcat配置"></a>IDEA与tomcat配置</h2><ol>
<li><p>IDEA会为每一个tomcat部署的项目单独建立一个配置文件。查看控制台的log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;</span><br></pre></td></tr></table></figure>

</li>
<li><p>工作空间项目    和     tomcat部署的web项目</p>
<ul>
<li>tomcat真正访问的是“tomcat部署的web项目”，”tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源</li>
<li>WEB-INF目录下的资源不能被浏览器直接访问。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat端口80被占用</title>
    <url>/2022/01/21/Tomcat%E7%AB%AF%E5%8F%A380%E8%A2%AB%E5%8D%A0%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="使用Tomcat端口80被System占用解决方法-关闭IIS服务"><a href="#使用Tomcat端口80被System占用解决方法-关闭IIS服务" class="headerlink" title="使用Tomcat端口80被System占用解决方法-关闭IIS服务"></a>使用Tomcat端口80被System占用解决方法-关闭IIS服务</h1><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用Tomcat的时候，在浏览器中想要直接通过ip地址，不输入端口，使用默认端口80访问Tomcat。配置Tomcat的端口号为80后，发现浏览器不能访问Tomcat,通过查看日志文件发现80端口被占用，如下</p>
<p><img src="https://img-blog.csdnimg.cn/6a9a281b331b4a8b89a7ecd0a1d96697.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>为了解决这个问题，首先的想法就是杀死占用80端口的进程。</p>
<h1 id="寻找问题"><a href="#寻找问题" class="headerlink" title="寻找问题"></a>寻找问题</h1><h2 id="参看占用80端口的进程PID"><a href="#参看占用80端口的进程PID" class="headerlink" title="参看占用80端口的进程PID"></a>参看占用80端口的进程PID</h2><p>在cmd窗口输入一下命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure>

<p>发现PID为4的进程占用了端口，然后去任务管理器查看PID为4的进程，发现是System进程<br><img src="https://img-blog.csdnimg.cn/c1ffd50d0199409db448405ca229a48c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>发现是System进程占用了该端口,但是该进程不能直接关闭，我们猜测是系统的某个服务占用了该端口。我们查看系统的http服务命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh http show servicestate </span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/7d30321447b548f5a3fde431eab0c640.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>发现是DefaltAPPPool这个东西占用了80端口，它的PID是<strong>4640</strong>。我们任务管理器找到该进程，通过右键转到服务</p>
<p><img src="https://img-blog.csdnimg.cn/4c7465489eb5452aa260a7d64cda9168.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/de542597bc2f4e7ebad102ab0c8dd946.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>看到图中的服务，这里原因也就找到了，IIS的World Wid Web Publishing Service 万维网服务的问题。</p>
<h1 id="解决方法-关闭IIS服务"><a href="#解决方法-关闭IIS服务" class="headerlink" title="解决方法-关闭IIS服务"></a>解决方法-关闭IIS服务</h1><p>打开<strong>控制面板</strong>-&gt;进入<strong>程序</strong>-&gt;<strong>启用或关闭windows服务</strong>,将<strong>Internet Information Services</strong>关闭，重启电脑即可。</p>
<p><img src="https://img-blog.csdnimg.cn/84dca3635cb344719161e603841dd509.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>Tomcat就能通过默认80端口访问啦！亲测有效！</p>
<p><img src="https://img-blog.csdnimg.cn/18e71d0156274911961397016535c6b8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/firstdream/p/8057646.html">Windows下80端口被进程System占用的解决方法</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java{{}}匿名内部类初始化</title>
    <url>/2022/12/20/java%7B%7B%7D%7D%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在刷题的时候看到有人写代码用了<code>&#123;&#123;&#125;&#125;</code>写法，以前没有见过，特此记录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><code>&#123;&#123;&#125;&#125;</code>这种方法是对一个集合进行初始化操作，避免了对集合初始化进行一条一条的add。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()&#123;</span><br><span class="line">&#123;</span><br><span class="line">	add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">	add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">	add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="comment">// 和下面功能实现一样</span></span><br><span class="line"><span class="comment">//        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span></span><br><span class="line"><span class="comment">//        list.add(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">//        list.add(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//        list.add(&quot;c&quot;);</span></span><br></pre></td></tr></table></figure>

<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>第一个括号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了一个继承于ArrayList的类，它没有名字</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()&#123;</span><br><span class="line">  <span class="comment">//在这里对这个类进行具体定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的括号表示对一个类进行具体的定义。</p>
<p>第二个括号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//这里是实例初始化块，可以直接调用父类的非私有方法或访问非私有成员</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 这里的括号表示实例初始化块（Instance Initialiazer Block）,也被称为非静态初始化块。</p>
<p>类比于静态初始块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="comment">//静态初始块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://">https://www.cnblogs.com/dengyungao/p/7524981.html</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>XML要点总结</title>
    <url>/2022/01/21/XML%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="XML可扩展标记语言"><a href="#XML可扩展标记语言" class="headerlink" title="XML可扩展标记语言"></a>XML可扩展标记语言</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>XML（Extensible Markup Language可拓展标记语言）</p>
<h2 id="2-功能"><a href="#2-功能" class="headerlink" title="2.功能"></a>2.功能</h2><p>存储数据，一般用于做配置文件，或者在网络中传输（通常用json文件）</p>
<h2 id="3-XML和HTML区别"><a href="#3-XML和HTML区别" class="headerlink" title="3.XML和HTML区别"></a>3.XML和HTML区别</h2><ol>
<li>xml标签是自定义的，所以需要有约束文件。</li>
<li>xml的语法严格，html语法松散</li>
<li>xml主要用于存储数据，html展示数据</li>
</ol>
<h2 id="4-语法"><a href="#4-语法" class="headerlink" title="4.语法"></a>4.语法</h2><ul>
<li>文档后缀名xml</li>
<li>第一行<code>&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf8&#39;?&gt; </code>是文档声明</li>
<li>xml中有且仅有一个根标签</li>
<li>属性值要用（单双）引号引起来</li>
<li>区分大小写</li>
</ul>
<h2 id="5-快速入门"><a href="#5-快速入门" class="headerlink" title="5.快速入门"></a>5.快速入门</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; ?&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">gender</span>&gt;</span>male<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&#x27;2&#x27;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">name</span>&gt;</span>lisi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">gender</span>&gt;</span>female<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-主要部分"><a href="#6-主要部分" class="headerlink" title="6.主要部分"></a>6.主要部分</h2><h3 id="1-文档声明"><a href="#1-文档声明" class="headerlink" title="1.文档声明"></a>1.文档声明</h3><h4 id="1-格式"><a href="#1-格式" class="headerlink" title="1.格式"></a>1.格式</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml 属性列表 ?&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="2-属性列表"><a href="#2-属性列表" class="headerlink" title="2.属性列表"></a>2.属性列表</h4><ul>
<li>version:版本号，一般用1.0</li>
<li>encoding:编码方式。</li>
<li>standalone：是否独立，yes 或者 no用于表示是否依赖其他文件</li>
</ul>
<h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h3><p>id值是唯一的</p>
<h1 id="2-约束：规定XML文档的书写诡诈"><a href="#2-约束：规定XML文档的书写诡诈" class="headerlink" title="2.约束：规定XML文档的书写诡诈"></a>2.约束：规定XML文档的书写诡诈</h1><h2 id="1-要求"><a href="#1-要求" class="headerlink" title="1.要求"></a>1.要求</h2><ul>
<li>能够在xml中引入约束文档</li>
<li>能够简单读懂约束文档</li>
</ul>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><h3 id="1-DTD-Document-Type-Define，简单的文档类型约束技术"><a href="#1-DTD-Document-Type-Define，简单的文档类型约束技术" class="headerlink" title="1.DTD:Document Type Define，简单的文档类型约束技术"></a>1.DTD:Document Type Define，简单的文档类型约束技术</h3><h4 id="1-将约束规则引入xml文件中两种方式"><a href="#1-将约束规则引入xml文件中两种方式" class="headerlink" title="1.将约束规则引入xml文件中两种方式"></a>1.将约束规则引入xml文件中两种方式</h4><ul>
<li>本地：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;文件位置&quot;&gt;</code></li>
<li>网络：<code>&lt;!DOCTYPE 根标签名 PUBLIC&quot;文件位置&quot;&gt;</code></li>
</ul>
<h4 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--从外部引入文档类型定义--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;!DOCTYPE students SYSTEM &quot;student.dtd&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--内部定义文档类型定义--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">students</span> [</span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="keyword">students</span> (<span class="keyword">student</span>*) &gt;</span> &lt;!--表示students标签下student标签可以无数个--&gt;</span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="keyword">student</span> (<span class="keyword">name</span>,<span class="keyword">age</span>,<span class="keyword">sex</span>)&gt;</span>&lt;!--表示student下标签有name、age、sex--&gt;</span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="keyword">name</span> (<span class="keyword">#PCDATA</span>)&gt;</span>&lt;!--表示name类型为parse character data类型--&gt;</span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="keyword">age</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="keyword">sex</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ATTLIST <span class="keyword">student</span> <span class="keyword">number</span> <span class="keyword">ID</span> <span class="keyword">#REQUIRED</span>&gt;</span>&lt;!--表示属性列表，student标签的number属性是唯一的（iD）,且必须的（REQUIRED）--&gt;</span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ENTITY <span class="keyword">msg</span> <span class="string">&quot;hello&quot;</span>&gt;</span> &lt;!-- 表示定义一个实体引用，可以直接用msg表示&quot;hello&quot; --&gt;</span></span><br><span class="line"><span class="meta">        ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;first&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">age</span>&gt;</span>12<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;second&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="symbol">&amp;msg;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">age</span>&gt;</span>12<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-Schema-略微复杂的xml文档约束技术"><a href="#2-Schema-略微复杂的xml文档约束技术" class="headerlink" title="2.Schema:略微复杂的xml文档约束技术"></a>2.Schema:略微复杂的xml文档约束技术</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	1.填写xml文档的根元素</span></span><br><span class="line"><span class="comment">	2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line"><span class="comment">	3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;</span></span><br><span class="line"><span class="comment">	4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot; </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns</span>=<span class="string">&quot;http://www.itcast.cn/xml&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.itcast.cn/xml  student.xsd&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上面表示引入约束文件--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    第一句表示引入w3cschool定义的命名空间，并且取别名xsi</span></span><br><span class="line"><span class="comment">    第三句(先看第三句)表示该xml文件引入本地的xsd约束文件student.xsd（使用w3cschool定义的命名空间xsi下schemaLocation命令），并且用别名http://www.itcast.cn/xml代替</span></span><br><span class="line"><span class="comment">    第二句表示命名空间http://www.itcast.cn/xml不在标签前面加前缀，默认是该命名空间如students标签未加前缀就表示该命名空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">&quot;heima_0001&quot;</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">name</span>&gt;</span>tom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">		 </span><br><span class="line"> <span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="3-解析"><a href="#3-解析" class="headerlink" title="3.解析"></a>3.解析</h1><h2 id="1-方式"><a href="#1-方式" class="headerlink" title="1.方式"></a>1.方式</h2><ul>
<li><p>DOM</p>
<p>将标记语言一次性加载进内存形成DOM树。因为比较占内存，所以一般用于PC端</p>
</li>
<li><p>SAX</p>
<p>逐行读取，是基于事件驱动的，一般用于手机端，因为内存小。</p>
</li>
</ul>
<h2 id="2-XML解析器JSOUP"><a href="#2-XML解析器JSOUP" class="headerlink" title="2.XML解析器JSOUP"></a>2.XML解析器JSOUP</h2><h3 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h3><h4 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h4><ol>
<li>导入jsoup的jar包</li>
<li>获取document对象</li>
<li>获取标签Element对象</li>
<li>获取数据</li>
</ol>
<h4 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> JsoupDemo1.class.getClassLoader().getResource(<span class="string">&quot;student.xml&quot;</span>).getPath();</span><br><span class="line">        <span class="comment">//2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(path), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//3.获取元素对象 Element</span></span><br><span class="line">        <span class="type">Elements</span> <span class="variable">elements</span> <span class="operator">=</span> document.getElementsByTag(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(elements.size());</span><br><span class="line">        <span class="comment">//3.1获取第一个name的Element对象</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">element</span> <span class="operator">=</span> elements.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//3.2获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> element.text();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-主要对象使用"><a href="#2-主要对象使用" class="headerlink" title="2.主要对象使用"></a>2.主要对象使用</h3><h4 id="1-Document"><a href="#1-Document" class="headerlink" title="1.Document"></a>1.Document</h4><p>Jsoup静态方法parsexml文件获取</p>
<h4 id="2-Element"><a href="#2-Element" class="headerlink" title="2.Element"></a>2.Element</h4><p>通过getElementByxx获取，下面也会介绍快捷的方式select获取xpath获取</p>
<h4 id="3-获取属性值"><a href="#3-获取属性值" class="headerlink" title="3.获取属性值"></a>3.获取属性值</h4><p>String attr(String key)</p>
<h4 id="4-获取文本"><a href="#4-获取文本" class="headerlink" title="4.获取文本"></a>4.获取文本</h4><ul>
<li>string text()</li>
<li>string html()</li>
</ul>
<h3 id="3-快捷查询1selector"><a href="#3-快捷查询1selector" class="headerlink" title="3.快捷查询1selector"></a>3.快捷查询1selector</h3><ul>
<li>select(String cssQuery)，就是css中定位元素的方法</li>
<li>参考文档中的Selector类中的方法</li>
</ul>
<h3 id="4-快捷查询2xpath"><a href="#4-快捷查询2xpath" class="headerlink" title="4.快捷查询2xpath"></a>4.快捷查询2xpath</h3><ul>
<li><p>需要导入xpath对应的jar包</p>
</li>
<li><p>new JXDocument对象，参数为jsoup获取的document对象</p>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取student.xml的path</span></span><br><span class="line">		        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> JsoupDemo6.class.getClassLoader().getResource(<span class="string">&quot;student.xml&quot;</span>).getPath();</span><br><span class="line">		        <span class="comment">//2.获取Document对象</span></span><br><span class="line">		        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.parse(<span class="keyword">new</span> <span class="title class_">File</span>(path), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		        <span class="comment">//3.根据document对象，创建JXDocument对象</span></span><br><span class="line">		        <span class="type">JXDocument</span> <span class="variable">jxDocument</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JXDocument</span>(document);</span><br><span class="line">		</span><br><span class="line">		        <span class="comment">//4.结合xpath语法查询</span></span><br><span class="line">		        <span class="comment">//4.1查询所有student标签</span></span><br><span class="line">		        List&lt;JXNode&gt; jxNodes = jxDocument.selN(<span class="string">&quot;//student&quot;</span>);</span><br><span class="line">		        <span class="keyword">for</span> (JXNode jxNode : jxNodes) &#123;</span><br><span class="line">		            System.out.println(jxNode);</span><br><span class="line">		        &#125;</span><br><span class="line">		</span><br><span class="line">		        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		        <span class="comment">//4.2查询所有student标签下的name标签</span></span><br><span class="line">		        List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(<span class="string">&quot;//student/name&quot;</span>);</span><br><span class="line">		        <span class="keyword">for</span> (JXNode jxNode : jxNodes2) &#123;</span><br><span class="line">		            System.out.println(jxNode);</span><br><span class="line">		        &#125;</span><br><span class="line">		</span><br><span class="line">		        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		        <span class="comment">//4.3查询student标签下带有id属性的name标签</span></span><br><span class="line">		        List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(<span class="string">&quot;//student/name[@id]&quot;</span>);</span><br><span class="line">		        <span class="keyword">for</span> (JXNode jxNode : jxNodes3) &#123;</span><br><span class="line">		            System.out.println(jxNode);</span><br><span class="line">		        &#125;</span><br><span class="line">		        System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">		        <span class="comment">//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast</span></span><br><span class="line">		</span><br><span class="line">		        List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(<span class="string">&quot;//student/name[@id=&#x27;itcast&#x27;]&quot;</span>);</span><br><span class="line">		        <span class="keyword">for</span> (JXNode jxNode : jxNodes4) &#123;</span><br><span class="line">		            System.out.println(jxNode);</span><br><span class="line">		        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet&amp;HTTP&amp;Reques&amp;Response快速入门</title>
    <url>/2022/02/19/servlet&amp;HTTP&amp;Reques&amp;Response%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="servlet相关配置"><a href="#servlet相关配置" class="headerlink" title="servlet相关配置"></a>servlet相关配置</h2><ol>
<li><p>URLPattern:servlet访问路径</p>
<p>一个servlet可以定义多个访问路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(&#123;&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>路径规则：</p>
<ul>
<li>&#x2F;xxx:路径匹配</li>
<li>&#x2F;xxx&#x2F;xx：多层路径，目录结构</li>
<li>*.do：拓展名匹配</li>
</ul>
</li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ol>
<li><p>概念</p>
<p>Hyper Text Transfer Protocol超文本传输协议。何谓协议?即定义了两个设备之间传输信息的格式。</p>
</li>
<li><p>特点</p>
<ul>
<li>默认端口号是80</li>
<li>基于请求&#x2F;响应模型的：一次请求对应一次响应</li>
<li>无状态的，每次请求之间相互独立，不能交互数据</li>
</ul>
</li>
</ol>
<p>3.版本</p>
<ul>
<li>1.0:每一次请求相应都会建立新的连接</li>
<li>1.1:复用连接</li>
</ul>
<ol start="4">
<li><p>请求消息数据格式</p>
<ul>
<li><p>请求行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /login.html	HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>HTTP协议中有7种请求方法，常用的有2种</p>
<p><strong>GET</strong></p>
<ol>
<li>请求参数在请求行中，在url后？连接</li>
<li>请求的url长度有限制</li>
<li>不太完全</li>
</ol>
<p><strong>POST</strong></p>
<ol>
<li>请求参数在请求体中</li>
<li>请求的url长度没有限制</li>
<li>相对安全</li>
</ol>
</li>
<li><p>请求头</p>
<ol>
<li><p>User-agent</p>
<p>浏览器告诉服务器，我的浏览器的版本信息</p>
</li>
<li><p>Referer</p>
<p>高速浏览器我从哪里来</p>
<p>可以防止盗链、进行统计工作</p>
</li>
</ol>
</li>
<li><p>请求空行</p>
<p>空行，用于分隔post请求头和请求体。</p>
</li>
<li><p>请求体（正文）</p>
<p>post请求方式请求数据存放的地方</p>
</li>
<li><p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /login.html	HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://localhost/login.html</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">username=zhangsan	</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>响应消息数据格式(略)</p>
</li>
</ol>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="Resquest功能"><a href="#Resquest功能" class="headerlink" title="Resquest功能"></a>Resquest功能</h3><p>主要用户获取请求消息数据</p>
<ol>
<li><p>获取请求行数据 GET &#x2F;day14&#x2F;demo1?name&#x3D;zhangsan HTTP&#x2F;1.1</p>
<ul>
<li>getMethod 获取请求方法GET</li>
<li>getContextPath获取虚拟路径&#x2F;day14</li>
<li>getServletPath获取servlet路径&#x2F;demo1</li>
<li>getQueryString获取Get请求参数name&#x3D;zhangsan</li>
<li>getRequestURI获取请求URI&#x2F;day14&#x2F;demo1</li>
<li>getProtocol获取协议及版本HTTP&#x2F;1.1</li>
<li>getRemoteAddr获取客户机IP地址</li>
</ul>
</li>
<li><p>获取请求头数据</p>
<ul>
<li>getHeader(String name)</li>
<li>getHeaderNames():获取所有的请求头名称</li>
</ul>
</li>
<li><p>获取请求体数据</p>
<p>getReader获取流对象后获取</p>
</li>
</ol>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ol>
<li><p>获取请求参数通用方法</p>
<ol>
<li>String getParameter(String name):根据参数名称获取参数值    username&#x3D;zs&amp;password&#x3D;123</li>
<li>String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby&#x3D;xx&amp;hobby&#x3D;game</li>
<li>Enumeration<String> getParameterNames():获取所有请求的参数名称</li>
<li>Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合</li>
</ol>
</li>
</ol>
<h3 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher.forward(ServletRequest request,ServletResponse response) </span><br></pre></td></tr></table></figure>

<ul>
<li><p>特点</p>
<ol>
<li>转发只是一次请求</li>
<li>只能转发到当前服务器内部资源中</li>
<li>浏览器地址栏不发生变化</li>
</ol>
</li>
<li><p>共享数据</p>
<ol>
<li><p>域对象：在一定的作用范围内共享数据</p>
</li>
<li><p>request域：在一次请求中的数据共享范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setAttribute() 存储数据</span><br><span class="line">getAttribute()获取数据</span><br><span class="line">removeAttribute移除数据</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>(在Response下详细学习)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletContext <span class="title function_">getServletContext</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h3 id="案例-登录"><a href="#案例-登录" class="headerlink" title="案例-登录"></a>案例-登录</h3><p>链接：<a href="https://blog.csdn.net/qq_44850917/article/details/122842886">案例-登录</a></p>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="HTTP协议响应"><a href="#HTTP协议响应" class="headerlink" title="HTTP协议响应"></a>HTTP协议响应</h3><ol>
<li><p>请求消息：客户端发送给服务器的数据</p>
<ul>
<li>请求行</li>
<li>请求头</li>
<li>请求空行</li>
<li>请求体</li>
</ul>
</li>
<li><p>响应消息：服务端发送给客户端的消息</p>
<ul>
<li><p>响应行</p>
<ol>
<li><p>组成</p>
<p>协议&#x2F;版本 响应状态码 状态码描述</p>
</li>
<li><p>响应状态码</p>
<p>1xx:服务端接受客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</p>
<p>2xx:成功，200</p>
<p>3xx:重定向。302重定向。304访问缓存</p>
<p>4xx:客户端错误</p>
<p>​	404请求路径没有对应的资源</p>
<p>​	405请求方式没有对应的doxxx方法</p>
<p>5xx:服务端错误500服务端内部异常</p>
</li>
</ol>
</li>
<li><p>响应头</p>
<ol>
<li><p>Content-Type：服务端告诉客户端本次响应体的数据格式以及编码格式</p>
</li>
<li><p>Content-disposition：服务端高数客户端以什么格式打开相应数据</p>
<p>–inline默认</p>
<p>–attachment;filename&#x3D;xxx 以附件方式打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.setHeader(&quot;content-disposition&quot;,&quot;attachment;filname=111&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>响应空行</p>
</li>
<li><p>响应体：传输的数据</p>
</li>
<li><p>响应内容实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Length: 101</span><br><span class="line">Date: Wed, 06 Jun 2018 07:08:42 GMT</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">hello , response</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h3><ol>
<li><p>设置响应消息</p>
<ul>
<li><p>设置响应行</p>
<p>格式：HTTP&#x2F;1.1 200 OK</p>
<p>设置状态码：setStatus</p>
</li>
<li><p>设置响应头</p>
<p>setHeader(String name, String value) </p>
</li>
<li><p>设置响应体</p>
<p>1.获取输出流getWriter或者getOutputStream</p>
<p>2.使用输出流</p>
</li>
</ul>
</li>
<li><p>重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//response.setStatus(302);//1. 设置状态码为302</span></span><br><span class="line"><span class="comment">//      response.setHeader(&quot;location&quot;,&quot;/day/servletDemo3&quot;); //2.设置响应头location</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的写法的简介</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;/day/servletDemo3&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="重定向和转发区别"><a href="#重定向和转发区别" class="headerlink" title="重定向和转发区别"></a>重定向和转发区别</h3><ol>
<li>重定向特点<ul>
<li>地址栏发生变化</li>
<li>重定向可以访问其他站点</li>
<li>重定向是两次请求，不能用request域类共享数据</li>
</ul>
</li>
<li>转发特点<ul>
<li>转发地址路径不变</li>
<li>是一次请求</li>
<li>转发只能访问当前服务器的资源</li>
</ul>
</li>
</ol>
<h3 id="访问路径"><a href="#访问路径" class="headerlink" title="访问路径"></a>访问路径</h3><ol>
<li><p>相对路径</p>
<p>比如.&#x2F;index.html</p>
<p>.&#x2F;当前目录</p>
<p>..&#x2F;后退一级目录</p>
</li>
<li><p>绝对路径</p>
<p>比如 <a href="http://localhost/day14/demo">http://localhost/day14/demo</a></p>
<p>或者 &#x2F;day14&#x2F;demo</p>
</li>
<li><p>路径使用</p>
<ul>
<li><p>客户端使用</p>
<p>需要添加虚拟目录,虚拟目录动态获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getContextPath()</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器使用</p>
<p>不需要添加虚拟目录，一般转发时用</p>
</li>
</ul>
</li>
</ol>
<h3 id="服务器输出字符数据到浏览器"><a href="#服务器输出字符数据到浏览器" class="headerlink" title="服务器输出字符数据到浏览器"></a>服务器输出字符数据到浏览器</h3><ol>
<li><p>步骤</p>
<p>获取字符输出流 -&gt; 输出数据</p>
</li>
<li><p>乱码问题</p>
<p>设置响应头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例-验证码</p>
<p>链接：<a href="https://blog.csdn.net/qq_44850917/article/details/122845044">验证码案例</a></p>
</li>
</ol>
<h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>代表整个web应用，可以和程序的容器（服务器）通信</p>
<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><ol>
<li><p>request获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getServletContext();</span><br></pre></td></tr></table></figure>

</li>
<li><p>HttpServlet获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.getServletContext();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li><p>获取MIME类型</p>
<p>MIME类型:在互联网通信过程中定义的一种文件数据类型</p>
<p>格式：大类型&#x2F;小类型</p>
<p> text&#x2F;html               image&#x2F;jpeg</p>
<p>获取方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getMimeType(String file)</span><br></pre></td></tr></table></figure>

</li>
<li><p>域对象：共享数据</p>
<ul>
<li>setAttribute</li>
<li>getAttribute</li>
<li>removeAttribute</li>
</ul>
<p>ServletContext对象的范围：所有用户请求的数据，个人理解是所有的servlet之间共享数据</p>
</li>
<li><p>获取文件的真实（服务器）路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/b.txt&quot;</span>);<span class="comment">//web目录下资源访问</span></span><br><span class="line">System.out.println(b);</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/WEB-INF/c.txt&quot;</span>);<span class="comment">//WEB-INF目录下的资源访问</span></span><br><span class="line">System.out.println(c);</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/WEB-INF/classes/a.txt&quot;</span>);<span class="comment">//src目录下的资源访问</span></span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="案例-文件下载"><a href="#案例-文件下载" class="headerlink" title="案例-文件下载"></a>案例-文件下载</h2><ol>
<li><p>文件下载需求</p>
<ul>
<li>页面显示超链接</li>
<li>点击超链接后弹出下载提示框</li>
<li>完成图片文件下载</li>
</ul>
</li>
<li><p>链接 <a href="https://blog.csdn.net/qq_44850917/article/details/122957155">文件下载-案例</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是回调函数callback？</title>
    <url>/2022/12/11/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0callback/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>A，B两个小组开发一个功能。B小组开发制作油条模块:make_youtiao。A小组需要调用B小组开发的模块，然后执行后续的操作：sell()如下图： </p>
<p><img src="https://img-blog.csdnimg.cn/direct/56910f4a3b62486d9aeeef085fb3db23.webp" alt="请添加图片描述"></p>
<p>上面的方式A小组必须等待B小组开发的模块make_youtiao执行完成后才能执行sell()。</p>
<p>上图代码的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">make_youtiao(<span class="number">10000</span>);</span><br><span class="line">sell();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/direct/e835a8278b564a7c9733100aeb77806d.webp" alt="在这里插入图片描述"></p>
<p>存在的问题：A小组不知道啥时候B小组执行完，因此必须等待B小组执行完，再执行后续的操作sell()，效率不够高。</p>
<p>要是A能够告诉B小组，你执行完make_youtiao后自动执行sell（）就好了！我把任务交给你之后就去做其他事情啦~</p>
<p><img src="https://img-blog.csdnimg.cn/direct/b10b89cfdca94b1e8070391742625ca1.webp" alt="在这里插入图片描述"></p>
<p>看懂了？回调函数就是上面的sell()函数，不过他要作为参数传递给B小组。</p>
<p>上面功能用回调函数实现</p>
<p>B小组开发的模块这样定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">make_youtiao</span><span class="params">(<span class="type">int</span> num, func call_back)</span> &#123;</span><br><span class="line">    <span class="comment">// 制作油条</span></span><br><span class="line">    do_youtiao();</span><br><span class="line">    call_back(); <span class="comment">//执行回调 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A小组这样调用，将make_youtiao完成后和make_youtiao相关的工作sell作为参数传入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make_youtiao(10000, sell);</span><br></pre></td></tr></table></figure>

<h1 id="新的编程思维模式"><a href="#新的编程思维模式" class="headerlink" title="新的编程思维模式"></a>新的编程思维模式</h1><p>同步的思维方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res = request();</span><br><span class="line">handle(res);</span><br></pre></td></tr></table></figure>

<p>这种是必须等待执行完，拿到结果res，我们才能处理下一步和结果相关的工作handle()。</p>
<p><img src="https://img-blog.csdnimg.cn/direct/34e820fd1fe741cb944c55da8b4787eb.webp" alt="在这里插入图片描述"></p>
<p>异步的思维方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request(handle);</span><br></pre></td></tr></table></figure>

<p>这种方式不关心request何时执行完，将后续的工作handle传入request，当request执行完了，自动就把handle处理了。</p>
<p><img src="https://img-blog.csdnimg.cn/direct/5bb04812f8b548308f221b3613721afd.webp" alt="3e2ceb4b054ae956c7422547a76ff660_720w.webp&amp;pos_id=img-wrrhxyoc-1702705329186)"></p>
<p>举个例子说明同步和异步的区别：</p>
<p>同步：老板凡事亲力亲为，自己亲自拨电话等待电话接通（request）。然后吩咐事情(handle)。</p>
<p>异步：老板直接告诉小秘吩咐的事情是什么，小秘去完成这些琐事。老板就可以腾出手来完成一个亿的小目标啦~</p>
<h1 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h1><p>在计算机科学中，回调函数是指一段以参数的形式传递给其它代码的可执行代码。可以理解为一种设计思想。</p>
<p>一般函数：我们自己编写的函数在自己内部调用，实现方是我们自己，调用方是我们自己。</p>
<p>回调函数：实现方是我们自己，将函数传给第三方，由三方库来调用。实现方是我们自己，调用方是第三方库。</p>
<h1 id="进一步思考为什么需要callback"><a href="#进一步思考为什么需要callback" class="headerlink" title="进一步思考为什么需要callback?"></a>进一步思考为什么需要callback?</h1><p>我们之所以要传给第三方库自己定义的函数，是因为第三方库自己的代码执行完成之后，并不知道接下来应该做什么，因此对外提供了一个回调函数（跟对外提供一个接口有点类似，由调用方来具体实现）</p>
<p>最后补充一点是：回调函数被调用的时间点，是需要有特定的事件（event）发生后，才能执行回调函数。比如油条制作完成，文件读取完成，接收到消息。因此回调函数本质上是一个event_handler。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p> <a href="https://zhuanlan.zhihu.com/p/326902537">https://zhuanlan.zhihu.com/p/326902537</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>反射通俗易懂，反射体现在哪里</title>
    <url>/2022/01/11/%E5%8F%8D%E5%B0%84%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%EF%BC%8C%E5%8F%8D%E5%B0%84%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E9%87%8C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="反射概念"><a href="#反射概念" class="headerlink" title="反射概念"></a>反射概念</h2><p>反射指的是通过一个类就能知道该类的所有属性和方法（<strong>注意这里是类，而不是实例化的对象</strong>）。通俗的说，就是给你一个类的名称就可以得到该类的<strong>成员变量</strong>、<strong>构造方法</strong>、<strong>成员方法</strong>的技术。</p>
<p>通过类得到其所有的属性和方法。举个例子，比如有汽车这个类，通过汽车我们能够知道他的组成部分有轮子、方向盘等。将轮子、方向盘视为一个对象，然后通过该对象可以进行一些操作，比如轮子本身具有向前的功能，方向盘具有转弯的功能。<strong>这就是反射（内省）机制的形象化理解</strong>。</p>
<p><strong>那么问题来了，到底哪里体现了反射的字面意思呢？文末有讲到，建议按照顺序读完。</strong></p>
<h2 id="字节码对象（Class对象）-标识-class文件的对象"><a href="#字节码对象（Class对象）-标识-class文件的对象" class="headerlink" title="字节码对象（Class对象）-标识.class文件的对象"></a>字节码对象（Class对象）-标识.class文件的对象</h2><p>反射机制中有两个对象的概念对理解反射非常重要，下面介绍<strong>字节码对象</strong></p>
<p><img src="https://img-blog.csdnimg.cn/c78858d68894401e94c57e4a8b5b333f.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>我们知道一个java文件，需要编译成.class文件。这个.class文件我们虽然表面上对该文件一无所知，但是java将.class字节码加载进内存时，jvm将产生一个java.lang.Class对象代表该.class字节码文件（这里体现了java中万物皆对象），从该字节码文件中可以获得该类的许多基本信息，这就是反射机制。所以要想完成反射操作，必须先获得该字节码对象。下面介绍三种获取字节码对象方法。</p>
<h2 id="获取Class对象的三种方法"><a href="#获取Class对象的三种方法" class="headerlink" title="获取Class对象的三种方法"></a>获取Class对象的三种方法</h2><h3 id="Class-forName-“全类名”"><a href="#Class-forName-“全类名”" class="headerlink" title="Class.forName(“全类名”)"></a>Class.forName(“全类名”)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;cn.itcast.reflect.domain.Student&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果知道一个类的全类名，就可以通过该方法来得到类对象。这里的Class是java系统中自己定义的类。</p>
<h3 id="自定义类名-class"><a href="#自定义类名-class" class="headerlink" title="自定义类名.class"></a>自定义类名.class</h3><p>通过自定义类名的属性来获取。</p>
<h3 id="对象-getClass"><a href="#对象-getClass" class="headerlink" title="对象.getClass"></a>对象.getClass</h3><p>通过实例化的对象，get方法来获取</p>
<h2 id="字节码对象功能（获取类属性和方法对象）"><a href="#字节码对象功能（获取类属性和方法对象）" class="headerlink" title="字节码对象功能（获取类属性和方法对象）"></a>字节码对象功能（获取类属性和方法对象）</h2><p>上面我们介绍了获取字节码对象三种方法后，再来介绍该对象的功能。</p>
<p>我们说过，字节码对象代表.class文件，可以通过该字节码对象了解到.class字节码编译前java类中的所有属性和方法。下面介绍这些属性和方法封装成的对象：Filed、Constructor、Method如何获取。</p>
<h3 id="获取成员变量们"><a href="#获取成员变量们" class="headerlink" title="获取成员变量们"></a>获取成员变量们</h3><ul>
<li>Field[] getFields() ：获取所有public修饰的成员变量</li>
<li>Field getField(String name)   获取指定名称的 public修饰的成员变量</li>
<li>Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</li>
<li>Field getDeclaredField(String name)</li>
</ul>
<h3 id="获取构造方法们"><a href="#获取构造方法们" class="headerlink" title="获取构造方法们"></a>获取构造方法们</h3><ul>
<li>Constructor&lt;?&gt;[] getConstructors()  </li>
<li>Constructor<T> getConstructor(类&lt;?&gt;… parameterTypes)  </li>
<li>Constructor<T> getDeclaredConstructor(类&lt;?&gt;… parameterTypes)  </li>
<li>Constructor&lt;?&gt;[] getDeclaredConstructors()</li>
</ul>
<h3 id="获取成员方法们"><a href="#获取成员方法们" class="headerlink" title="获取成员方法们"></a>获取成员方法们</h3><ul>
<li><p>Method[] getMethods()  </p>
</li>
<li><p>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)  </p>
</li>
<li><p>Method[] getDeclaredMethods()  </p>
</li>
<li><p>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)</p>
</li>
</ul>
<h2 id="到底哪里体现反射的字面意思？"><a href="#到底哪里体现反射的字面意思？" class="headerlink" title="到底哪里体现反射的字面意思？"></a>到底哪里体现反射的字面意思？</h2><p>一图胜千言，看图</p>
<p><img src="https://img-blog.csdnimg.cn/fa3d6850969c404d98ebfccfb0cf35a1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>反射体现在通过字节码对象，反射回推得知java类中所有的属性和方法。</p>
<p>其实探究反射到底体现在哪里，这里不是太重要？重要的是需要理解<strong>反射指的是通过类了解到该类内部的属性和方法的一种技术</strong>。</p>
<h2 id="案例：实现小框架理解反射是框架的灵魂"><a href="#案例：实现小框架理解反射是框架的灵魂" class="headerlink" title="案例：实现小框架理解反射是框架的灵魂"></a>案例：实现小框架理解反射是框架的灵魂</h2><p>需求：通过加载properties，实现调用任意一个类的方法。（不允许使用new实例对象的方法来调用函数。）</p>
<p>方法：</p>
<p>1.加载property对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">InputStream resourceAsStream ==example.class.getClassLoader().getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);</span><br><span class="line">pro.load(resourceAsStream);</span><br></pre></td></tr></table></figure>

<p>2.通过property对象读取属性全类名,创建字节码对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String className = pro.getProperty(&quot;className&quot;);</span><br><span class="line">Class cls = Class.forName(className);</span><br></pre></td></tr></table></figure>

<p>3.通过字节码对象获取并实例化类构造对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>4.通过字节码对象获取并执行类方法对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">cls.getMethod(methodName).invoke(o);</span><br></pre></td></tr></table></figure>

<h3 id="example-java"><a href="#example-java" class="headerlink" title="example.java"></a>example.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//加载property对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> example.class.getClassLoader().getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);</span><br><span class="line">        pro.load(resourceAsStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过property对象读取属性全类名，创建字节码对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过字节码对象获取并实例化类构造对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过字节码对象获取方法对象，并执行该方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> cls.getMethod(methodName).invoke(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="pro-properties"><a href="#pro-properties" class="headerlink" title="pro.properties"></a>pro.properties</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">cn.itcast.domain.Student</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">shout</span></span><br></pre></td></tr></table></figure>

<p>Person.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是person......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Integer age, String address)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是student.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Integer age, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h3><p><img src="https://img-blog.csdnimg.cn/38d69cba6a1746198af4730b3ceb3ced.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer52.两个链表的第一个公共节点</title>
    <url>/2022/12/15/%E5%89%91%E6%8C%87Offer52/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共节点。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:  A=[4,1,8,4,5]  B=[5,0,1,8,4,5]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:  A=[4,1,8]  B=[5,0,1]</span><br><span class="line">输出: NULL</span><br></pre></td></tr></table></figure>

<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><h3 id="1-方法1-消除差距法"><a href="#1-方法1-消除差距法" class="headerlink" title="1.方法1:消除差距法"></a>1.方法1:消除差距法</h3><ol>
<li>两个链表相交之后，后面都是一样的，需要找第一个公共节点。</li>
<li>但是他们的第一个公共节点在哪儿呢。我们通过两个链表的长度之差，定位到长链表的遍历起始地方。</li>
<li>此举消除了起始位置差，保证了两个链表同时遍历后一定能同时到达第一个公共节点。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2656906465b54f578e743fe5a5f11b38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-方法2：浪漫相遇法"><a href="#2-方法2：浪漫相遇法" class="headerlink" title="2.方法2：浪漫相遇法"></a>2.方法2：浪漫相遇法</h3><ol>
<li>该方法实质上也是一种消除差距的方法。方法1消除差距是利用长链表遍历的时候先走几步（先出发），直到达到长，短链表遍历能够同步。</li>
<li>浪漫相遇法两个指针遍历同时出发，都走长短链表之和的路程。虽然前面的路程不同，但是因为有公共节点。后面一截路程一定相同，也就一定会相遇。</li>
<li>如下图第一个相遇的节点就是所求结果</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/acd09f299751424bb204aa52a4b4dbe0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="1-消除差距法"><a href="#1-消除差距法" class="headerlink" title="1.消除差距法"></a>1.消除差距法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">题目：剑指 Offer 52. 两个链表的第一个公共节点</span></span><br><span class="line"><span class="string">描述：</span></span><br><span class="line"><span class="string">方法：消除差距法：</span></span><br><span class="line"><span class="string">    两个链表相交之后，后面都是一样的，需要找第一个公共节点。</span></span><br><span class="line"><span class="string">    但是他们的第一个公共节点在哪儿呢。我们通过两个链表的长度之差，定位到长链表的遍历起始地方。</span></span><br><span class="line"><span class="string">    此举保证了两个链表遍历后一定能同时到达第一个公共节点。</span></span><br><span class="line"><span class="string">    消除差距是利用长链表遍历的时候先走几步（先出发），直到达到长，短链表遍历能够同步。</span></span><br><span class="line"><span class="string">复杂度分析：时间O(m+n)：求长度O(m+n) 遍历找公共节点：O(m+n)</span></span><br><span class="line"><span class="string">            空间O(1)： i，pA,PB</span></span><br><span class="line"><span class="string">坑：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    pA, pB = headA, headB</span><br><span class="line">    lenA = lenB = <span class="number">0</span>  <span class="comment"># 两个链表长度</span></span><br><span class="line">    <span class="comment"># 求链表长度</span></span><br><span class="line">    <span class="keyword">while</span> pA:</span><br><span class="line">        lenA += <span class="number">1</span></span><br><span class="line">        pA = pA.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> pB:</span><br><span class="line">        lenB += <span class="number">1</span></span><br><span class="line">        pB = pB.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># 消除差距长链表遍历的时候先走几步（先出发）</span></span><br><span class="line">    <span class="keyword">if</span> lenB &gt;= lenA:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lenB - lenA):  <span class="comment"># 通过先出发将差距弥补</span></span><br><span class="line">            headB = headB.<span class="built_in">next</span>  <span class="comment"># 当前节点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lenA - lenB):</span><br><span class="line">            headA = headA.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> headA <span class="keyword">and</span> headB:</span><br><span class="line">        <span class="keyword">if</span> headA <span class="keyword">is</span> headB:  <span class="comment"># 同步出发，相等就是相遇的第一个节点</span></span><br><span class="line">            <span class="keyword">return</span> headA</span><br><span class="line">        headA, headB = headA.<span class="built_in">next</span>, headB.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span> <span class="comment"># 没有相遇</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-浪漫相遇法"><a href="#2-浪漫相遇法" class="headerlink" title="2.浪漫相遇法"></a>2.浪漫相遇法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    题目：剑指 Offer 52. 两个链表的第一个公共节点</span></span><br><span class="line"><span class="string">    描述：</span></span><br><span class="line"><span class="string">    方法：浪漫相遇法，为了消除两个的长度差，遍历的时候对两个链路总和进行遍历。只是起点不同，他们总会在第一个节点相遇</span></span><br><span class="line"><span class="string">    复杂度分析：时间O(m+n)：</span></span><br><span class="line"><span class="string">                空间O(1)： i，pA,PB</span></span><br><span class="line"><span class="string">    坑：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNodeA</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        flagA = flagB = <span class="literal">False</span></span><br><span class="line">        pA, pB = headA, headB</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pA != pB:</span><br><span class="line">            <span class="keyword">if</span> (flagA <span class="keyword">and</span> <span class="keyword">not</span> pA.<span class="built_in">next</span>) <span class="keyword">or</span> (flagB <span class="keyword">and</span> <span class="keyword">not</span> pB.<span class="built_in">next</span>): <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> pA.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                pA = headB</span><br><span class="line">                flagA = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pA = pA.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> pB.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                pB = headA</span><br><span class="line">                flagB = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pB = pB.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pA</span><br></pre></td></tr></table></figure>

<h3 id="3-浪漫相遇法优化"><a href="#3-浪漫相遇法优化" class="headerlink" title="3.浪漫相遇法优化"></a>3.浪漫相遇法优化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">题目：剑指 Offer 52. 两个链表的第一个公共节点</span></span><br><span class="line"><span class="string">描述：</span></span><br><span class="line"><span class="string">方法：题解，上面方法的优化。在遍历的时候要遍历最后一个节点之后的空节点。这样会使两个链表即使</span></span><br><span class="line"><span class="string">    没有公共节点，也会在在该节点相遇。就不用单独考虑特殊情况啦</span></span><br><span class="line"><span class="string">复杂度分析：时间O(m+n)：</span></span><br><span class="line"><span class="string">            空间O(1)： pA,PB</span></span><br><span class="line"><span class="string">坑：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getIntersectionNodeAA</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">    pA, pB = headA, headB</span><br><span class="line">    <span class="keyword">while</span> pA != pB:</span><br><span class="line">        pA = pA.<span class="built_in">next</span> <span class="keyword">if</span> pA <span class="keyword">else</span> headB</span><br><span class="line">        pB = pB.<span class="built_in">next</span> <span class="keyword">if</span> pB <span class="keyword">else</span> headA</span><br><span class="line">    <span class="keyword">return</span> pA</span><br></pre></td></tr></table></figure>

<h3 id="4-set集合存储节点，判断重复（补充）"><a href="#4-set集合存储节点，判断重复（补充）" class="headerlink" title="4.set集合存储节点，判断重复（补充）"></a>4.set集合存储节点，判断重复（补充）</h3><p><strong>python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">题目：剑指 Offer 52. 两个链表的第一个公共节点</span></span><br><span class="line"><span class="string">描述：</span></span><br><span class="line"><span class="string">方法：利用set存储一条链表，然后遍历另一条链表，如果发现set中有重复的，那么就是第一个交点</span></span><br><span class="line"><span class="string">        没有重复的返回None</span></span><br><span class="line"><span class="string">复杂度分析：时间O(m+n)：遍历两个链表</span></span><br><span class="line"><span class="string">            空间O(m)： 辅助空间set集合</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getIntersectionNodeB</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">    pA, pB = headA, headB</span><br><span class="line">    container = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> pA:</span><br><span class="line">        container.add(pA)</span><br><span class="line">        pA = pA.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> pB:</span><br><span class="line">        <span class="keyword">if</span> container.__contains__(pB): <span class="keyword">return</span> pB</span><br><span class="line">        pB = pB.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：剑指 Offer 52. 两个链表的第一个公共节点</span></span><br><span class="line"><span class="comment">* 描述：输入两个链表，找出它们的第一个公共节点。</span></span><br><span class="line"><span class="comment">* 实现:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">	ListNode* p1 = headA;</span><br><span class="line">	ListNode* p2 = headB;</span><br><span class="line">	set&lt;ListNode*&gt; myset;</span><br><span class="line">	<span class="keyword">while</span> (p1) &#123;</span><br><span class="line">		myset.<span class="built_in">emplace</span>(p1);</span><br><span class="line">		p1 = p1-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (myset.<span class="built_in">count</span>(p2)) <span class="keyword">return</span> p2;</span><br><span class="line">		p2 = p2-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>此题是双指针的典型题。链表问题要想到用双指针。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库连接池</title>
    <url>/2022/01/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 





<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数据库连接池是一个存放<strong>connection连接对象</strong>的池子（<strong>容器</strong>）。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>当系统初始化后，容器被创建，容器会申请一些连接对象存放在该容器中，当用户访问数据库的时候，直接从池子中申请，用完后归还到池子中去。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li>节约资源</li>
<li>用户访问高效</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>标准的接口是DataSource，包含方法</p>
<ul>
<li>获取连接getConnection</li>
<li>归还连接close</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>一般是由数据库厂商来实现</p>
<ul>
<li>C3P0数据库连接池技术</li>
<li>Druid（阿里巴巴提供）</li>
</ul>
<h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><h2 id="C3P0数据库连接池技术"><a href="#C3P0数据库连接池技术" class="headerlink" title="C3P0数据库连接池技术"></a>C3P0数据库连接池技术</h2><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>导入jar包（注意要导入数据库连接池的jar包，还要导入数据库驱动jar包）</li>
<li>在src（classPath）下定义配置文件，可以配置driverName,user,password,maxSize等</li>
<li>定义一个类文件使用<ul>
<li><code>ds=new ComboPooledDataSource</code>直接new一个连接池</li>
<li>数据库连接池直接getConnection获取连接对象</li>
</ul>
</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dataSource.c3p0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataSource ds=<span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;other1c3p0&quot;</span>);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">            System.out.println(con);</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Druid（阿里巴巴提供）常用"><a href="#Druid（阿里巴巴提供）常用" class="headerlink" title="Druid（阿里巴巴提供）常用"></a>Druid（阿里巴巴提供）常用</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>导入jar包（注意要导入数据库连接池的jar包，还要导入数据库驱动jar包）</li>
<li>在src（classPath）下定义配置文件，可以配置driverName,user,password,maxSize等</li>
<li>定义一个类文件使用<ul>
<li><code>ds=DruidDataSourceFactory.createDataSource(pro)</code>这里是通过工厂类来生成连接池</li>
<li>数据库连接池直接getConnection获取连接对象</li>
</ul>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dataSource.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Properties pro=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">rs</span> <span class="operator">=</span> Demo01.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            pro.load(rs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">            String sql=<span class="string">&quot;SELECT * FROM emp;&quot;</span>;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">            <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;ename&quot;</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="抽取成工具类DruidUtils"><a href="#抽取成工具类DruidUtils" class="headerlink" title="抽取成工具类DruidUtils"></a>抽取成工具类DruidUtils</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li>获取数据库连接池</li>
<li>获取连接对象</li>
<li>关闭对象</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dataSource.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * druid工具类</span></span><br><span class="line"><span class="comment"> * 1.获取连接对象</span></span><br><span class="line"><span class="comment"> * 2.关闭连接对象</span></span><br><span class="line"><span class="comment"> * 3.获取数据库连接池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">rs</span> <span class="operator">=</span> DruidUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            pro.load(rs);</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);<span class="comment">//初始化数据池对象</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> con</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet rs, Statement stmt, Connection con)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Statement stmt, Connection con)</span> &#123;</span><br><span class="line">        DruidUtils.close(<span class="literal">null</span>, stmt, con);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Spring-JDBC（JDBCTemplate）常用"><a href="#Spring-JDBC（JDBCTemplate）常用" class="headerlink" title="Spring  JDBC（JDBCTemplate）常用"></a>Spring  JDBC（JDBCTemplate）常用</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Spring框架对JDBC的简单封装。提供了JDBCTemplate对象简化JDBC的开发。JDBCTemplate对象能自动close对象，极大方便了操作。</p>
<h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>导入jar包</p>
</li>
<li><p>创建JDBCTemplate对象。<strong>参数为数据库连接池DataSource</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource ds= DruidUtils.getDataSource();</span><br><span class="line">JdbcTemplate tmp=<span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(ds);</span><br></pre></td></tr></table></figure>

</li>
<li><p>调用方法来实现</p>
<ul>
<li>update</li>
<li>query（查询，通过BeanPropertyRowMapper封装成对象列表）</li>
<li>queryForObeject（查询，通过BeanPropertyRowMapper封装成对象）</li>
<li>queryForMap</li>
<li>queryForList</li>
</ul>
</li>
</ol>
<h2 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dataSource.jdbctmplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.dataSource.domain.Emp;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.dataSource.utils.DruidUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTemplateDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DataSource ds= DruidUtils.getDataSource();</span><br><span class="line">        JdbcTemplate tmp=<span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(ds);</span><br><span class="line">        String sql=<span class="string">&quot;SELECT * FROM emp where id=1001&quot;</span>;</span><br><span class="line">        <span class="comment">//封装成对象，参数用BeanPropertyRowMapper接口</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> tmp.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Emp.class));</span><br><span class="line">        System.out.println(emp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String sql1=<span class="string">&quot;SELECT * FROM emp;&quot;</span>;</span><br><span class="line">        <span class="comment">//封装成对象列表，参数用BeanPropertyRowMapper接口</span></span><br><span class="line">        List&lt;Emp&gt; emps = tmp.query(sql1, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Emp.class));</span><br><span class="line">        <span class="keyword">for</span> (Emp emp1 : emps) &#123;</span><br><span class="line">            System.out.println(emp1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询总的数据条数</span></span><br><span class="line">        String sql2=<span class="string">&quot;SELECT count(id) FROM emp;&quot;</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> tmp.queryForObject(sql2, Long.class);</span><br><span class="line">        System.out.println(num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>案例-02验证码(html,servlet,Response对象)</title>
    <url>/2022/02/09/%E6%A1%88%E4%BE%8B-02%E9%AA%8C%E8%AF%81%E7%A0%81(html,servlet,Response%E5%AF%B9%E8%B1%A1)/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><ol>
<li><p>本质上是图片，用来防止恶意表单注册。</p>
<p>通过img标签，src为servlet的 路径</p>
</li>
</ol>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li><p>书写静态页面login.html</p>
<p>img标签，src为servlet路径。再写一个a标签。两者都绑定点击事件，点击后图片进行刷新。</p>
</li>
<li><p>书写servlet</p>
<p>通过ImageIO将写好的img输出到页面流里面去（response.getOutPutStream）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将图片写入到浏览器页面上去</span></span><br><span class="line">ImageIO.write(img,<span class="string">&quot;jpg&quot;</span>,response.getOutputStream());</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="登录页面login-html"><a href="#登录页面login-html" class="headerlink" title="登录页面login.html"></a>登录页面login.html</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> img=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;image&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> change=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;change&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            img.<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> date=<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span></span><br><span class="line"><span class="language-javascript">                img.<span class="property">src</span>=<span class="string">&quot;/day/CheckCodeServlet?&quot;</span>+date;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            change.<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> date=<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span></span><br><span class="line"><span class="language-javascript">                img.<span class="property">src</span>=<span class="string">&quot;/day/CheckCodeServlet?&quot;</span>+date;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/day/CheckCodeServlet&quot;</span> <span class="attr">id</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;change&quot;</span>&gt;</span>看不见？点击换一张<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="CheckCodeServlet"><a href="#CheckCodeServlet" class="headerlink" title="CheckCodeServlet"></a>CheckCodeServlet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/CheckCodeServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckCodeServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">int</span> height=<span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> width=<span class="number">100</span>;</span><br><span class="line">        <span class="comment">//创建对象，在内存中图片对象</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">img</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(width,height,BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//美化图片</span></span><br><span class="line">        <span class="type">Graphics</span> <span class="variable">g</span> <span class="operator">=</span> img.getGraphics();</span><br><span class="line">        g.setColor(Color.pink);</span><br><span class="line">        g.drawRect(<span class="number">0</span>,<span class="number">0</span>,width-<span class="number">1</span>,height-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String str=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span>;</span><br><span class="line">        Random ran=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ran.nextInt(str.length());</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(index);</span><br><span class="line">            g.drawString(c+<span class="string">&quot;&quot;</span>,width/<span class="number">5</span>*i,height/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g.setColor(Color.GREEN);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> ran.nextInt(width);</span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> ran.nextInt(width);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> ran.nextInt(height);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> ran.nextInt(height);</span><br><span class="line">            g.drawLine(x1,y1,x1,x2);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将图片写入到浏览器页面上去</span></span><br><span class="line">        ImageIO.write(img,<span class="string">&quot;jpg&quot;</span>,response.getOutputStream());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://img-blog.csdnimg.cn/96586e1f27cb4908a40114cc71971096.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="验证码实现的原理？"><a href="#验证码实现的原理？" class="headerlink" title="验证码实现的原理？"></a>验证码实现的原理？</h2><p>验证码的本质是一张图片，通过设置图片标签的src指向servlet位置，通过在servlet中定义img的内容，然后通过ImageIO.write 将img内容写到response的输出流上去，也就是输出到页面中。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>案例-01登录(mysql，druid连接池技术、JDBCTemplate、servlet)</title>
    <url>/2022/02/09/%E6%A1%88%E4%BE%8B-01%E7%99%BB%E5%BD%95(mysql%EF%BC%8Cdruid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%8A%80%E6%9C%AF%E3%80%81JDBCTemplate%E3%80%81servlet)/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 



<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><ol>
<li><p>编写login.html登录页面</p>
<p>username &amp; password 两个输入框</p>
</li>
<li><p>使用Druid数据库连接池技术，操作mysql中的user表</p>
</li>
<li><p>使用JdbcTemplate技术封装JDBC</p>
</li>
<li><p>登录成功跳转到SuccessServlet</p>
<p>展示：登录成功！用户名，欢迎您xxx用户</p>
</li>
<li><p>登录失败跳转到FailServlet</p>
<p>展示：登录失败，用户名或者密码错误</p>
</li>
</ol>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li><p>导入数据库驱动包，Druid数据库连接池包，JdbcTemplate一系列包</p>
</li>
<li><p>编写登录页面login.html</p>
</li>
<li><p>定义User实体类</p>
</li>
<li><p>定义UserDao数据库连接对象</p>
</li>
<li><p>编写处理登录servlet以及展示页面成功和失败的servlet</p>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><p><img src="https://img-blog.csdnimg.cn/389a00ad6cba4a379c9bac109cdf4c71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="登录页面login-html"><a href="#登录页面login-html" class="headerlink" title="登录页面login.html"></a>登录页面login.html</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--用户输入表单--&gt;</span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;/demo_login_1/loginServlet&quot;</span> style=<span class="string">&quot;margin:auto;&quot;</span>&gt;</span><br><span class="line">    姓名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> placeholder=<span class="string">&quot;输入姓名&quot;</span>&gt;&lt;/br&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> placeholder=<span class="string">&quot;输入密码&quot;</span>&gt;&lt;/br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;btn&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="User实体类"><a href="#User实体类" class="headerlink" title="User实体类"></a>User实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.domain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实体类，注意这里面的属性要和数据库中的属性写成一样的</span></span><br><span class="line"><span class="comment"> * 方便在UserDao中queryForObject使用BeanPropertyMapper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JDBCUtils-java获取数据库连接池DataSource"><a href="#JDBCUtils-java获取数据库连接池DataSource" class="headerlink" title="JDBCUtils.java获取数据库连接池DataSource"></a>JDBCUtils.java获取数据库连接池DataSource</h2><h3 id="druid-properties"><a href="#druid-properties" class="headerlink" title="druid.properties"></a>druid.properties</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/day15</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">believe</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">believe</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>



<h3 id="定义工具类，用于获取DataSource"><a href="#定义工具类，用于获取DataSource" class="headerlink" title="定义工具类，用于获取DataSource"></a>定义工具类，用于获取DataSource</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC工具类，用于获取数据库连接池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="UserDao数据库连接实体-利用JDBCTemplate"><a href="#UserDao数据库连接实体-利用JDBCTemplate" class="headerlink" title="UserDao数据库连接实体(利用JDBCTemplate)"></a>UserDao数据库连接实体(利用JDBCTemplate)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.Utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库连接获取user信息</span></span><br><span class="line"><span class="comment"> * 需要导入的包：1.JDBC驱动：连接数据库</span></span><br><span class="line"><span class="comment"> *             2.Druid数据库连接池：创建datasource</span></span><br><span class="line"><span class="comment"> *             3.JDBCTemplate:快速创建connection</span></span><br><span class="line"><span class="comment"> *             4.BeanUtils：利用反射将map转换为实体对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">(User loginUser)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">JdbcTemplate</span> <span class="variable">jt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(JDBCUtils.getDataSource());</span><br><span class="line">            String sql=<span class="string">&quot;SELECT * FROM USER WHERE NAME=? AND PASSWORD=?;&quot;</span>;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jt.queryForObject(sql,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class),</span><br><span class="line">                    loginUser.getName(), loginUser.getPassword());<span class="comment">//最后两个参数是问号填充</span></span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><h2 id="LoginServlet"><a href="#LoginServlet" class="headerlink" title="LoginServlet"></a>LoginServlet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/loginServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取表单的输入值</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//设置编码方式</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = request.getParameterMap();</span><br><span class="line">        <span class="type">User</span> <span class="variable">loginuser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将表单输入的map集合转换成一个User对象</span></span><br><span class="line">            BeanUtils.populate(loginuser,map);</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserDao.getUser(loginuser);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span>==user)&#123;</span><br><span class="line">                <span class="comment">//查询不到就失败，转发到failedServlet</span></span><br><span class="line">                request.getRequestDispatcher(<span class="string">&quot;/failedServlet&quot;</span>).forward(request,response);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//查询成功，转发到successServlet</span></span><br><span class="line">                request.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">                request.getRequestDispatcher(<span class="string">&quot;/successServlet&quot;</span>).forward(request,response);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="SuccessServlet"><a href="#SuccessServlet" class="headerlink" title="SuccessServlet"></a>SuccessServlet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/successServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuccessServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) request.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//设置响应的mime类型,防止乱码</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;你好，&quot;</span>+user.getName()+<span class="string">&quot;用户！好久不见&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="FailedServlet"><a href="#FailedServlet" class="headerlink" title="FailedServlet"></a>FailedServlet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/failedServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FailedServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置响应的mime类型,防止乱码</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;用户密码错误，登录失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://img-blog.csdnimg.cn/2b9a80de96b841d485c03237cbe5c656.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/ae1d01e85240414c879c3eb6fd7aefd1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/4a8831b8a51f45f79a19886aa0c68100.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="需要导入哪些jar包？各自有什作用？"><a href="#需要导入哪些jar包？各自有什作用？" class="headerlink" title="需要导入哪些jar包？各自有什作用？"></a>需要导入哪些jar包？各自有什作用？</h2><ul>
<li><p>数据库驱动jar包</p>
<p>用于连接数据库，由数据库厂商提供，有统一的接口。</p>
</li>
<li><p>Druid数据库连接池jar包</p>
<p>阿里巴巴提供的数据库连接池技术。通过DruidDataSourceFactory创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DruidDataSourceFactory.createDataSource(pro)</span><br></pre></td></tr></table></figure>
</li>
<li><p>JDBCTemplate jar包 和 BeanUtils jar包</p>
<p>JDBC模板，通过JDBCTemplate（DataSource）创建对象。</p>
<p>再通过对象.queryForObject查询数据库构造实体（比如User）对象。</p>
<p>需要借助BeanUtils工具类将实体的字节码对象映射到实体对象上去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jt.queryForObject(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class),sql中的？参数)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="JDBCUtils工具类分析"><a href="#JDBCUtils工具类分析" class="headerlink" title="JDBCUtils工具类分析"></a>JDBCUtils工具类分析</h2><ol>
<li><p>主要功能</p>
<ul>
<li><p>加载读取druid.properties，利用druid数据库连接池工厂创建一个数据库连接池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">ds = DruidDataSourceFactory.createDataSource(pro);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数据库连接池</p>
</li>
</ul>
</li>
</ol>
<h2 id="文件目录结构分析"><a href="#文件目录结构分析" class="headerlink" title="文件目录结构分析"></a>文件目录结构分析</h2><ul>
<li><p>dao</p>
<p>数据库访问对象，实现数据库连接访问操作</p>
</li>
<li><p>domain</p>
<p>定义实体类</p>
</li>
<li><p>web</p>
<p>实现servlet逻辑</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>炼丹小技巧1：通过TensorBoard查看loss走向判断模型是否收敛</title>
    <url>/2022/12/21/%E7%82%BC%E4%B8%B9%E5%B0%8F%E6%8A%80%E5%B7%A71%EF%BC%9A%E9%80%9A%E8%BF%87TensorBoard%E6%9F%A5%E7%9C%8Bloss%E8%B5%B0%E5%90%91%E5%88%A4%E6%96%AD%E6%A8%A1%E5%9E%8B%E6%98%AF%E5%90%A6%E6%94%B6%E6%95%9B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h1><p>我们在训练模型的时候，不知道自己的超参数epochs设置的是够正确,能否训练出一个足够好的模型？<br>通过参看loss的走向，如果loss稳定在较低值附近，就可以判断该模型已经收敛。<br>可以通过plt.show自己绘制loss的走向图，当然也可以通过TensorBoard绘制loss的走向图，更加高大上。<br>TensorBoard绘图简单原理如下：1.将要绘制的数据保存为一个文件 2.用tensorboard命令读取文件并绘制图形</p>
<h1 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h1><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install tensorboard</span><br></pre></td></tr></table></figure>

<p>训练模型代码中保存loss值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)  <span class="comment"># 写入文件存放的位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=2*x&quot;</span>, <span class="number">2</span> * i, i)  <span class="comment">#  &quot;y=2*x&quot;为图片描述，2 * i 为纵坐标， i为step（横坐标）</span></span><br><span class="line">writer.close()  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动TensorBoard</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=logs</span><br></pre></td></tr></table></figure>
<p>–logdir ：读取文件所在的文件夹</p>
<h1 id="3-举例"><a href="#3-举例" class="headerlink" title="3.举例"></a>3.举例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">2.0</span>], [<span class="number">4.0</span>], [<span class="number">6.0</span>]])</span><br><span class="line"><span class="comment"># 终端中输入 tensorboard --logdir=./logs 启动tensorboard读取logs下文件，进行绘制</span></span><br><span class="line"><span class="comment"># epochs = 100  # 设置为100时模型还没有收敛</span></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearModel</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LinearModel, self).__init__()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y_pred = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = LinearModel()</span><br><span class="line">loss = torch.nn.MSELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">opmizier = torch.optim.SGD(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    y_pred = model(x_data)</span><br><span class="line">    l = loss(y_pred, y_data)</span><br><span class="line">    <span class="built_in">print</span>(l.item())</span><br><span class="line">    writer.add_scalar(<span class="string">&#x27;loss&#x27;</span>, l.item(), epoch)  <span class="comment"># 使用tensorboard</span></span><br><span class="line">    l.backward()</span><br><span class="line">    opmizier.step()</span><br><span class="line">    opmizier.zero_grad()</span><br><span class="line"></span><br><span class="line">writer.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w:&quot;</span>, model.linear.weight.item())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b:&quot;</span>, model.linear.bias.item())</span><br><span class="line"></span><br><span class="line">x_test = torch.tensor([<span class="number">4.0</span>])</span><br><span class="line">y_test = model(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_pred:&quot;</span>, y_test.item())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-1-epochs设置过小"><a href="#3-1-epochs设置过小" class="headerlink" title="3.1 epochs设置过小"></a>3.1 epochs设置过小</h2><p><img src="https://img-blog.csdnimg.cn/7cf0f419ed954c19b02b8f7607368fe1.png" alt="模型未收敛"></p>
<h2 id="3-2-epochs设置合理"><a href="#3-2-epochs设置合理" class="headerlink" title="3.2 epochs设置合理"></a>3.2 epochs设置合理</h2><p><img src="https://img-blog.csdnimg.cn/81f81430dd3149b3933edc1e3ed2597b.png" alt="模型收敛"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>案例-03下载</title>
    <url>/2022/02/16/%E6%A1%88%E4%BE%8B-03%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><ul>
<li>页面显示超链接</li>
<li>点击超链接后弹出下载提示框</li>
<li>完成图片文件下载</li>
</ul>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>在前端页面点击<a>标签通过href进行获取链接指向的来源。</p>
<ul>
<li><p>超链接指向的资源如果能够被浏览器解析，则直接在浏览器中展示</p>
</li>
<li><p>如果不能解析，则弹出下载框</p>
<p>弹出下载框需要设置content-disposition：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">content-disposition:attachment;filename=xxx</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li><p>定义页面，编辑超链接href属性，指向servlet,传递资源名称filename</p>
</li>
<li><p>书写servlet</p>
<ol>
<li>获取文件名称</li>
<li>使用字节输入流加载文件进内存</li>
<li>指定response的响应头：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">content-disposition:attachment;filename=xxx</span><br></pre></td></tr></table></figure>

<pre><code>    4. 将数据写出到response输出流
</code></pre>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="下载页面download-html"><a href="#下载页面download-html" class="headerlink" title="下载页面download.html"></a>下载页面download.html</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/day15/img/2.jpg&quot;</span>&gt;</span>图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/day15/img/1.avi&quot;</span>&gt;</span>视频<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/day15/downloadServlet?filename=2.jpg&quot;</span>&gt;</span>图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/day15/downloadServlet?filename=1.avi&quot;</span>&gt;</span>视频<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="DownloadServlet"><a href="#DownloadServlet" class="headerlink" title="DownloadServlet"></a>DownloadServlet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/downloadServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//        使用响应头指定资源打开方式</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;filname=111&quot;</span>);</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line">        <span class="comment">//拿到该文件在服务器中的真实路径</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="comment">//设置响应内容</span></span><br><span class="line">        response.setContentType(context.getMimeType(fileName));</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/img/&quot;</span> + fileName);</span><br><span class="line">        <span class="comment">//将文件放到response的输出流中</span></span><br><span class="line">        <span class="comment">//先设置响应类型为文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将该文件加载进内存</span></span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">        <span class="type">byte</span>[] tmp=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将文件放到response的输出流中</span></span><br><span class="line">        <span class="keyword">while</span> ((len=fis.read(tmp))!=-<span class="number">1</span>)&#123;<span class="comment">//注意读取到文件的末尾返回值是-1</span></span><br><span class="line">            response.getOutputStream().write(tmp,<span class="number">0</span>,len);<span class="comment">//每次从tmp中0开始输出len长度到输出流中去</span></span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://img-blog.csdnimg.cn/2758bc978deb47eebe16dc9cc36e7d54.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><h2 id="如何实现下载？"><a href="#如何实现下载？" class="headerlink" title="如何实现下载？"></a>如何实现下载？</h2><ul>
<li>前端是一个超链接a标签，href为文件来源。如果href来源是一个浏览器可以解析的文件，那么浏览器直接打开；如果href来源是一个servlet那么需要servlet对response输出流进行处理。href接受response输出流。</li>
<li>servlet的编写<ol>
<li>用content-disposition设置资源打开的方式</li>
<li>获取传递的参数，通过servletContext获取该文件的mime类型，再通过setContentType设置响应内容</li>
<li>获取服务器文件的路径（下载是从服务器中下载），api为servletContext.getRealPath</li>
<li>利用输入流将文件读取进内存，然后再输出到response输出流中。超链接就可以接收到流文件。剩下的工作就是浏览器进行操作。</li>
</ol>
</li>
</ul>
<h2 id="如何获取服务器文件路径"><a href="#如何获取服务器文件路径" class="headerlink" title="如何获取服务器文件路径"></a>如何获取服务器文件路径</h2><p>利用servletContext对象的方法getRealPath进行获取，不同文件位置获取方法参数不一样，如下</p>
<ol>
<li><p>文件在web目录下，参数路径就是文件名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/b.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
<li><p>文件在WEB-INF目录下，参数路径就是&#x2F;WEB-INF&#x2F;文件名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/WEB-INF/c.txt&quot;</span>);<span class="comment">//WEB-INF目录下的资源访问</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>文件在src目录下，参数路径就是&#x2F;WEB-INF&#x2F;classes&#x2F;文件名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/WEB-INF/classes/a.txt&quot;</span>);<span class="comment">//src目录下的资源访问</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="content-disposition-和content-type区别"><a href="#content-disposition-和content-type区别" class="headerlink" title="content-disposition 和content-type区别"></a>content-disposition 和content-type区别</h2><ul>
<li><p>content-disposition告诉浏览器文件的打开方式，一般用附件打开采用content-disposition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;content-disposition&quot;</span>,<span class="string">&quot;attachment;filname=111&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>content-type告诉浏览器响应的类型，参数一般是mime类型,需要借助servletContext获取对应文件的mime类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(context.getMimeType(fileName));</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 Netty介绍</title>
    <url>/2022/12/15/%E7%AC%AC%E4%B8%80%E7%AB%A0Netty%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-Netty介绍"><a href="#1-Netty介绍" class="headerlink" title="1. Netty介绍"></a>1. Netty介绍</h1><ol>
<li>是一个异步的、基于事件驱动的网络应用框架，用以开发高性能，高可靠性的网络io程序。</li>
<li>Netty主要针对在TCP协议下，面向clients端的高并发应用，或者peer-to-peer场景下大量数据持续传输的应用。</li>
<li>Netty本质上是一个NIO框架，适用于服务器通讯相关的多种应用场景。<br> <img src="https://img-blog.csdnimg.cn/direct/61a96819e845426db0f6b980cb184c6d.png" alt="netty是基于TCP的"></li>
</ol>
<h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h1><h2 id="2-1-互联网行业"><a href="#2-1-互联网行业" class="headerlink" title="2.1 互联网行业"></a>2.1 互联网行业</h2><ul>
<li>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少。Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。</li>
<li>典型的引用： 阿里分布式服务框架Dubbo 的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各个节点之间的内部通信。</li>
</ul>
<h2 id="2-2-游戏行业"><a href="#2-2-游戏行业" class="headerlink" title="2.2 游戏行业"></a>2.2 游戏行业</h2><ul>
<li>Netty作为高性能的基础通信组件，提高了TCP&#x2F;UDP和HTTP协议，方便定制和开发私有协议栈，账号登录服务器。</li>
<li>地图服务器之间可以方便的通过Netty进行高性能的通信。</li>
</ul>
<h2 id="2-3-大数据行业"><a href="#2-3-大数据行业" class="headerlink" title="2.3 大数据行业"></a>2.3 大数据行业</h2><ul>
<li>Hadoop的高性能通信和序列化组件Avro的RPC框架,默认采用Netty进行跨节点通信。</li>
<li>他的Netty Service基于Netty框架二次封装实现。</li>
</ul>
<h1 id="3-学习资料"><a href="#3-学习资料" class="headerlink" title="3. 学习资料"></a>3. 学习资料</h1><p><img src="https://img-blog.csdnimg.cn/direct/627cbfa4a361453eaa53557fcf9463d3.png" alt="Netty书籍"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 第一节JavaNIO编程</title>
    <url>/2022/12/16/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%B8%80%E8%8A%82JavaNIO%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-Java-NIO基本介绍"><a href="#1-Java-NIO基本介绍" class="headerlink" title="1. Java NIO基本介绍"></a>1. Java NIO基本介绍</h1><ol>
<li>Java NIO(Non-blocking IO)指JDK提供新的API.从JDK1.4开始，java提供了一系列改进IO的新特性，被统称为NIO,是同步非阻塞的。</li>
<li>NIO相关类和接口都放在<strong>java.nio</strong>包及其子包下面，并且对java.io包中很多类进行了改写。</li>
<li>NIO有三大核心部分：<strong>Channel(通道)， Buffer（缓冲区）， Selector(选择器)</strong></li>
<li>NIO是面向缓冲区的。数据读取到一个稍后处理的缓冲区中去，需要的时候可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用他可以提供非阻塞性的高伸缩性网络。</li>
<li>Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果么有数据可读，就什么也不用处理，而不是保持线程阻塞，该线程可以做其他的事情。</li>
<li>NIO可以一个线程处理多个操作。1000个请求过来，分配50-100个线程处理就够了，不需要像NIO那样，非得分配1000个。</li>
<li>HTTP2.0 使用了多路复用技术，一个连接并发处理多个请求。</li>
</ol>
<h1 id="2-NIO和BIO的比较"><a href="#2-NIO和BIO的比较" class="headerlink" title="2. NIO和BIO的比较"></a>2. NIO和BIO的比较</h1><ol>
<li>BIO以流的方式处理数据，NIO以块（缓存区）的方式处理数据，块的效率高</li>
<li>BIO是阻塞的，NIO是非阻塞的</li>
<li>BIO是基于字节流和字符流进行操作。而NIO是基于Channel和Buffer进行操作。数据总是从通道读取到缓存区。或者从缓存区写入到通道中。Selector用于监听多个通道的事件（连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li>
</ol>
<h1 id="3-NIO三大核心原理示意图"><a href="#3-NIO三大核心原理示意图" class="headerlink" title="3. NIO三大核心原理示意图"></a>3. NIO三大核心原理示意图</h1><p><img src="https://img-blog.csdnimg.cn/direct/fa5f276d66ec4f408641b2dc68008d04.png" alt="在这里插入图片描述"><br>一张图描述NIO中selector和channel和buffer的关系。<br>说明：</p>
<ol>
<li>每个channel都会对应一个buffer</li>
<li>一个线程对应一个selector,对应多个channel(连接)</li>
<li>该图反应了有三个channel注册到selector</li>
<li>线程切到哪个channel是事件event决定的。</li>
<li>selector根据不同的事件在通道上切换</li>
<li>channel是双向的，可以返回底层操作系统的情况，比如linux,底层的os通道就是双向的。</li>
<li>buffer就是一个内存块，底层是一个数组。</li>
<li>数据的读写是通过buffer。读写切换通过flip.</li>
</ol>
<h1 id="4-缓冲区（Buffer）"><a href="#4-缓冲区（Buffer）" class="headerlink" title="4.  缓冲区（Buffer）"></a>4.  缓冲区（Buffer）</h1><h2 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1 基本介绍"></a>4.1 基本介绍</h2><p>缓存区就是一个可以读写数据的内存块，理解为一个容器对象，对象提供了一组方法，可以方便操作内存块，能够跟踪记录缓存区的状态变化情况。channel提供了从文件，网络读取数据的渠道，但是读取或者写入的数据都必须经过buffer.</p>
<h2 id="4-2-buffer类和其子类"><a href="#4-2-buffer类和其子类" class="headerlink" title="4.2 buffer类和其子类"></a>4.2 buffer类和其子类</h2><p><img src="https://img-blog.csdnimg.cn/direct/5fd18ef546364690b0c05ee0529e5036.png" alt="在这里插入图片描述"></p>
<h1 id="5-通道（Channel）"><a href="#5-通道（Channel）" class="headerlink" title="5. 通道（Channel）"></a>5. 通道（Channel）</h1><h2 id="5-1-基本介绍"><a href="#5-1-基本介绍" class="headerlink" title="5.1  基本介绍"></a>5.1  基本介绍</h2><ol>
<li>通道类似于流，有些区别如下：</li>
</ol>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:<br><img src="https://img-blog.csdnimg.cn/direct/80d5a92c9d104042b35e51b5a01eca35.png" alt="在这里插入图片描述"></li>
</ul>
<ol start="2">
<li>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。</li>
<li>常用的 Channel 类有：FileChannel、DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li>
<li>FileChannel 用于文件的数据读写，DatagramChannel 用于 UDP 的数据读写，ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。<br>  <img src="https://img-blog.csdnimg.cn/direct/ed5095f248024e79a97ede89df20fb6f.png" alt="在这里插入图片描述"><br>  ByteBuffer我们用的比较多：<br>  <img src="https://img-blog.csdnimg.cn/direct/e8ffd47973b748b09e9193babe66ddc7.png" alt="在这里插入图片描述"></li>
</ol>
<h2 id="5-2-FileChannel"><a href="#5-2-FileChannel" class="headerlink" title="5.2  FileChannel"></a>5.2  FileChannel</h2><p>FileChannel主要用来对本地文件进行 IO 操作，常见的方法有</p>
<ol>
<li>public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中**(对channel读)**</li>
<li>public int write(ByteBuffer src) ，把缓冲区的数据写到通道中 <strong>（对channel写）</strong></li>
<li>public long  transferFrom(ReadableByteChannel src, long position, long   count)，从目标通道中复制数据到当前通道 </li>
<li>public long transferTo(long position, long   count, WritableByteChannel target)，把数据从当前通道复制给目标通道</li>
</ol>
<h3 id="5-2-1-实例1-本地文件写数据"><a href="#5-2-1-实例1-本地文件写数据" class="headerlink" title="5.2.1 实例1-本地文件写数据"></a>5.2.1 实例1-本地文件写数据</h3><p>使用前面学习后的ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,尚硅谷” 写入到file01.txt 中<br>流程：</p>
<ol>
<li>ByteBuffer对象中写入”hello,尚硅谷”。</li>
<li>FileOutputStream关联文件夹，并获取channel对象</li>
<li>将bytebuffer写入到channel中（写入channel就自动写入到文件了）<br>  注：Channel可以看做是流包装的对象，见下图。<br>  <img src="https://img-blog.csdnimg.cn/direct/f5f77375525641389d817b37b92c803f.png" alt="在这里插入图片描述"><br>  代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello,尚硅谷&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流-&gt;channel</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\file01.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//通过 fileOutputStream 获取 对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实 类型是  FileChannelImpl</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//将 str 放入 byteBuffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line">        <span class="comment">//对byteBuffer 进行flip</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">//将byteBuffer 数据写入到 fileChannel</span></span><br><span class="line">        fileChannel.write(byteBuffer);<span class="comment">//写入channel就自动就写入文件里了。</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-2-2-实例2-本地文件读数据"><a href="#5-2-2-实例2-本地文件读数据" class="headerlink" title="5.2.2 实例2-本地文件读数据"></a>5.2.2 实例2-本地文件读数据</h3><p>使用前面学习后的ByteBuffer(缓冲) 和 FileChannel(通道)， 将 file01.txt 中的数据读入到程序，并显示在控制台屏幕<br>流程：</p>
<ol>
<li>FileInputStream关联文件夹，并获取到channel</li>
<li>定义bytebuffer用来读取channel中的值，放到bytebuffer中</li>
<li>通过bytebuffer转换为string输出<br>  代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//创建文件的输入流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\file01.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">    <span class="comment">//通过fileInputStream 获取对应的FileChannel -&gt; 实际类型  FileChannelImpl</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">    <span class="comment">//创建缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) file.length());</span><br><span class="line">    <span class="comment">//将 通道的数据读入到Buffer</span></span><br><span class="line">    fileChannel.read(byteBuffer);</span><br><span class="line">    <span class="comment">//将byteBuffer 的 字节数据 转成String</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array()));</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-2-3-实例3-使用一个Buffer完成文件读取"><a href="#5-2-3-实例3-使用一个Buffer完成文件读取" class="headerlink" title="5.2.3 实例3-使用一个Buffer完成文件读取"></a>5.2.3 实例3-使用一个Buffer完成文件读取</h3><p>使用 FileChannel(通道) 和 方法  read , write，完成文件的拷贝。将file1.txt拷贝file2.txt<br>流程：</p>
<ol>
<li>通过FileInputStream关联file1.txt,并获取channel1</li>
<li>通过FileOutputStream关联file2.txt，并获取channel2</li>
<li>循环</li>
</ol>
<ul>
<li>读取前清空bytebuffer</li>
<li>读取channel1的内容，读取大小为bytebuffer申请的大小：channel1.read(bytebuffer)</li>
<li>bytebuffer.flip() 从写模式转化到读模式</li>
<li>将读取到bytebuffer中的内容写入到channel2中去：channel2.write(bytebuffer)<br>代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">       <span class="type">FileChannel</span> <span class="variable">fileChannel01</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">       <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line">       <span class="type">FileChannel</span> <span class="variable">fileChannel02</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">       <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//循环读取</span></span><br><span class="line">           <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public final Buffer clear() &#123;</span></span><br><span class="line"><span class="comment">               position = 0;</span></span><br><span class="line"><span class="comment">               limit = capacity;</span></span><br><span class="line"><span class="comment">               mark = -1;</span></span><br><span class="line"><span class="comment">               return this;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           byteBuffer.clear(); <span class="comment">//清空buffer因为之前是读状态，postion = limit。再写会导致read = 0。因此用clear重置position</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fileChannel01.read(byteBuffer);</span><br><span class="line">           System.out.println(<span class="string">&quot;read =&quot;</span> + read);</span><br><span class="line">           <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123; <span class="comment">//表示读完</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将buffer 中的数据写入到 fileChannel02 -- 2.txt</span></span><br><span class="line">           byteBuffer.flip();</span><br><span class="line">           fileChannel02.write(byteBuffer);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//关闭相关的流</span></span><br><span class="line">       fileInputStream.close();</span><br><span class="line">       fileOutputStream.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-2-4-实例4-拷贝文件transferFrom-方法"><a href="#5-2-4-实例4-拷贝文件transferFrom-方法" class="headerlink" title="5.2.4 实例4-拷贝文件transferFrom 方法"></a>5.2.4 实例4-拷贝文件transferFrom 方法</h3><p>使用 FileChannel(通道) 和 方法  transferFrom ，完成文件的拷贝。a.jpg拷贝到b.jpg<br>流程：</p>
<ol>
<li>FileInputStream关联a.jpg,获取sourceChannel</li>
<li>FileOutputStream关联b.jpg,获取DesChannel</li>
<li>DesChannel.transferFrom(sourceChannel, 0, sourceChannel.size()) 完成拷贝<br>  代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//创建相关流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\a.jpg&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\a2.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//获取各个流对应的filechannel</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">sourceCh</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">destCh</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">    <span class="comment">//使用transferForm完成拷贝</span></span><br><span class="line">    destCh.transferFrom(sourceCh,<span class="number">0</span>,sourceCh.size());</span><br><span class="line">    <span class="comment">//关闭相关通道和流</span></span><br><span class="line">    sourceCh.close();</span><br><span class="line">    destCh.close();</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-3-关于Buffer-和-Channel的注意事项和细节"><a href="#5-3-关于Buffer-和-Channel的注意事项和细节" class="headerlink" title="5.3  关于Buffer 和 Channel的注意事项和细节"></a>5.3  关于Buffer 和 Channel的注意事项和细节</h2><h2 id="5-3-1-bytebuffer支持类型化的put和get，put放入的是什么数据类型，get就应该使用相应的数据读出。"><a href="#5-3-1-bytebuffer支持类型化的put和get，put放入的是什么数据类型，get就应该使用相应的数据读出。" class="headerlink" title="5.3.1 bytebuffer支持类型化的put和get，put放入的是什么数据类型，get就应该使用相应的数据读出。"></a>5.3.1 bytebuffer支持类型化的put和get，put放入的是什么数据类型，get就应该使用相应的数据读出。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Buffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"><span class="comment">//类型化方式放入数据</span></span><br><span class="line">buffer.putInt(<span class="number">100</span>);</span><br><span class="line">buffer.putLong(<span class="number">9</span>);</span><br><span class="line">buffer.putChar(<span class="string">&#x27;尚&#x27;</span>);</span><br><span class="line">buffer.putShort((<span class="type">short</span>) <span class="number">4</span>);</span><br><span class="line"><span class="comment">//取出</span></span><br><span class="line">buffer.flip();</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(buffer.getInt());</span><br><span class="line">System.out.println(buffer.getLong());</span><br><span class="line">System.out.println(buffer.getChar());</span><br><span class="line">System.out.println(buffer.getShort());</span><br></pre></td></tr></table></figure>
<h2 id="5-3-2-可以将只读buffer抓换为只读buffer"><a href="#5-3-2-可以将只读buffer抓换为只读buffer" class="headerlink" title="5.3.2 可以将只读buffer抓换为只读buffer"></a>5.3.2 可以将只读buffer抓换为只读buffer</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个buffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">        buffer.put((<span class="type">byte</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="comment">//得到一个只读的Buffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">readOnlyBuffer</span> <span class="operator">=</span> buffer.asReadOnlyBuffer();</span><br><span class="line">    System.out.println(readOnlyBuffer.getClass());</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.println(readOnlyBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">    readOnlyBuffer.put((<span class="type">byte</span>)<span class="number">100</span>); <span class="comment">//ReadOnlyBufferException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-3-NIO提供了MappedByteBuffer-让文件直接在内存（jvm堆外内存）中进行修改，而如何同步到文件由NIO来完成。"><a href="#5-3-3-NIO提供了MappedByteBuffer-让文件直接在内存（jvm堆外内存）中进行修改，而如何同步到文件由NIO来完成。" class="headerlink" title="5.3.3 NIO提供了MappedByteBuffer,让文件直接在内存（jvm堆外内存）中进行修改，而如何同步到文件由NIO来完成。"></a>5.3.3 NIO提供了MappedByteBuffer,让文件直接在内存（jvm堆外内存）中进行修改，而如何同步到文件由NIO来完成。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);<span class="comment">// 支持从任意位置读取文件</span></span><br><span class="line"><span class="comment">//获取对应的通道</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> randomAccessFile.getChannel();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数1: FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment"> * 参数2： 0 ： 可以直接修改的起始位置</span></span><br><span class="line"><span class="comment"> * 参数3:  5: 是映射到内存的大小(不是索引位置) ,即将 1.txt 的多少个字节映射到内</span></span><br><span class="line"><span class="comment"> * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment"> * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">MappedByteBuffer</span> <span class="variable">mappedByteBuffer</span> <span class="operator">=</span> channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">mappedByteBuffer.put(<span class="number">0</span>, (<span class="type">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">mappedByteBuffer.put(<span class="number">3</span>, (<span class="type">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">mappedByteBuffer.put(<span class="number">5</span>, (<span class="type">byte</span>) <span class="string">&#x27;Y&#x27;</span>);<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">randomAccessFile.close();</span><br><span class="line">System.out.println(<span class="string">&quot;修改成功~~&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="5-3-4-NIO-还支持-通过多个Buffer-即-Buffer-数组-完成读写操作，即-Scattering-和-Gathering"><a href="#5-3-4-NIO-还支持-通过多个Buffer-即-Buffer-数组-完成读写操作，即-Scattering-和-Gathering" class="headerlink" title="5.3.4 NIO 还支持 通过多个Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering"></a>5.3.4 NIO 还支持 通过多个Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span></span><br><span class="line">      <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">      <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">7000</span>);</span><br><span class="line">      <span class="comment">//绑定端口到socket ，并启动</span></span><br><span class="line">      serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line">      <span class="comment">//创建buffer数组</span></span><br><span class="line">      ByteBuffer[] byteBuffers = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[<span class="number">2</span>];</span><br><span class="line">      byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">      byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">      <span class="comment">//等客户端连接(telnet)</span></span><br><span class="line">      <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">      <span class="type">int</span> <span class="variable">messageLength</span> <span class="operator">=</span> <span class="number">8</span>;   <span class="comment">//假定从客户端接收8个字节</span></span><br><span class="line">      <span class="comment">//循环的读取</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (byteRead &lt; messageLength ) &#123;</span><br><span class="line">              <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> socketChannel.read(byteBuffers);</span><br><span class="line">              byteRead += l; <span class="comment">//累计读取的字节数</span></span><br><span class="line">              System.out.println(<span class="string">&quot;byteRead=&quot;</span> + byteRead);</span><br><span class="line">              <span class="comment">//使用流打印, 看看当前的这个buffer的position 和 limit</span></span><br><span class="line">              Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="string">&quot;postion=&quot;</span> + buffer.position() + <span class="string">&quot;, limit=&quot;</span> + buffer.limit()).forEach(System.out::println);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//将所有的buffer进行flip</span></span><br><span class="line">          Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line">          <span class="comment">//将数据读出显示到客户端</span></span><br><span class="line">          <span class="type">long</span> <span class="variable">byteWirte</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (byteWirte &lt; messageLength) &#123;</span><br><span class="line">              <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> socketChannel.write(byteBuffers); <span class="comment">//</span></span><br><span class="line">              byteWirte += l;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//将所有的buffer 进行clear</span></span><br><span class="line">          Arrays.asList(byteBuffers).forEach(buffer-&gt; &#123;</span><br><span class="line">              buffer.clear();</span><br><span class="line">          &#125;);</span><br><span class="line">          System.out.println(<span class="string">&quot;byteRead:=&quot;</span> + byteRead + <span class="string">&quot; byteWrite=&quot;</span> + byteWirte + <span class="string">&quot;, messagelength&quot;</span> + messageLength);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-选择器（selector）"><a href="#6-选择器（selector）" class="headerlink" title="6. 选择器（selector）"></a>6. 选择器（selector）</h1><h2 id="6-1-基本介绍"><a href="#6-1-基本介绍" class="headerlink" title="6.1 基本介绍"></a>6.1 基本介绍</h2><ol>
<li>Java的NIO可以用非阻塞的IO方式。可以用一个线程处理多个客户端的请求，就会用到selector.</li>
<li>selector检测到注册的多个通道是否有事件发生（注意：多个channel以事件的形式注册到selector），如果有事件发生，获取对应的事件进行处理。这样一个线程通过一个selector管理多个通道（多个连接请求）</li>
<li>只有在连接通道有读写事件发生的时候才会读写，大大减少了系统开销。并且不需要为每一个连接创建一个线程，不用去维护多个线程。</li>
<li>避免了多个线程上下文切换导致的开销。</li>
</ol>
<h2 id="6-2-示意图和特点说明"><a href="#6-2-示意图和特点说明" class="headerlink" title="6.2 示意图和特点说明"></a>6.2 示意图和特点说明</h2><p> <img src="https://img-blog.csdnimg.cn/direct/7264a3fcec49446584cdcf016062b157.png" alt="在这里插入图片描述"><br>说明：</p>
<ol>
<li>netty的IO线程聚合了selector，可以同时处理上千个客户端连接。</li>
<li>当线程从客户端socketchannel进行读写数据时，如果没有数据可用，该线程可以进行其他任务</li>
<li>线程将非阻塞的io的空闲时间用于其他通道执行io操作，所以单独的线程可以处理多个客户端</li>
<li>读写都是非阻塞的，充分提高了io线程的运行效率</li>
<li>一个io线程处理多个客户端的请求。从根本上解决了传统阻塞型io一线程一连接模型，架构的性能，可靠性得到了极大提升。</li>
</ol>
<h2 id="6-3-selector类相关方法"><a href="#6-3-selector类相关方法" class="headerlink" title="6.3 selector类相关方法"></a>6.3 selector类相关方法</h2><p>selector是一个抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Selector</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//得到一个选择器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">long</span> timeout)</span>;<span class="comment">//监控所有注册的通道，当其中有 IO 操作可以进行时，将对应的 SelectionKey 加入到内部集合中并返回，参数用来设置超时时间</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title function_">selectedKeys</span><span class="params">()</span>;<span class="comment">//从内部集合中得到所有的 SelectionKey，也就是发生事件的selectKey</span></span><br><span class="line">&#125;</span><br><span class="line">selector.select()<span class="comment">//阻塞,直到获取到有事件发生的selectkey</span></span><br><span class="line">selector.select(<span class="number">1000</span>);<span class="comment">//阻塞1000毫秒，在1000毫秒后返回</span></span><br><span class="line">selector.wakeup();<span class="comment">//唤醒selector</span></span><br><span class="line">selector.selectNow();<span class="comment">//不阻塞，立马返还</span></span><br></pre></td></tr></table></figure>
<h2 id="6-4-NIO非阻塞原理分析（加入了selector细致分析）"><a href="#6-4-NIO非阻塞原理分析（加入了selector细致分析）" class="headerlink" title="6.4 NIO非阻塞原理分析（加入了selector细致分析）"></a>6.4 NIO非阻塞原理分析（加入了selector细致分析）</h2><p><img src="https://img-blog.csdnimg.cn/direct/5a242a1afcf14c77ac56819907f59dbb.png" alt="在这里插入图片描述"><br>上图的说明：<br>以selector为中心：</p>
<ol>
<li>serverSocketChannel注册到selector上，事件为accept，表示监听客户端连接</li>
<li>客户端连接的时候selector 会监听，通过selectKeys方法得到所有的selectKey。判断selectKey是否isAcceptable,如果是就获取客户端的socketChannel.</li>
<li>获取到客户端的channel后同样注册到selector上，注册操作师读操作。如果selectKey是isReadable，就获取socketChannel进行业务处理</li>
</ol>
<h2 id="6-5-NIO-非阻塞-网络编程快速入门"><a href="#6-5-NIO-非阻塞-网络编程快速入门" class="headerlink" title="6.5 NIO 非阻塞 网络编程快速入门"></a>6.5 NIO 非阻塞 网络编程快速入门</h2><h3 id="6-5-1-案例要求"><a href="#6-5-1-案例要求" class="headerlink" title="6.5.1 案例要求"></a>6.5.1 案例要求</h3><p>案例要求:<br>编写一个 NIO 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）<br>目的：理解NIO非阻塞网络编程机制<br>看老师代码演示</p>
<h3 id="6-5-2-流程"><a href="#6-5-2-流程" class="headerlink" title="6.5.2 流程"></a>6.5.2 流程</h3><h4 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h4><ol>
<li>实例化serverSocketChannel并绑定端口6666, 设置为非阻塞。实例化selector对象。将serverSocketChannel注册到selector中，注册事件为OP_ACCEPT</li>
<li>循环等待客户端连接</li>
</ol>
<ul>
<li>selector的select（1s）方法看有无事件发生。无事件发生一直循环</li>
<li>如果有事件发生，获取selectedKeys，遍历selectedKey。<ul>
<li>判断是否是Acceptable事件。如果是，serverSocektChannel accept到一个客户端的socketChannel。将其注册到selector中，注册事件为OP_READABLE.</li>
<li>因为selector新注册了客户端读事件，要新增判断条件，如果selectKey是isReadable通过key获取到channe进行读取操作。</li>
<li>循环过程中记得移除遍历过的selectedKey</li>
</ul>
</li>
</ul>
<h4 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h4><ol>
<li>实例化socketChannel，连接服务器</li>
<li>如果连接成功了，就往socetChannel写入数据（相当于发送了数据）</li>
</ol>
<h3 id="6-5-3-代码"><a href="#6-5-3-代码" class="headerlink" title="6.5.3 代码"></a>6.5.3 代码</h3><p>服务端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel -&gt; ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//得到一个Selecor对象</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">//绑定一个端口6666, 在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//把 serverSocketChannel 注册到  selector 关心 事件为 OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;注册后的selectionkey 数量=&quot;</span> + selector.keys().size()); <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//这里我们等待1秒，如果没有事件发生, 返回</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>) &#123; <span class="comment">//没有事件发生</span></span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等待了1秒，无连接&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果返回的&gt;0, 就获取到相关的 selectionKey集合</span></span><br><span class="line">            <span class="comment">//1.如果返回的&gt;0， 表示已经获取到关注的事件</span></span><br><span class="line">            <span class="comment">//2. selector.selectedKeys() 返回关注事件的集合</span></span><br><span class="line">            <span class="comment">//   通过 selectionKeys 反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            System.out.println(<span class="string">&quot;selectionKeys 数量 = &quot;</span> + selectionKeys.size());</span><br><span class="line">            <span class="comment">//遍历 Set&lt;SelectionKey&gt;, 使用迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//获取到SelectionKey</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                <span class="comment">//根据key 对应的通道发生的事件做相应处理</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123; <span class="comment">//如果是 OP_ACCEPT, 有新的客户端连接</span></span><br><span class="line">                    <span class="comment">//该该客户端生成一个 SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接成功 生成了一个 socketChannel &quot;</span> + socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将  SocketChannel 设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">//将socketChannel 注册到selector, 关注事件为 OP_READ， 同时给socketChannel</span></span><br><span class="line">                    <span class="comment">//关联一个Buffer</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接后 ，注册的selectionkey 数量=&quot;</span> + selector.keys().size()); <span class="comment">//2,3,4..</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(key.isReadable()) &#123;  <span class="comment">//发生 OP_READ</span></span><br><span class="line">                    <span class="comment">//通过key 反向获取到对应channel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel)key.channel();</span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer)key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;form 客户端 &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//手动从集合中移动当前的selectionKey, 防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的ip 和 端口</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(inetSocketAddress)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间，客户端不会阻塞，可以做其它工作..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...如果连接成功，就发送数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello, 尚硅谷~&quot;</span>;</span><br><span class="line">        <span class="comment">//Wraps a byte array into a buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(str.getBytes());</span><br><span class="line">        <span class="comment">//发送数据，将 buffer 数据写入 channel</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-6-案例中相关类说明"><a href="#6-6-案例中相关类说明" class="headerlink" title="6.6 案例中相关类说明"></a>6.6 案例中相关类说明</h2><h3 id="6-6-1-SelectionKey"><a href="#6-6-1-SelectionKey" class="headerlink" title="6.6.1 SelectionKey"></a>6.6.1 SelectionKey</h3><p>表示selector和网络通道的注册关系。通过key可以获取到channel.<br>注册关系分为下面四种：<br>int OP_ACCEPT：有新的网络连接可以 accept，值为 16<br>int OP_CONNECT：代表连接已经建立，值为 8<br>int OP_READ：代表读操作，值为 1<br>int OP_WRITE：代表写操作，值为 4<br>源码中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SelectionKey相关方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SelectionKey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title function_">selector</span><span class="params">()</span>;<span class="comment">//得到与之关联的 Selector 对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title function_">channel</span><span class="params">()</span>;<span class="comment">//得到与之关联的通道</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">attachment</span><span class="params">()</span>;<span class="comment">//得到与之关联的共享数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title function_">interestOps</span><span class="params">(<span class="type">int</span> ops)</span>;<span class="comment">//设置或改变监听事件.比如原来是accept现在可以改为read事件</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isAcceptable</span><span class="params">()</span>;<span class="comment">//是否可以 accept</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isReadable</span><span class="params">()</span>;<span class="comment">//是否可以读</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isWritable</span><span class="params">()</span>;<span class="comment">//是否可以写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-6-2-ServerSocketChannel"><a href="#6-6-2-ServerSocketChannel" class="headerlink" title="6.6.2 ServerSocketChannel"></a>6.6.2 ServerSocketChannel</h3><p>在服务端监听新的客户端连接<br>相关方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ServerSocketChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title class_">NetworkChannel</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title function_">open</span><span class="params">()</span><span class="comment">//得到一个 ServerSocketChannel 通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title function_">bind</span><span class="params">(SocketAddress local)</span><span class="comment">//设置服务器端端口号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title function_">configureBlocking</span><span class="params">(<span class="type">boolean</span> block)</span><span class="comment">//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span><br><span class="line"><span class="keyword">public</span> SocketChannel <span class="title function_">accept</span><span class="params">()</span><span class="comment">//接受一个连接，返回代表这个连接的通道对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops)</span><span class="comment">//注册一个选择器并设置监听事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-6-2-SocketChannel"><a href="#6-6-2-SocketChannel" class="headerlink" title="6.6.2 SocketChannel"></a>6.6.2 SocketChannel</h3><p>网络IOchannel，负责进行读写操作。可以将数据读或写入通道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SocketChannel</span> <span class="keyword">extends</span> <span class="title class_">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title class_">ByteChannel</span>, ScatteringByteChannel, GatheringByteChannel, NetworkChannel&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title function_">open</span><span class="params">()</span>;<span class="comment">//得到一个 SocketChannel 通道</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title function_">configureBlocking</span><span class="params">(<span class="type">boolean</span> block)</span>;<span class="comment">//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connect</span><span class="params">(SocketAddress remote)</span>;<span class="comment">//连接服务器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">finishConnect</span><span class="params">()</span>;<span class="comment">//如果上面的方法连接失败，接下来就要通过该方法完成连接操作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(ByteBuffer src)</span>;<span class="comment">//往通道里写数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst)</span>;<span class="comment">//从通道里读数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops, Object att)</span>;<span class="comment">//注册一个选择器并设置监听事件，最后一个参数可以设置共享数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;<span class="comment">//关闭通道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 第三节NIO零拷贝</title>
    <url>/2022/12/18/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82NIO%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-NIO与零拷贝"><a href="#1-NIO与零拷贝" class="headerlink" title="1. NIO与零拷贝"></a>1. NIO与零拷贝</h1><h2 id="1-1-零拷贝基本介绍"><a href="#1-1-零拷贝基本介绍" class="headerlink" title="1.1 零拷贝基本介绍"></a>1.1 零拷贝基本介绍</h2><ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开</li>
<li>Java程序中，常用的零拷贝有mmap(内存映射)和sendFile。</li>
</ol>
<h3 id="传统的IO数据读写"><a href="#传统的IO数据读写" class="headerlink" title="传统的IO数据读写"></a>传统的IO数据读写</h3><p> 需要三次用户态和内核态切换<br> 4次内存的拷贝<br><img src="https://img-blog.csdnimg.cn/direct/3aca32ecdbea4b52bcd88e2ef8908cec.png" alt="在这里插入图片描述"></p>
<h3 id="mmap优化"><a href="#mmap优化" class="headerlink" title="mmap优化"></a>mmap优化</h3><ol>
<li>mmap经过内存映射（userbuffer 和 kernelbuffer 共享），将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据（直接从内核空间buffer拷贝到内核空间socketbuffer）。这样，进行网络传输时，可以减少内核空间到用户空间的拷贝次数。<br>  <img src="https://img-blog.csdnimg.cn/direct/dc402123c3a64d2d84cbbf52aceb9ee1.png" alt="在这里插入图片描述"></li>
</ol>
<h3 id="sendFile优化（DMA-copy）"><a href="#sendFile优化（DMA-copy）" class="headerlink" title="sendFile优化（DMA copy）"></a>sendFile优化（DMA copy）</h3><ol>
<li>linux2.1 ：数据不经过用户态，直接从内核缓冲区 &#x3D;&gt; socketBuffer &#x3D;&gt; protocal engin.，由于和用户态完全无关，就减少了一次上下文切换.<br><img src="https://img-blog.csdnimg.cn/direct/395bc55550aa4ef1a44de30c275b02c8.png" alt="在这里插入图片描述"></li>
<li>linux2.4: 直接从内核缓冲区 &#x3D;&gt; 协议栈（拷贝到socketBuffer信息很少，忽略不计）<br>  <img src="https://img-blog.csdnimg.cn/direct/b283190e735f4eefa6e45bf4304437c5.png" alt="在这里插入图片描述"></li>
</ol>
<h3 id="零拷贝再次理解"><a href="#零拷贝再次理解" class="headerlink" title="零拷贝再次理解"></a>零拷贝再次理解</h3><ol>
<li>零拷贝:指的是没有CPU拷贝。通过DMA拷贝。(所谓DMA拷贝就是通过其他硬件负责数据的转移，不需要CPU参与，解放了CPU。<a href="https://blog.csdn.net/Erica_1230/article/details/106130799">DMA copy 和 CPU copy</a>)</li>
<li>零拷贝优势：更少的数据复制，减少上下文切换（内核态和用户态的切换）。</li>
</ol>
<h3 id="mmap-和-sendFile-的区别"><a href="#mmap-和-sendFile-的区别" class="headerlink" title="mmap 和 sendFile 的区别"></a>mmap 和 sendFile 的区别</h3><ol>
<li>mmap适合小数据量读写，sendFile适合大文件传输</li>
<li>sendFile可以利用DMA，减少cpu拷贝。mmap不能，它是用户buffer和内核buffer共享的。</li>
</ol>
<h2 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1. 2 案例"></a>1. 2 案例</h2><p>使用NIO零拷贝方式传递（channel.transeferTo）一个大文件。速度快得多。</p>
<h1 id="2-Java-AIO-基本介绍"><a href="#2-Java-AIO-基本介绍" class="headerlink" title="2. Java AIO 基本介绍"></a>2. Java AIO 基本介绍</h1><ol>
<li>JDK1.7引入了AIO,采用了Proactor模式，简化了程序编写，有效的请求才启动线程，他的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时长较长的应用。</li>
<li>目前AIO还没有广泛使用。netty是基于NIO的而不是AIO.</li>
</ol>
<h1 id="3-BIO-NIO-AIO-对比"><a href="#3-BIO-NIO-AIO-对比" class="headerlink" title="3. BIO NIO AIO 对比"></a>3. BIO NIO AIO 对比</h1><p><img src="https://img-blog.csdnimg.cn/direct/dfad9627ec7b470cbe56c62369dcf760.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 java BIO编程</title>
    <url>/2022/12/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0JavaBio%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-I-O模型"><a href="#1-I-O模型" class="headerlink" title="1.  I&#x2F;O模型"></a>1.  I&#x2F;O模型</h1><h2 id="1-1-I-O模型的基本说明"><a href="#1-1-I-O模型的基本说明" class="headerlink" title="1.1 I&#x2F;O模型的基本说明"></a>1.1 I&#x2F;O模型的基本说明</h2><ol>
<li><p>I&#x2F;O模型简单的理解：就是用什么样的数据通道进行数据的发送和接受，很大程度上决定了IO程序的性能</p>
</li>
<li><p>java支持三种IO模型：BIO, NIO, AIO</p>
</li>
<li><p>java BIO: 同步非阻塞模型（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有一个连接，服务器就新建一个线程进行处理，如果这个连接不释放，这个线程就会阻塞在那里造成不必要的线程开销。</p>
<p><img src="https://img-blog.csdnimg.cn/direct/dd97952364b743319d249142277d2709.png" alt="在这里插入图片描述"></p>
</li>
<li><p>java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的请求连接会注册到多路复用器上，多路复用器轮询到连接有IO请求就会进行处理。</p>
<p><img src="https://img-blog.csdnimg.cn/direct/5d654a5f588b44bca49c2dbb5681e277.png" alt="在这里插入图片描述"></p>
</li>
<li><p>java AIO: 异步非阻塞，AIO引入了异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，他的特点是操作系统完成后才通知服务端程序启动线程去处理，一般使用于连接数量较多，连接时间较长的应用。</p>
</li>
</ol>
<h1 id="2-BIO-NIO-AIO使用场景分析"><a href="#2-BIO-NIO-AIO使用场景分析" class="headerlink" title="2. BIO,NIO,AIO使用场景分析"></a>2. BIO,NIO,AIO使用场景分析</h1><ol>
<li>BIO适用于 连接数量少，架构固定的应用，对服务器资源要求高。程序简单容易理解.JDK 1.4以前的选择。</li>
<li>NIO适用于连接数量多，连接时间短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等，编程较为复杂。JDK1.4之后开始支持。</li>
<li>AIO适用于连接数量多，连接时间长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂。JDK1.7之后开始支持</li>
</ol>
<h1 id="3-Java-BIO基本介绍"><a href="#3-Java-BIO基本介绍" class="headerlink" title="3. Java BIO基本介绍"></a>3. Java BIO基本介绍</h1><ol>
<li>java BIO 是传统的IO编程，相关的类和接口都在java.io</li>
<li>BIO(Blocing IO):同步阻塞模型，服务器实现模式为一个连接对应一个线程进行处理，如果连接不做任何事情会造成不必要的线程开销。</li>
<li>BIO适用于连接数量较少且固定的架构，对服务器资源要求较高</li>
</ol>
<h1 id="4-Java-BIO的工作机制"><a href="#4-Java-BIO的工作机制" class="headerlink" title="4. Java BIO的工作机制"></a>4. Java BIO的工作机制</h1><p><img src="https://img-blog.csdnimg.cn/direct/7accfb01aa7044f290901a779b8d318e.png" alt="在这里插入图片描述"></p>
<ol>
<li>服务端会启动一个serversocket</li>
<li>客户端启动socket对服务器进行通信，默认情况下服务端对客户端的每一个连接都要新建一个线程处理该连接</li>
<li>客户端发出请求后，看服务器是否有现成线程相应，没有会等待，或者拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li>
</ol>
<h1 id="5-Java-BIO应用举例"><a href="#5-Java-BIO应用举例" class="headerlink" title="5. Java BIO应用举例"></a>5. Java BIO应用举例</h1><h2 id="5-1-需求"><a href="#5-1-需求" class="headerlink" title="5.1 需求"></a>5.1 需求</h2><ol>
<li>使用BIO模型编写一个服务器，监听6666端口，当有客户端连接时，启动一个线程与其通信。</li>
<li>要求使用线程池，可以连接多个客户端。</li>
<li>服务端接受用户发送的数据（终端中用Telnet方式发送数据）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">newCachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息 id =&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 名字=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); <span class="comment">// 会阻塞，主线程一直阻塞在这里等待新的连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//我们重写</span></span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息 id =&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 名字=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket 获取输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息 id =&quot;</span> + Thread.currentThread().getId() + <span class="string">&quot; 名字=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;read....&quot;</span>);</span><br><span class="line">               <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span>  inputStream.read(bytes); <span class="comment">// 会阻塞。子线程会阻塞在这里接受新的消息。</span></span><br><span class="line">               <span class="keyword">if</span>(read != -<span class="number">1</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, read</span><br><span class="line">                   )); <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-2-分析"><a href="#5-2-分析" class="headerlink" title="5.2 分析"></a>5.2 分析</h2><ol>
<li>Main线程监听6666端口，一旦有客户端请求连接，从线程池中new 一个线程thread_i进行处理。</li>
<li>thread_i线程处理socket连接，对对应客户端进行数据Read,业务处理，数据write等操作。</li>
<li>并发数较大的时候，创建大量线程，系统资源占用较大。</li>
<li>连接建立后，如果当前线程没有数据可读，thread_i会阻塞到Read操作上，造成线程阻塞，系统资源浪费。</li>
</ol>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章Netty第二节协议设计：自定义编解码器</title>
    <url>/2022/12/24/%E7%AC%AC%E4%BA%94%E7%AB%A0Netty%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="协议设计与解析"><a href="#协议设计与解析" class="headerlink" title="协议设计与解析"></a>协议设计与解析</h1><h2 id="为什么需要协议"><a href="#为什么需要协议" class="headerlink" title="为什么需要协议"></a>为什么需要协议</h2><p>TCP&#x2F;IP消息传输是基于二进制流的方式，没有边界。<br>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则。<br>例如：在网络上传输</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下雨天留客天留我不留</span><br></pre></td></tr></table></figure>
<p>是中文中一句著名的无标点符号的句子，没有标点符号，有很多种拆解方式，不同拆解有不同的意思。这就是说明了标点符号的重要性，也就是消息边界的重要性。<br>网络中的协议，也就是给网络传输的信息加上「标点符号」。下面一种协议较为常用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定长字节表示内容长度 + 实际内容</span><br></pre></td></tr></table></figure>
<p>netty中通过LengthFieldBasedFrameDecoder来实现。</p>
<h2 id="redis协议举例"><a href="#redis协议举例" class="headerlink" title="redis协议举例"></a>redis协议举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">byte</span>[] LINE = &#123;<span class="number">13</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">    bootstrap.group(worker);</span><br><span class="line">    bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="comment">// 会在连接 channel 建立成功后，会触发 active 事件</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    set(ctx);</span><br><span class="line">                    get(ctx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*2&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;get&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;bbb&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>).sync();</span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    worker.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="http协议举例"><a href="#http协议举例" class="headerlink" title="http协议举例"></a>http协议举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.advance.c2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.DefaultFullHttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponseStatus;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHttp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());<span class="comment">// Codec:coder &amp; decoder缩写，编解码器</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123;<span class="comment">// 只关注HttpRequest消息</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 获取请求</span></span><br><span class="line">                            log.debug(msg.uri());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 返回响应</span></span><br><span class="line">                            <span class="type">DefaultFullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span></span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"></span><br><span class="line">                            <span class="type">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">                            response.headers().setInt(CONTENT_LENGTH, bytes.length);<span class="comment">// 如果不设置响应头长度，浏览器会一直转圈圈</span></span><br><span class="line">                            response.content().writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 写回响应</span></span><br><span class="line">                            ctx.writeAndFlush(response);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">/*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;</span></span><br><span class="line"><span class="comment">                        @Override</span></span><br><span class="line"><span class="comment">                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">                            log.debug(&quot;&#123;&#125;&quot;, msg.getClass());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                            if (msg instanceof HttpRequest) &#123; // 请求行，请求头</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                            &#125; else if (msg instanceof HttpContent) &#123; //请求体</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;);*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>流程总结：</p>
<ul>
<li>实例化ServerBootstrap</li>
<li>添加channel，添加group(处理的线程池)</li>
<li>添加childHandler：ChannelInitalizer</li>
<li>pipeline中添加LoggingHandler</li>
<li>pipeline中添加HttpServerCodec（http协议的编解码器）</li>
<li>pipeline中添加SimpleChannelInboundHandler接受http请求，响应数据</li>
<li>绑定端口</li>
<li>sync方法同步执行完</li>
<li>通过try catch  finally关闭boss组和worker组。</li>
</ul>
<h2 id="自定义协议要素"><a href="#自定义协议要素" class="headerlink" title="自定义协议要素"></a>自定义协议要素</h2><p>如果我们自定义一个协议需要哪些信息呢？</p>
<ul>
<li>魔数：用来在第一时间判定是否是无效数据包，比如java字节码开头是CAFEBABE</li>
<li>版本号:标识协议的版本号，支持协议升级</li>
<li>序列化算法:消息正文到底采用哪种序列化反序列化方式。例如：Json,jdk等</li>
<li>指令类型：跟业务相关，是登录，注册，单聊，群聊等</li>
<li>请求序号：为了双工通信，提供异步能力</li>
<li>正文长度</li>
<li>消息正文</li>
</ul>
<h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>根据上面的要素，设计一个登录请求消息和登录响应消息。使用netty完成收发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">//@ChannelHandler.Sharable // 继承自ByteToMessageCodec（注释中说了不能共享），所谓共享就是并发下是线程安全的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);<span class="comment">//为了给下一个handler用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(</span><br><span class="line">        <span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MessageCodec</span>()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// encode</span></span><br><span class="line"><span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//        channel.writeOutbound(message);//测试编码，要写入outbound，outbound对应写出，写出的时候编码。</span></span><br><span class="line"><span class="comment">// decode</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>, message, buf);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s2</span> <span class="operator">=</span> buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">s1.retain(); <span class="comment">// 引用计数 2</span></span><br><span class="line">channel.writeInbound(s1); <span class="comment">// release 1</span></span><br><span class="line">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure>
<h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><p><img src="https://img-blog.csdnimg.cn/direct/6f57e9d5cee9402e8d46b06e2a0f7d44.png" alt="在这里插入图片描述"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>在解码decode的时候，避免传过来的数据是不完整的，需要在codec前面加一个LengthFieldBasedFrameDecoder验证数据的完整性（长度偏移，长度等）</li>
<li>在测试decode的时候，对数据进行分片了，要注意加上s1.retain(); &#x2F;&#x2F; 引用计数 2。不然会引用数变为0ByteBuf被清理掉。出现IllegalReferenceCountException错误。</li>
</ul>
<h2 id="Sharable"><a href="#Sharable" class="headerlink" title="@Sharable"></a>@Sharable</h2><ul>
<li>当handler不保存状态的时候，就可以安全的在多线程下共享。（加了这个表明handler是线程安全的）​</li>
</ul>
<ul>
<li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制，即明确了不能加@Sharable。换为继承自MessageToMessageCodeC父类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 第二节NIO网络编程应用实例-群聊系统</title>
    <url>/2022/12/17/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%BA%8C%E8%8A%82NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-案例需求"><a href="#1-案例需求" class="headerlink" title="1. 案例需求"></a>1. 案例需求</h1><p>编写一个 NIO 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）实现多人群聊服务器端：可以监测用户上线，离线，并实现消息转发功能客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)<br>目的：进一步理解NIO非阻塞网络编程机制<br><img src="https://img-blog.csdnimg.cn/direct/de1f5387a10e436a82d01f9e55e4d513.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/direct/64e1c545ab0942be838f3b0788111029.png" alt="在这里插入图片描述"></p>
<h1 id="2-流程"><a href="#2-流程" class="headerlink" title="2. 流程"></a>2. 流程</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ol>
<li>监听客户端连接</li>
</ol>
<ul>
<li>初始化工作，实例化selector,实例化serverSocketChannel.设置非阻塞。注册ACCEPT事件</li>
<li>监听客户端连接请求，将socketChannel注册到selector,注册为READ事件。</li>
</ul>
<ol start="2">
<li>读取客户端信息，打印输出</li>
</ol>
<ul>
<li>读取socketChannel信息</li>
</ul>
<ol start="3">
<li>将客户端信息转发到其他的客户端</li>
</ol>
<ul>
<li>获取所有的keys。如果channel instanceof socketChannel &amp;&amp; 不是当前的客户端的channel，向其他客户端channel写入数据。</li>
</ul>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol>
<li>发送信息<br>初始化工作，实例化selector,实例化SocketChannel，连接服务器.设置非阻塞。向socketChannel写入信息</li>
<li>接受信息<br>selector.select()看是否有事件，有则遍历key,获取通道读取数据。<br>注意：读写数据都是通过channel。<br>三种方法获取channel:</li>
<li>serverSocketChannel.accept() 服务端 </li>
<li>socketChannel.open(new InetSocketAddress(“127.0.0.1”, PORT)); 客户端 </li>
<li>SocketChannel sc &#x3D; (SocketChannel) key.channel(); 通过selector的selectionKey获取（事件获取）</li>
</ol>
<h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h1><p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel =  ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//将该listenChannel 注册到selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;<span class="comment">//有事件处理</span></span><br><span class="line">                    <span class="comment">//遍历得到selectionKey 集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">//取出selectionkey</span></span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="comment">//监听到accept</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到seletor</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable()) &#123; <span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">//处理读 (专门写方法..)</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="comment">//取到关联的channle</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据count的值做处理</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form 客户端: &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己), 专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot; 离线了..&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self )</span> <span class="keyword">throws</span>  IOException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发数据给客户端线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//遍历 所有注册到selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span>(SelectionKey key: selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key  取出对应的 SocketChannel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span>  SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">dest</span> <span class="operator">=</span> (SocketChannel)targetChannel;</span><br><span class="line">                <span class="comment">//将msg 存储到buffer</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer 的数据写入 通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">groupChatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>; <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">//构造器, 完成初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = socketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//将channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span>(readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                       <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                       <span class="comment">//得到一个Buffer</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove(); <span class="comment">//删除当前的selectionKey, 防止重复操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        <span class="type">GroupChatClient</span> <span class="variable">chatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>();</span><br><span class="line">        <span class="comment">//启动一个线程, 每隔3秒，读取从服务器发送数据。这里启动线程是因为主线程要发送数据接受用户数据，会阻塞，因此要用新的线程处理接受消息。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章Netty第一节 粘包和半包</title>
    <url>/2022/12/23/%E7%AC%AC%E4%BA%94%E7%AB%A0Netty%E7%AC%AC%E4%B8%80%E8%8A%82%E7%B2%98%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h1><h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><p>现象：发送abc  def,接受到abcdef</p>
<p>原因：</p>
<ul>
<li>应用层：接收方ByteBuf设置太大（Netty默认是1024）</li>
<li>传输层滑动窗口： 假设发送方256 bytes表示一个完整的报文，接收方的滑动窗口来不及处理且滑动窗口足够大，导致多个报文在一个滑动窗口中，导致粘包。（TCP协议）</li>
<li>Nagle算法：会造成粘包。Nagle算法是TCP协议中的一种机制，有时候发送一个字节，也需要加入TCP头和IP头，有点浪费网络。为了提高网络利用率，会将少量数据进行延迟发送，积攒起来一起发送。会造成粘包现象。</li>
</ul>
<h2 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h2><p>现象：发送abcdef,接受abc def<br>原因：</p>
<ul>
<li>应用层：接收方的ByteBuf小于实际发送的数据，导致一个数据报文被拆分了。</li>
<li>传输层滑动窗口：假设接收方的滑动窗口大小为128bytes，这时候发送方发了256bytes，滑动窗口接受不过来，让发送方只能先发128bytes，等待ACK后，才能发送剩余的数据。造成一个完整的报文被拆分开。（传输层TCP协议）</li>
<li>MSS(max segment size)限制：当发送的数据超出MSS限制后，会将数据切分后发送，会造成半包。<br>本质上是因为TCP协议是基于字节流的（首部没有长度），消息没有边界，所以会造成粘包和半包现象。UDP是面向报文的（首部有长度），所以不会有粘包和半包现象。</li>
</ul>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="方法1-短链接"><a href="#方法1-短链接" class="headerlink" title="方法1 短链接"></a>方法1 短链接</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;conneted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 短链接相当于发送一个数据就断开一次。只能解决粘包。接受的ByteBuf还是有限的，还是会有半包问题。</p>
</blockquote>
<h2 id="方法2-固定长度"><a href="#方法2-固定长度" class="headerlink" title="方法2 固定长度"></a>方法2 固定长度</h2><p>客户端和服务端商量好发送的数据包具有固定长度。如果不够长，就用占位符占位。<br>让所有的数据包长度固定（假设长度为10字节），服务端加入FixedLengthFrameDecoder进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; r.nextInt(<span class="number">8</span>); j++) &#123;</span><br><span class="line">                                    bytes[j] = (<span class="type">byte</span>) c;</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                                buffer.writeBytes(bytes);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 缺点是数据包的大小不好把握。长度只能定的太大，占位符就会多。浪费空间。因此长度最好定位最大的数据包的长度。仅仅适用于提前知道数据包的长度的情况。</p>
</blockquote>
<h2 id="方法3-固定分隔符"><a href="#方法3-固定分隔符" class="headerlink" title="方法3 固定分隔符"></a>方法3 固定分隔符</h2><p>客户端和服务端商量好发送的数据包具有特定的分隔符。服务端用LineBasedFrameDecoder处理,自动将接受到的消息用\n进行分隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure>
<p>客户端在每条消息之后，加入\n分隔符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果本身传输的数据中有分隔符，会解析错误</p>
</blockquote>
<h2 id="方法4-预设长度（推荐）"><a href="#方法4-预设长度（推荐）" class="headerlink" title="方法4 预设长度（推荐）"></a>方法4 预设长度（推荐）</h2><p>在发送消息前，先约定用定长字节表示接下来数据的长度。服务端用LengthFieldBasedFrameDecoder来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整(长度占用字节后偏移多少个才是真正的数据)，剥离字节数（用于接受的数据去除长度占用的字节信息）</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.advance.c1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBufAllocator;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.embedded.EmbeddedChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLengthFieldDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(</span><br><span class="line">                        <span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>,<span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  4 个字节的内容长度， 实际内容</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        send(buffer, <span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">        send(buffer, <span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">        channel.writeInbound(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(ByteBuf buffer, String content)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = content.getBytes(); <span class="comment">// 实际内容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> bytes.length; <span class="comment">// 实际内容长度</span></span><br><span class="line">        buffer.writeInt(length);</span><br><span class="line">        buffer.writeByte(<span class="number">1</span>);</span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章Netty第一节概述</title>
    <url>/2022/12/19/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E4%B8%80%E8%8A%82%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-原生NIO存在的问题"><a href="#1-原生NIO存在的问题" class="headerlink" title="1. 原生NIO存在的问题"></a>1. 原生NIO存在的问题</h1><ol>
<li>NIO的类库和API繁杂，使用麻烦。需要熟练掌握Selector, ServerSocketChannel, SocketChannel, ByteBuffer等。</li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li>
</ol>
<h1 id="2-Netty官方说明"><a href="#2-Netty官方说明" class="headerlink" title="2. Netty官方说明"></a>2. Netty官方说明</h1><p><img src="https://img-blog.csdnimg.cn/direct/237e97df88124b25b1418dbca5c1761b.png" alt="在这里插入图片描述"></p>
<ol>
<li>Netty 是由JBOSS提供的一个Java开源框架，Netty提供异步的，基于事件驱动的网络应用程序框架，用以快速开发高性能，高可靠的网络IO程序。</li>
<li>Netty 可以帮助你快速、简单的开发出一个网络应用，相当于简化和流程化了 NIO 的开发过程。</li>
<li>Netty 是目前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，知名的 Elasticsearch 、Dubbo 框架内部都采用了 Netty。</li>
</ol>
<h1 id="3-Netty的优点"><a href="#3-Netty的优点" class="headerlink" title="3. Netty的优点"></a>3. Netty的优点</h1><ol>
<li>设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池.</li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
</ol>
<h1 id="4-线程模型基本介绍"><a href="#4-线程模型基本介绍" class="headerlink" title="4. 线程模型基本介绍"></a>4. 线程模型基本介绍</h1><ol>
<li>目前存在的线程模型：</li>
</ol>
<ul>
<li>传统阻塞IO服务模型</li>
<li>Reactor模式</li>
</ul>
<h1 id="5-Reactor模式"><a href="#5-Reactor模式" class="headerlink" title="5. Reactor模式"></a>5. Reactor模式</h1><h2 id="5-1-单Reactor单线程"><a href="#5-1-单Reactor单线程" class="headerlink" title="5.1 单Reactor单线程"></a>5.1 单Reactor单线程</h2><p><img src="https://img-blog.csdnimg.cn/direct/6310bfd5bea34cb7aa2c35d76ca2899c.png" alt="在这里插入图片描述"><br>前面的群聊实例就是这种方式：服务器端用一个线程通过多路复用搞定所有的 IO 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 NIO 案例就属于这种模型。	<br>方案优缺点分析：</p>
<ol>
<li>优点：模型简单，没有多线程，进程通信，资源竞争问题。全部在一个线程中完成。</li>
<li>缺点：性能问题，只有一个线程，无法完全发挥多核CPU的性能</li>
<li>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis在业务处理的时间复杂度 O(1) 的情况</li>
</ol>
<h2 id="5-2-单Reactor多线程"><a href="#5-2-单Reactor多线程" class="headerlink" title="5.2 单Reactor多线程"></a>5.2 单Reactor多线程</h2><p><img src="https://img-blog.csdnimg.cn/direct/d0df38f203dd478088f3eb30053b8502.png" alt="在这里插入图片描述"></p>
<p>说明：</p>
<ol>
<li>Reactor对象通过select 监控客户端请求时间，收到事件后，通过dispatch进行分发。</li>
<li>如果建立连接请求，则acceptor荣国accept处理请求，然后创建handler对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由reactor分发调用连接对应的handler处理。</li>
<li>handler只负责响应事件，不做具体的业务处理，通过read读取数据后，分发给后面的worker线程池的某个线程处理任务。</li>
<li>worker线程池会分配独立线程完成真正的业务，并将结果返回给handler.</li>
<li>handler收到响应后，通过send将结果返回client<br> 方案优缺点分析：</li>
<li>优点：可以充分利用多核cpu的处理能力</li>
<li>缺点：多线程数据共享和访问比较复杂，reactor处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li>
<li>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis在业务处理的时间复杂度 O(1) 的情况</li>
</ol>
<h2 id="5-3-主从Reactor多线程"><a href="#5-3-主从Reactor多线程" class="headerlink" title="5.3 主从Reactor多线程"></a>5.3 主从Reactor多线程</h2><p><img src="https://img-blog.csdnimg.cn/direct/2bd1fe809ea04276b7c7a869731b6ba6.png" alt="在这里插入图片描述"></p>
<p>说明：</p>
<ol>
<li>Reactor主线程MainReactor对象通过select监听连接事件，收到事件后，通过acceptor处理连接事件。</li>
<li>当acceptor处理连接事件后，MainReactor将连接分配给SubReactor.</li>
<li>subreactor将连接加入连接队列进行监听，并创建handler进行各种事件处理</li>
<li>当有新事件发生时，subreactor调用对应的handler进行处理</li>
<li>handler通过reade读取数据，分发给后面的worker线程池处理</li>
<li>worker线程池分配独立的线程进行业务处理，并返回结果</li>
<li>handler收到响应的结果后，再通过send将结果返回给client</li>
<li>reactor主线程可以对应多个reactor子线程，即MainReactor可以关联多个subreactor<br> 方案优缺点分析：</li>
<li>优点：父线程和子线程的数据交互简单职责明确，父线程只需要接受新连接，子线程完成后续的业务处理。</li>
<li>缺点：编程难度高。</li>
<li>使用场景：这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持</li>
</ol>
<h1 id="6-Reactor模式小结"><a href="#6-Reactor模式小结" class="headerlink" title="6. Reactor模式小结"></a>6. Reactor模式小结</h1><ol>
<li>单Reactor单线程，前台接待员和服务员是同一个人</li>
<li>单Reactor多线程，1个前台接待员，多个服务员。</li>
<li>主从Reactor多线程，多个前台接待员，多个服务员。<br> Reactor模式优点：</li>
<li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</li>
<li>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</li>
<li>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ol>
<h1 id="7-Netty模型"><a href="#7-Netty模型" class="headerlink" title="7. Netty模型"></a>7. Netty模型</h1><h2 id="7-1-Netty简单版"><a href="#7-1-Netty简单版" class="headerlink" title="7.1 Netty简单版"></a>7.1 Netty简单版</h2><p>Netty主要基于主从reactors多线程模型做了一定的改进，其中主从reactor多线程模型有多个reactor<br><img src="https://img-blog.csdnimg.cn/direct/62285359d91842e09074647489686b82.png" alt="在这里插入图片描述"><br>说明：</p>
<ol>
<li>BossGroup线程维护selector，他只关注accept</li>
<li>当接收到accept事件后，获取到对应的socketchannel,封装成NIOsocketChannel并注册到worker线程（事件循环），并进行维护</li>
<li>当worker线程监听到selector中通道发生自己感兴趣的事件后，就进行处理（hanlder）.注意handler已经加入到通道中。</li>
</ol>
<h2 id="7-2-Netty进阶版"><a href="#7-2-Netty进阶版" class="headerlink" title="7.2 Netty进阶版"></a>7.2 Netty进阶版</h2><p><img src="https://img-blog.csdnimg.cn/direct/8ed26c042902425693eabeed5abcb778.png" alt="在这里插入图片描述"></p>
<h2 id="7-2-Netty详细版"><a href="#7-2-Netty详细版" class="headerlink" title="7.2 Netty详细版"></a>7.2 Netty详细版</h2><p><img src="https://img-blog.csdnimg.cn/direct/54650aabe032417da26ab851a9d34033.png" alt="在这里插入图片描述">说明：</p>
<ol>
<li>Netty抽象出两组线程池BossGroup专门负责接受客户端的连接，workerGroup专门负责网络的读写</li>
<li>BossGroup和workerGroup类型都是NIOEventLoopGroup</li>
<li>NIOEventLoopGroup 相当于是一个事件循环组，这个组中包含多个事件循环，每一个事件循环都是NIOEventLoop.</li>
<li>NIOEventLoop表示一个不断循环的执行处理任务的线程，每个NIOEventLoop都有一个selector，用户监听绑定在其上的socket网络通讯。</li>
<li>NIOEventLoopGroup可以有多个线程，即可以含有多个NIOEventLoop</li>
<li>每个bossNIOEventLoop循环执行的步骤有三步</li>
</ol>
<ul>
<li>轮询accept事件</li>
<li>处理accept事件，与client建立连接，生成NIOsocketChannel并将其注册到某个wokerNIOEventLoop上的selector。</li>
<li>处理任务队列的任务，即runAllTasks</li>
</ul>
<ol start="7">
<li>每个workerNIOEventLOOP循环执行的步骤</li>
</ol>
<ul>
<li>轮询read，write事件</li>
<li>处理IO事件，即read,write事件，在对应NIOSocketChannel处理</li>
<li>处理任务队列的任务，即runAllTasks</li>
</ul>
<ol start="8">
<li>每个workerNIOEventLoop处理业务时，会使用pipeline（管道）pipeline中包含了channel，即通过pipeline可以获取到对应的管道，管道中维护了很多的处理器。</li>
</ol>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章Netty第三节handler&amp;pipeline&amp;ByteBuf</title>
    <url>/2022/12/22/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E4%B8%89%E8%8A%82handler&amp;pipeline&amp;ByteBuf/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="Handler-Pipeline"><a href="#Handler-Pipeline" class="headerlink" title="Handler &amp; Pipeline"></a>Handler &amp; Pipeline</h1><h2 id="Pipeline中执行顺序"><a href="#Pipeline中执行顺序" class="headerlink" title="Pipeline中执行顺序"></a>Pipeline中执行顺序</h2><p>ChannelHandler用来处理Channel上的各种事件，分为入站和出站。ChannelHandler被连成一串就是pipeline.</p>
<ul>
<li>入站处理器通常是ChannelInBoundHanderAdapter的子类，主要用来读取客户端的数据，写回结果</li>
<li>出站处理器通常是ChannelOutboundHandlerAdapter的子类，主要对写回结果进行加工。<br>打个比喻，channel是产品的加工车间。pipeline是车间中的流水线，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品。<br>服务端：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">3</span>);</span><br><span class="line">                    ctx.channel().write(msg); <span class="comment">// 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">4</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">5</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">6</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 6</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
客户单：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">        future.channel().writeAndFlush(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
结果打印：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表<br><img src="https://img-blog.csdnimg.cn/direct/5fb50836ab9446faa304ccb9e67b6889.png" alt="在这里插入图片描述"></li>
</ul>
<ol>
<li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong></li>
</ol>
<ul>
<li>如果注释掉 1 处代码，则仅会打印 1</li>
<li>如果注释掉 2 处代码，则仅会打印 1 2</li>
</ul>
<ol start="2">
<li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行</li>
</ol>
<ul>
<li>如果注释掉 3 处代码，则仅会打印 1 2 3</li>
</ul>
<ol start="3">
<li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong></li>
</ol>
<ul>
<li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li>
</ul>
<ol start="4">
<li>ctx.channel().write(msg) vs ctx.write(msg)</li>
</ol>
<ul>
<li>都是触发出站处理器的执行</li>
<li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li>
<li>ctx.write(msg) 是从当前节点找上一个出站处理器</li>
<li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器</li>
<li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己<br>下图为服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序<br><img src="https://img-blog.csdnimg.cn/direct/763d46a86fd342939f8aff11bde47d84.png" alt="在这里插入图片描述"></li>
</ul>
<h2 id="EmbededChannel调试"><a href="#EmbededChannel调试" class="headerlink" title="EmbededChannel调试"></a>EmbededChannel调试</h2><p>主要方法：</p>
<ul>
<li>channel.writeInbound</li>
<li>channel.writeOutbound<br>通过new EmbededChannel，调用上面方法，能够触发pipeline中的channel事件，handler执行。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">ChannelInboundHandlerAdapter</span> <span class="variable">ch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelInboundHandlerAdapter</span> <span class="variable">ch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelOutboundHandlerAdapter</span> <span class="variable">ch3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelOutboundHandlerAdapter</span> <span class="variable">ch4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(ch1, ch2, ch3, ch4);</span><br><span class="line"><span class="comment">//        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes()));// 让inbound事件触发</span></span><br><span class="line">        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;hello&quot;</span>.getBytes()));<span class="comment">// 让outbound事件触发</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:0 capacity:10</span><br></pre></td></tr></table></figure>
<p>创建默认的ByteBuf(池化基于直接内存)，初始容量为10（可扩充，对应一个最大容量）</p>
<h3 id="直接内存-vs-堆内存"><a href="#直接内存-vs-堆内存" class="headerlink" title="直接内存 vs 堆内存"></a>直接内存 vs 堆内存</h3><p>直接内存（默认）：将数据存放在操作系统的堆外内存中。直接内存的分配和释放不受JVM的垃圾回收控制，减少了GC开销。直接内存创建和销毁的代价高，但是读写性能好（零拷贝技术减少了内核态和用户态数据的复制），配合池化功能一起用。<br>堆内存：堆内存由JVM自动管理和回收。某些情况下可能导致GC的开销和延迟。<br>创建池化基于堆的buffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>创建池化基于直接内存的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h3 id="池化-vs-非池化"><a href="#池化-vs-非池化" class="headerlink" title="池化 vs 非池化"></a>池化 vs 非池化</h3><p>池化的最大意义在于减少创建buffer的时间和重用byteBuf。具体如下：</p>
<ul>
<li>没有池化，每次都得创建新的byteBuf实例，速度慢</li>
<li>有了池化，池中提前创建好byteBuf，用完了放回池子，可以重用。</li>
<li>高并发时，池化功能更节约内存，减少内存溢出的可能。</li>
</ul>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>ByteBuf由四部分组成<br> <img src="https://img-blog.csdnimg.cn/direct/26846cbdac5b466493c9a9e35e296af9.png" alt="在这里插入图片描述"><br> 两个指针，分别时读指针和写指针（注意：NIO中的bytebuffer读写指针共用的）</p>
<h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><p> 方法列表，省略一些不重要的方法</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td>用一字节 01|00 代表 true|false</td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeShort(int value)</td>
<td>写入 short 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian，即 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian，即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeLong(long value)</td>
<td>写入 long 值</td>
<td></td>
</tr>
<tr>
<td>writeChar(int value)</td>
<td>写入 char 值</td>
<td></td>
</tr>
<tr>
<td>writeFloat(float value)</td>
<td>写入 float 值</td>
<td></td>
</tr>
<tr>
<td>writeDouble(double value)</td>
<td>写入 double 值</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 netty 的 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 nio 的 ByteBuffer</td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td>写入字符串</td>
<td></td>
</tr>
<tr>
<td>大端方式写入（网络传输中习惯大端）：将第一个字节（从左到右）写入高位（大端）：符合人的正常思维，即 0x00 00 02 50，写入后 00 00 02 50</td>
<td></td>
<td></td>
</tr>
<tr>
<td>小端方式写入：将第一个字节（从左到右）写入低位（小端）：即 0x00 00 02 50，写入后 50 02 00 00</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>先写入 4 个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:4 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>再写入一个 int 整数，也是 4 个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">5</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:8 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">6</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>扩容规则是</p>
<ul>
<li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>
<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10&#x3D;1024（2^9&#x3D;512 已经不够了）</li>
<li>扩容不能超过 max capacity 会报错</li>
</ul>
<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>例如读了 4 次，每次一个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>如果需要重复读取 int 整数 5，怎么办？</p>
<p>可以在 read 前先做个标记 mark</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.markReaderIndex();</span><br><span class="line">System.out.println(buffer.readInt());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">read index:8 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 06                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时要重复读取的话，重置到标记位置 reset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.resetReaderIndex();</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>这时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p>
<h2 id="retain-release"><a href="#retain-release" class="headerlink" title="retain &amp; release"></a>retain &amp; release</h2><p>由于Nettty由堆外内存的byteBuf实现，堆外内存最好是手动来释放，而不是GC垃圾回收。</p>
<ul>
<li>UnpooledHeapByteBuf使用的是JVM内存，只需要等GC回收即可</li>
<li>UnpooledDirectByteBuf使用的是操作系统的堆外内存，需要特殊的方法来回收内存</li>
<li>PooledByteBuf和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<p>Netty这里使用了<strong>引用计数法</strong>来控制回收内存，每个ByteBuf都实现了ReferenceCounted接口</p>
<ul>
<li>每个ByteBuf对象的初始计数为1</li>
<li>调用release方法计数减1，如果计数为0， ByteBuf内存被回收。</li>
<li>调用retain方法计数加1，表示调用者没用完之前，其他handler即使调用了release也不会造成回收。</li>
<li>当计数为0时，底层内存会被回收。这时即使ByteBuf对象还在，当各个方法均无法正常使用。</li>
</ul>
<p>谁来负责release呢？<br>基本规则是，<strong>谁是最后使用者，谁负责release</strong></p>
<ol>
<li>入站ByteBuf处理原则</li>
</ol>
<ul>
<li>对原始ByteBuf不做处理，调用ctx.fireChannelRead(msg)向后传递，无需release</li>
<li>将原始ByteBuf转换为其他类型的Java对象，这时ByteBuf没用了，必须release</li>
<li>如果不调用ctx.fireChannelRead（msg）向后传递，那么也必须release</li>
<li>注意各种异常，如果ByteBuf没有成功传递到后一个ChannelHandler，必须release</li>
<li>假设消息一直往后传，那么TailContext会负责释放未处理消息（原始的ByteBuf）</li>
</ul>
<ol start="2">
<li>出站ByteBuf处理原则</li>
</ol>
<ul>
<li>出站消息最终会转为ByteBuf输出， 一直向前传，由headContext flush后release</li>
</ul>
<ol start="3">
<li>异常处理原则</li>
</ol>
<ul>
<li>有时候不清楚ByteBuf被引用了多少次，但又必须释放，可以循环调用release直接返回true</li>
</ul>
<p>TailContext 释放未处理消息逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ReferenceCounted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ReferenceCounted) msg).release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>「零拷贝」的体现之一。对原始的ByteBuf进行切片成多个ByteBuf,切片后的ByteBuf并没有发生内存复制，还是使用原来的内存，只是切片后的ByteBuf维护独立的read,write指针。<br>在这里插入图片描述<br><img src="https://img-blog.csdnimg.cn/direct/670831f56d434965bcce46f1ac75e8e6.png" alt="在这里插入图片描述"><br>例，原始 ByteBuf 进行一些初始操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">origin</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">origin.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">slice</span> <span class="operator">=</span> origin.slice();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class="line"><span class="comment">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 04                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时的 slice 不受影响，因为它有独立的读写指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>如果 slice 的内容发生了更改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slice.setByte(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 05                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 05                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<h2 id="duplicate"><a href="#duplicate" class="headerlink" title="duplicate"></a>duplicate</h2><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的<br><img src="https://img-blog.csdnimg.cn/direct/bf397080795948269cfe5313c7a5d837.png" alt="在这里插入图片描述"></p>
<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始ByteBuf无关。</p>
<h2 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h2><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝<br>有两个 ByteBuf 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p>
<p>方法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT</span><br><span class="line">    .buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class="line">buf3.writeBytes(buf1);</span><br><span class="line">buf3.writeBytes(buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这种方法好不好？回答是不太好，因为进行了数据的内存复制操作</p>
<p>方法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line"><span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">buf3.addComponents(<span class="literal">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure>

<p>结果是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p>
<ul>
<li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>
<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>
</ul>
<h2 id="ByteBuf优势"><a href="#ByteBuf优势" class="headerlink" title="ByteBuf优势"></a>ByteBuf优势</h2><ul>
<li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>
<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>
<li>可以自动扩容</li>
<li>支持链式调用，使用更流畅</li>
<li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li>
</ul>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-CAS</title>
    <url>/2024/01/24/JUC-CAS/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-CAS概述"><a href="#1-CAS概述" class="headerlink" title="1. CAS概述"></a>1. CAS概述</h1><p>CAS(Compare ans swap&#x2F;set) 比较并交换，实现并发的一种底层技术。它将预期的值和内存中的值比较，如果相同，就更新内存中的值。如果不匹配，一直重试（自旋）。Java.util.concurrent.atomic包下的原子类都使用了CAS算法</p>
<h1 id="2-CAS原理"><a href="#2-CAS原理" class="headerlink" title="2. CAS原理"></a>2. CAS原理</h1><p>CAS具体的操作是将预期的值和内存中真实的值进行比较，如果相同就更新值。如果不相同就重试（自旋）。<br>CAS是通过Unsafe的compareAndSwap方法实现的，底层实现是CPU原子指令cmpxchg，不会造成数据不一致的问题。<br>CAS依靠底层硬件实现的无锁原子算法。比synchronized重量级锁性能更好。</p>
<h1 id="3-CAS与自旋锁"><a href="#3-CAS与自旋锁" class="headerlink" title="3. CAS与自旋锁"></a>3. CAS与自旋锁</h1><h2 id="3-1-前置知识：原子引用类AtomicReference"><a href="#3-1-前置知识：原子引用类AtomicReference" class="headerlink" title="3.1 前置知识：原子引用类AtomicReference"></a>3.1 前置知识：原子引用类AtomicReference</h2><p>将自定义的类型变成原子类，能够进行cas操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">    AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="type">User</span> <span class="variable">z3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;z3&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">li4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;li4&quot;</span>,<span class="number">28</span>);</span><br><span class="line">    atomicReference.set(z3);</span><br><span class="line">    System.out.println(atomicReference.compareAndSet(z3, li4)+<span class="string">&quot;\t&quot;</span>+atomicReference.get().toString());</span><br><span class="line">    System.out.println(atomicReference.compareAndSet(z3, li4)+<span class="string">&quot;\t&quot;</span>+atomicReference.get().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-CAS实现一个自旋锁：A线程持有锁，B线程自旋等待直到A释放锁。"><a href="#3-2-CAS实现一个自旋锁：A线程持有锁，B线程自旋等待直到A释放锁。" class="headerlink" title="3.2 CAS实现一个自旋锁：A线程持有锁，B线程自旋等待直到A释放锁。"></a>3.2 CAS实现一个自旋锁：A线程持有锁，B线程自旋等待直到A释放锁。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：实现一个自旋锁,复习CAS思想</span></span><br><span class="line"><span class="comment"> * 自旋锁好处：循环比较获取没有类似wait的阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现</span></span><br><span class="line"><span class="comment"> * 当前有线程持有锁，所以只能通过自旋等待，直到A释放锁后B随后抢到。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----come in 等待锁&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 拿到锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----task over,释放锁...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SpinLockDemo</span> <span class="variable">spinLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLockDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.lock();</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            spinLockDemo.unLock();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停500毫秒,线程A先于B启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.lock();</span><br><span class="line"></span><br><span class="line">            spinLockDemo.unLock();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心思想：</strong></p>
<ul>
<li>加锁：开始的时候，内存中的值为NULL，一旦有线程进入，预期值为NULL,和真实值匹配将内存设置为当前线程值。(此时其他线程进来后预期值NULL，但是真实值已经被修改所以会自旋，这为加锁)</li>
<li>解锁： 释放锁之后，重新设置内存的值为NULL，让其他线程能够进入从而修改</li>
</ul>
<p><strong>运行结果：</strong><br><img src="https://img-blog.csdnimg.cn/direct/b737fcfa4df640c2b978134c70f8ac82.png" alt="在这里插入图片描述"></p>
<h1 id="CAS和synchronized比较"><a href="#CAS和synchronized比较" class="headerlink" title="CAS和synchronized比较"></a>CAS和synchronized比较</h1><p>CAS线程不会阻塞，线程一直自旋。<br>Synchronized会阻塞，会进行线程的上下文切换非常耗费资源。</p>
<h1 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h1><h2 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h2><p>CAS如果预测值和真实值不一样，将一直自旋。导致循环CPU开销大。</p>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题顾名思义就是将线程1在进行CAS操作的时候，另一个线程2已经将A修改为B又快速修改回A，导致一个线程并未发现中间修改过仍能正常进行CAS比较和修改。</p>
<h2 id="ABA问题解决方案"><a href="#ABA问题解决方案" class="headerlink" title="ABA问题解决方案"></a>ABA问题解决方案</h2><p>原子时间戳引用：给每次修改都加上一个时间戳(版本号)，CAS操作的时候不仅要比较预测值和真实值，还要比较预测版本号和真实版本号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>().compareAndSet(V   expectedReference,</span><br><span class="line">                                 V   newReference,</span><br><span class="line">                                 <span class="type">int</span> expectedStamp,</span><br><span class="line">                                 <span class="type">int</span> newStamp)</span><br></pre></td></tr></table></figure>
<h1 id="CAS注意事项"><a href="#CAS注意事项" class="headerlink" title="CAS注意事项"></a>CAS注意事项</h1><p>CAS只能保证原子性，不能保证变量的可见性。要配合volatile使用，保证共享变量的可见性。<br>CAS适用于并发量不高，多核CPU的情况。并发量增高，CAS自旋会导致消耗CPU资源。这时候用LongAdder</p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章Netty第四节案例实现echo server</title>
    <url>/2022/12/23/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E5%9B%9B%E8%8A%82%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0echoserver/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>实现一个echo server。通俗的说就是客户端发送什么就会接受到什么。echo的意思“回声”。</p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">               .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">               .channel(NioServerSocketChannel.class)</span><br><span class="line">               .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                       ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                               <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                               System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                               <span class="comment">// 建议使用 ctx.alloc() 创建 ByteBuf</span></span><br><span class="line">                               <span class="type">ByteBuf</span> <span class="variable">response</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                               response.writeBytes(buffer);</span><br><span class="line">                               ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">                               <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                               buffer.release();<span class="comment">// 没有向后传递了，所以应该释放？</span></span><br><span class="line">                               <span class="comment">// 思考：需要释放 response 吗</span></span><br><span class="line">                               response.release();<span class="comment">// 没有向后传递了，所以应该释放？</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).bind(<span class="number">8090</span>);</span><br></pre></td></tr></table></figure>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">       <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">               .group(group)</span><br><span class="line">               .channel(NioSocketChannel.class)</span><br><span class="line">               .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                       ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                       ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                               <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                               System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                               <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                               buffer.release();<span class="comment">//可以释放。不释放，tail会释放。能自己释放还是自己释放。</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8090</span>).sync().channel();</span><br><span class="line">       channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">           group.shutdownGracefully();</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">               <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">                   channel.close();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               channel.writeAndFlush(line);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br></pre></td></tr></table></figure>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>客户端打印输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hey</span><br><span class="line">hey</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章Netty第二节入门案例+channel,future,promise介绍</title>
    <url>/2022/12/21/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B+%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>开发一个简单的服务器端和客户端</p>
<ul>
<li>客户端向服务器端发送 hello, world</li>
<li>服务器仅接收，不返回<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.1</span><span class="number">.39</span>.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()); <span class="comment">// 5</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; <span class="comment">// 6</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>代码解读：</p>
<ol>
<li>1处创建NIOEventLoopGroup,可以简单理解为线程池+selector</li>
<li>2处选择服务socket实现类，其中NIOServerSocketChannel表示基于NIO的服务端实现。其他还有<br> <img src="https://img-blog.csdnimg.cn/direct/6ff3e7c3f5a345daa65b5247055416dd.png" alt="在这里插入图片描述"></li>
<li>3处，为啥方法骄傲childHandler，是接下来处理器都是给socketChannel用的，而不是给ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端socketChannel建立连接后，执行initChannel以便添加更多的处理器。</li>
<li>4 处，ServerSocketChannel 绑定的监听端口</li>
<li>5处，socketChannel的处理器，解码ByteBuf&#x3D;&gt;String</li>
<li>6处，socketChannel的业务处理器，使用上一个处理器的处理结果</li>
</ol>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">// 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>) <span class="comment">// 4</span></span><br><span class="line">    .sync() <span class="comment">// 5</span></span><br><span class="line">    .channel() <span class="comment">// 6</span></span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>); <span class="comment">// 7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码解读：<br>1.1处，创建NIOEventLoopGroup,同server<br>2. 2处， 选择客户的socket实现类，NIOSocketChannel表示基于NIO的客户端实现类。其他实现还有<br>    <img src="https://img-blog.csdnimg.cn/direct/0b6c72fccf8f450183a66563d5c1a12b.png" alt="在这里插入图片描述"></p>
<ol start="3">
<li>3处，添加socketChannel的处理器，ChannelInitializer处理器（仅执行一次），它的作用是待客户端socketChannel建立连接后，执行initChannel以便添加跟多的处理器。</li>
<li>4 处，指定要连接的服务器和端口</li>
<li>5处，Netty中很多方法都是异步的，如connect，这时需要使用sync方法等待connect建立连接完毕。</li>
<li>6处，获取channel对象，它即为通道抽象，可以进行数据读写。</li>
<li>7处，写入消息并清空缓冲区</li>
<li>8处，建立连接后，消息会经过通道handler处理，这里是将string&#x3D;&gt;ByteBuf发出。</li>
<li>数据经过网络传输，到达服务端，服务端5和6处的handlerx先后被触发走完一个流程。</li>
</ol>
<h1 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h1><p><img src="https://img-blog.csdnimg.cn/direct/6d5c3a5fef8648b49375212543b7f063.png" alt="在这里插入图片描述"><br>注意：</p>
<ul>
<li>把channel理解为数据的通道</li>
<li>把msg理解为流动的数据，最开始输入的是ByteBuf,但经过pipeLine的加工，会变成其他类型的对象，最后输出又变成ByteBuf</li>
<li>把handler理解为数据的处理工序<ul>
<li>工序有多道，合在一起就是pipeline.pipeline负责发布事件（读，读取完成。。。）传播给每个handler,handler对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>
<li>handler分Inbound和outbound两类</li>
</ul>
</li>
<li>把eventloop理解为处理数据的工人<ul>
<li>工人可以管理多个channel的io操作。并且一旦工人负责了某个channel就要负责到底（绑定）</li>
<li>工人既可以执行io操作，也可以进行任务处理。每位工人有任务队列，队列里可以堆放多个channel待处理的任务，把任务分为普通任务和定时任务。</li>
<li>工人按照pipeline顺序，依次按照handler的规划（代码）处理数据，可以为每一道工序执行不同的工人。</li>
</ul>
</li>
</ul>
<h1 id="组件-EventLoop"><a href="#组件-EventLoop" class="headerlink" title="组件-EventLoop"></a>组件-EventLoop</h1><h2 id="事件循环对象-EventLoop"><a href="#事件循环对象-EventLoop" class="headerlink" title="事件循环对象 EventLoop"></a>事件循环对象 EventLoop</h2><p>本质上是一个单线程执行器同时维护了一个selector，里面有run方法处理channel上源源不断的io事件。<br>继承关系：</p>
<ul>
<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自 netty 自己的 OrderedEventExecutor<ul>
<li>提供了boolean inEventLoop（Thread thread）方法判断一个线程是否属于此EventLoop</li>
<li>提供了parent方法来看看自己属于哪个EventLoopGroup</li>
</ul>
</li>
</ul>
<h2 id="事件循环组-EventLoopGroup"><a href="#事件循环组-EventLoopGroup" class="headerlink" title="事件循环组 EventLoopGroup"></a>事件循环组 EventLoopGroup</h2><p>是一组EventLoop,channel一般会调用EventLoopGroup的register方法来绑定一个EventLoop，后续这个channel上的io事件都由此EventLoop来处理（保证了io事件处理时的线程安全）<br>继承自 netty 自己的 EventExecutorGroup</p>
<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop<br>以一个简单的实现为例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span></span><br><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br></pre></td></tr></table></figure>
输出<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br></pre></td></tr></table></figure>
也可以使用 for 循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (EventExecutor eventLoop : group) &#123;</span><br><span class="line">    System.out.println(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br></pre></td></tr></table></figure>
<h2 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h2><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>
<h2 id="演示NioEventLoop处理io事件"><a href="#演示NioEventLoop处理io事件" class="headerlink" title="演示NioEventLoop处理io事件"></a>演示NioEventLoop处理io事件</h2><p>服务端两个Nio worker工人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></table></figure>
<p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">            .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>))</span><br><span class="line">            .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .channel(NioSocketChannel.class).connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">            .sync()</span><br><span class="line">            .channel();</span><br><span class="line"></span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;wangwu&quot;</span>.getBytes()));</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;wangwu&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure>

<p>最后输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        </span><br><span class="line">22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         </span><br></pre></td></tr></table></figure>

<p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定<br><img src="https://img-blog.csdnimg.cn/direct/b3f1397a312d4b67832c876e92fc29b8.png" alt="在这里插入图片描述"><br>再增加两个非 nio 工人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">normalWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span>  &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">            ch.pipeline().addLast(normalWorkers,<span class="string">&quot;myhandler&quot;</span>,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></table></figure>

<p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED</span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br></pre></td></tr></table></figure>

<p>可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</p>
<p><img src="https://img-blog.csdnimg.cn/direct/e042e537e8964fd98f021ab003cebbf9.png" alt="在这里插入图片描述"></p>
<h2 id="handler-执行中如何换人？"><a href="#handler-执行中如何换人？" class="headerlink" title="handler 执行中如何换人？"></a>handler 执行中如何换人？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是，直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRead(m);<span class="comment">// 用新的线程去执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/direct/20bcc43f138e4fe898ad8f49be748977.png" alt="在这里插入图片描述"></p>
<ul>
<li>如果两个handler绑定的是同一个线程，那么在当前线程中直接调用</li>
<li>否则，提交给一个新的线程调用。</li>
</ul>
<h2 id="演示-NioEventLoop-处理普通任务"><a href="#演示-NioEventLoop-处理普通任务" class="headerlink" title="演示 NioEventLoop 处理普通任务"></a>演示 NioEventLoop 处理普通任务</h2><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1. 创建事件循环组</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>); <span class="comment">// io 事件，普通任务，定时任务</span></span><br><span class="line">         <span class="comment">// 3. 执行普通任务。submit和execute都可以。将这个任务加到事件循环组中的一个线程去执行不会造成阻塞。实现了异步</span></span><br><span class="line">group.next().submit(() -&gt; &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">log.debug(<span class="string">&quot;main&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19:52:29 [DEBUG] [main] c.i.n.c.TestEventLoop - main</span><br><span class="line">19:52:30 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestEventLoop - ok</span><br></pre></td></tr></table></figure>
<p>可以用来执行耗时较长的任务，不会被阻塞。</p>
<h2 id="演示-NioEventLoop-处理定时任务"><a href="#演示-NioEventLoop-处理定时任务" class="headerlink" title="演示 NioEventLoop 处理定时任务"></a>演示 NioEventLoop 处理定时任务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建事件循环组</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>); <span class="comment">// io 事件，普通任务，定时任务</span></span><br><span class="line"><span class="comment">// 4. 执行定时任务</span></span><br><span class="line">group.next().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;main&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19:53:32 [DEBUG] [main] c.i.n.c.TestEventLoop - main</span><br><span class="line">19:53:32 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestEventLoop - ok</span><br><span class="line">19:53:33 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestEventLoop - ok</span><br><span class="line">19:53:34 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestEventLoop - ok</span><br></pre></td></tr></table></figure>
<p>可以用来执行定时任务。</p>
<h1 id="组件-Channel"><a href="#组件-Channel" class="headerlink" title="组件-Channel"></a>组件-Channel</h1><h2 id="channel的主要方法"><a href="#channel的主要方法" class="headerlink" title="channel的主要方法"></a>channel的主要方法</h2><ul>
<li>close() 可以用来关闭 channel</li>
<li>closeFuture() 用来处理 channel 的关闭<ul>
<li>sync 方法作用是同步等待 channel 关闭</li>
<li>而 addListener 方法是异步等待 channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法添加处理器</li>
<li>write() 方法将数据写入到缓冲区中，但没有将数据发出。</li>
<li>writeAndFlush() 方法将数据写入缓存去，并立刻将缓冲区数据刷出。会立即将数据发出。</li>
</ul>
<h2 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 异步非阻塞的。异步：main线程发起调用，真正执行连接是另一个线程-Nio线程。如果没有sync，是无阻塞的，会直接向下执行。连接都还没建立好，信息不知道发送到哪里去。</span></span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">channelFuture.sync().channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>说明：<br>1处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象<br>注意：connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象。加了sync才能变成同步，一直阻塞直到建立连接。然后执行后面的才能正确发送数据。<br>实验如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.sync(); <span class="comment">// 2 会阻塞直到返回结果</span></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li>
<li>执行到 2 时，sync 方法是同步等待连接建立完成</li>
<li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code><br>除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    System.out.println(future.channel()); <span class="comment">// 2 连接建立好了会调用该方法</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 或者用下面的方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 使用 addListener(回调对象) 方法异步处理结果</span></span><br><span class="line"><span class="comment">channelFuture.addListener(new ChannelFutureListener() &#123;</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    // 在 nio 线程连接建立好之后，会调用 operationComplete</span></span><br><span class="line"><span class="comment">    public void operationComplete(ChannelFuture future) throws Exception &#123;</span></span><br><span class="line"><span class="comment">        Channel channel = future.channel();</span></span><br><span class="line"><span class="comment">        log.debug(&quot;&#123;&#125;&quot;, channel);</span></span><br><span class="line"><span class="comment">        channel.writeAndFlush(&quot;hello, world&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
核心：channelFuture.addListener（）。注意带有future,promise的类型都可以和addListener方法配套使用的。<br>说明：这种方法不同于上面的同步的方法，同步的方法是有main线程完成打印的操作。而这里main线程直接将任务交给其他线程以异步的方式执行，当连接建立完成后自动完成打印操作。</li>
</ul>
<h2 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h2><p>用法基本同上面的channelFuture。closeFuture是用来处理关闭之后的操作的，一般用来关闭EventLoopGroup。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        NioEventLoopGroup group <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">                    channel.close(); <span class="comment">// close 异步操作 1s 之后</span></span><br><span class="line"><span class="comment">//                    log.debug(&quot;处理关闭之后的操作&quot;); // 不能在这里善后</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;input&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        <span class="comment">// 1.同步关闭的方法</span></span><br><span class="line">        <span class="comment">/*log.debug(&quot;waiting close...&quot;);</span></span><br><span class="line"><span class="comment">        closeFuture.sync();</span></span><br><span class="line"><span class="comment">        log.debug(&quot;处理关闭之后的操作&quot;);*/</span></span><br><span class="line">        <span class="comment">// 2.异步处理的方法</span></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="组件-Future-Promise"><a href="#组件-Future-Promise" class="headerlink" title="组件-Future&amp;Promise"></a>组件-Future&amp;Promise</h1><p>在异步处理的时候，经常用到这两个接口。</p>
<p>netty中的Future和JDK中的Future同名。Netty的Future是继承自JDK的Future。Promise是对Netty中的Future进行拓展（Extend）。</p>
<ul>
<li>JDK中的Future只能同步等待任务结束（或成功或失败）才能得到结果。</li>
<li>netty Future可以同步等待任务结束得到结果，也可以异步（addListener）得到结果。但都要等任务结束</li>
<li>netty Promise不仅有netty Future的功能，而且可以「主动创建」一个Promise,作为两个线程间传递结果的容器。</li>
</ul>
<table>
<thead>
<tr>
<th>功能&#x2F;名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，阻塞等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回null</td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody></table>
<h2 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h2><p>只能通过同步等待任务结束，future.get()会阻塞，直到拿到结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 线程池</span></span><br><span class="line">      <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">      <span class="comment">// 2. 提交任务</span></span><br><span class="line">      Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">              log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">              Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 3. 主线程通过 future 来获取结果</span></span><br><span class="line">      log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">      log.debug(<span class="string">&quot;结果是 &#123;&#125;&quot;</span>, future.get());</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:29:50 [DEBUG] [pool-1-thread-1] c.i.n.c.TestJdkFuture - 执行计算</span><br><span class="line">22:29:50 [DEBUG] [main] c.i.n.c.TestJdkFuture - 等待结果</span><br><span class="line">22:29:51 [DEBUG] [main] c.i.n.c.TestJdkFuture - 结果是 50</span><br></pre></td></tr></table></figure>
<h2 id="netty-Future"><a href="#netty-Future" class="headerlink" title="netty Future"></a>netty Future</h2><p>可以通过同步(get方法会阻塞)也可以通过异步（addListener不会阻塞，交给另外的线程处理）获得结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> group.next();</span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        log.debug(&quot;等待结果&quot;);</span></span><br><span class="line"><span class="comment">//        log.debug(&quot;结果是 &#123;&#125;&quot;, future.get()); // 1. 同步的方式</span></span><br><span class="line">        <span class="comment">//2. 异步的方式</span></span><br><span class="line">        future.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Integer&gt;&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;接收结果:&#123;&#125;&quot;</span>, future.getNow());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>上面异步的方式输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:34:24 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestNettyFuture - 执行计算</span><br><span class="line">22:34:25 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestNettyFuture - 接收结果:70</span><br></pre></td></tr></table></figure>
<h2 id="netty-Promise-常用的"><a href="#netty-Promise-常用的" class="headerlink" title="netty Promise(常用的)"></a>netty Promise(常用的)</h2><p>Promise 继承自（extend）netty的Future。不仅有Future的功能，而且能主动创建，作为线程 间存放数据的容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 准备 EventLoop 对象</span></span><br><span class="line">       <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>().next();</span><br><span class="line">       <span class="comment">// 2. 可以主动创建 promise, 结果容器</span></span><br><span class="line">       DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="comment">// 3. 任意一个线程执行计算，计算完毕后向 promise 填充结果</span></span><br><span class="line">           log.debug(<span class="string">&quot;开始计算...&quot;</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               promise.setSuccess(<span class="number">80</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               promise.setFailure(e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;).start();</span><br><span class="line">       <span class="comment">// 4. 接收结果的线程</span></span><br><span class="line">       log.debug(<span class="string">&quot;等待结果...&quot;</span>);</span><br><span class="line">       log.debug(<span class="string">&quot;结果是: &#123;&#125;&quot;</span>, promise.get());</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:37:03 [DEBUG] [main] c.i.n.c.TestNettyPromise - 等待结果...</span><br><span class="line">22:37:03 [DEBUG] [Thread-0] c.i.n.c.TestNettyPromise - 开始计算...</span><br><span class="line">22:37:04 [DEBUG] [main] c.i.n.c.TestNettyPromise - 结果是: 80</span><br></pre></td></tr></table></figure>
<p>后续netty一般都用Promise</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-JMM与volatile</title>
    <url>/2024/01/23/JUC-JMM%E4%B8%8Evolatile/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="volatile简介及作用"><a href="#volatile简介及作用" class="headerlink" title="volatile简介及作用"></a>volatile简介及作用</h1><p>volatile是JVM提供的轻量级的同步机制。volatile关键字能够保证并发编程的三大特性中的可见性，有序性。但是不能保证原子性。<br>保证可见性：<br>经过volatile修饰的变量，在本地内存中修改之后，会立即刷回主内存中。当主内存中的共享变量修改之后，其他线程的本地内存会立即同步获取到这个最新的值。<br>保证有序性：<br>通过禁止指令重排优化来保证有序性。禁止指令重排优化是通过内存屏障来实现的。</p>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>内存屏障就是CPU或者编译器对内存随机访问的一个同步点，使得对该点之前的操作在该点之后的操作之前。避免代码重排序。<br>内存屏障粗分类：</p>
<ul>
<li>读屏障：在读操作之前插入读屏障，让工作内存中的缓存失效，进而从主存中获取最新的数据。</li>
<li>写屏障：在写操作之后插入写屏障，让工作内存中的缓存立即写入到主内存中去。</li>
</ul>
<p>内存屏障细分类：<br>LoadLoad: 保证load1在load2之前执行。<br>StoreStore:保证store1保存在store2保存之前。<br>LoadStore:保证load1读取数据在store1写入数据之前。<br>StoreLoad:保证store保存数据在load读取数据之前。<br><img src="https://img-blog.csdnimg.cn/direct/c30c00405bba415f94aff52fc85a602a.png" alt="在这里插入图片描述"></p>
<h2 id="JMM针对编译器制定的volatile重排序的规则表："><a href="#JMM针对编译器制定的volatile重排序的规则表：" class="headerlink" title="JMM针对编译器制定的volatile重排序的规则表："></a>JMM针对编译器制定的volatile重排序的规则表：</h2><p><img src="https://img-blog.csdnimg.cn/direct/cd3e1b8af0a84ba2a7144cced49973fb.png" alt="在这里插入图片描述"></p>
<ul>
<li>当第一个操作为volatile读时，无论第二个操作是什么，都不能重排序。</li>
<li>当第二个操作为volatile写时，无论第一个操作是什么，都不能重排。</li>
<li>当第一个操作是volatile写时，第二个操作是读时，不能重排。</li>
</ul>
<h2 id="JMM在指令序列中插入屏障来禁止指令重排"><a href="#JMM在指令序列中插入屏障来禁止指令重排" class="headerlink" title="JMM在指令序列中插入屏障来禁止指令重排"></a>JMM在指令序列中插入屏障来禁止指令重排</h2><ul>
<li>在volatile写操作的前面加StoreStore屏障</li>
<li>在volatile写操作的后面加StoreLoad屏障</li>
<li>在volatile读操作的后面加LoadLoad屏障</li>
<li>在volatile读操作的后面加LoadStore屏障</li>
</ul>
<h1 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h1><p>单一赋值可以，复合赋值是禁止的。一般用来保存某个状态，判断业务是否结束。比如boolean值的flag。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="volatile可见性"><a href="#volatile可见性" class="headerlink" title="volatile可见性"></a>volatile可见性</h2><p>volaile修饰的变量具有可见性。<br>对于写操作，本地内存中修改后，会立即刷回主存中。<br>对于读操作，本地内存会从主存中获取最新的值。</p>
<h2 id="volatile有序性（禁止指令重排）"><a href="#volatile有序性（禁止指令重排）" class="headerlink" title="volatile有序性（禁止指令重排）"></a>volatile有序性（禁止指令重排）</h2><p>JMM在指令序列中通过插入内存屏障来禁止指令重排，保证有序性。<br>对于volatile写操作：在volatile写操作之前插入StoreStore指令，在volatile写操作之后插入StoreLoad指令来保证指令的有序。<br>对于volatile写操作：在volatile读操作之后插入LoadLoad指令和LoadStore指令，保证指令的有序。<br>参考：<br>1.《Java并发编程的艺术》<br>2.  <a href="https://blog.csdn.net/qq_44300280/article/details/127476199">JMM与volatile</a></p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-CompletableFuture</title>
    <url>/2024/01/13/JUC-CompletableFuture/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="Future接口理论"><a href="#Future接口理论" class="headerlink" title="Future接口理论"></a>Future接口理论</h1><p>Future接口定义了异步任务执行的一些方法，包括异步任务执行结果，异步任务执行是否中断，异步任务是否完毕等。</p>
<h2 id="Future接口常用实现类FutureTask异步任务"><a href="#Future接口常用实现类FutureTask异步任务" class="headerlink" title="Future接口常用实现类FutureTask异步任务"></a>Future接口常用实现类FutureTask异步任务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;( () -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t -----come in&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;task over&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>
<h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><h2 id="CompletableFuture对Future的改进"><a href="#CompletableFuture对Future的改进" class="headerlink" title="CompletableFuture对Future的改进"></a>CompletableFuture对Future的改进</h2><ul>
<li>CompletableFuture异步线程发生异常，不会影响到主线程，用来记录日志特别方便。</li>
<li>CompletableFuture出现的原因：Future的get方法是阻塞方法，当异步线程计算完成之前一直会阻塞，isDone()方法判断异步线程又特别消耗CPU资源。对于真正的异步处理我们希望传入回调函数，在Future结束时，自动调用该回调函数。这样我们就不用等待结果 。</li>
<li>CompletableFuture提供了一种观察者模式，可以让任务完成后通知监听的一方。<br><img src="https://img-blog.csdnimg.cn/direct/46ae4ec682574e16854c838b65e71c66.png" alt="在这里插入图片描述"></li>
</ul>
<h2 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h2><ul>
<li>CompltionStage是异步执行的一个阶段。一个阶段执行完成之后可能触发另一个阶段。</li>
<li>一个阶段的执行可以是一个Function,Comsumer或者Runnable。比如<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stage.thenApply(x -&gt; square(x)).thenAccept(×-&gt;System.out.print(x)).thenRun(( -&gt;system.out.println())</span><br></pre></td></tr></table></figure></li>
<li>一个阶段可能会是另一个阶段完成后触发。也可能是其他多个阶段完成后触发。</li>
</ul>
<h2 id="CompletableFuture的方法"><a href="#CompletableFuture的方法" class="headerlink" title="CompletableFuture的方法"></a>CompletableFuture的方法</h2><p><img src="https://img-blog.csdnimg.cn/direct/1100bbdf3750483b81b7d5428cef5674.png" alt="在这里插入图片描述"><br>主要是runAsync和supplyAsnc方法。一个无返回值。一个有返回值。</p>
<h2 id="CompletableFuture的优点"><a href="#CompletableFuture的优点" class="headerlink" title="CompletableFuture的优点"></a>CompletableFuture的优点</h2><ul>
<li>异步任务执行完成后，会自动调用某个对象的方法</li>
<li>异步任务出异常后，会自动调用某个对象的方法</li>
<li>主线程设置好回调后，不用关心异步任务的执行。异步任务之间可以顺序执行。</li>
</ul>
<h2 id="案例-前言"><a href="#案例-前言" class="headerlink" title="案例 - 前言"></a>案例 - 前言</h2><p>join和get的区别。get必须处理异常。join不需要处理异常<br>jdk8新特性： lambda表达式，stream流，chain链式调用，函数式编程<br><img src="https://img-blog.csdnimg.cn/direct/a6fefc53a2d64744936879b48974201f.png" alt="在这里插入图片描述"><br>有参数，有返回值：Function<br>有参数，无返回值：Consume, BiConsumer（两个参数）<br>无参数，有返回值：Supplier<br>无参数，无返回值：Runnable</p>
<h2 id="案例-从电商网站的比价需求"><a href="#案例-从电商网站的比价需求" class="headerlink" title="案例-从电商网站的比价需求"></a>案例-从电商网站的比价需求</h2><p>原来的写法，<strong>串行的方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * step by step 一家家搜查</span></span><br><span class="line"><span class="comment"> * List&lt;NetMall&gt; -----&gt;map------&gt; List&lt;String&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPrice</span><span class="params">(List&lt;NetMall&gt; list,String productName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//《mysql》 in taobao price is 90.43</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">            .stream()</span><br><span class="line">            .map(netMall -&gt;</span><br><span class="line">                    String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">                            netMall.getNetMallName(),</span><br><span class="line">                            netMall.calcPrice(productName)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用CompletableFuture，<strong>异步的方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * List&lt;NetMall&gt; -----&gt;List&lt;CompletableFuture&lt;String&gt;&gt;------&gt; List&lt;String&gt;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> productName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByCompletableFuture</span><span class="params">(List&lt;NetMall&gt; list,String productName)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> list.stream().map(netMall -&gt;</span><br><span class="line">               CompletableFuture.supplyAsync(() -&gt; String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">               netMall.getNetMallName(),</span><br><span class="line">               netMall.calcPrice(productName))))</span><br><span class="line">               .collect(Collectors.toList())</span><br><span class="line">               .stream()</span><br><span class="line">               .map(s -&gt; s.join())</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>耗时：比串行的方式快得多！！！</p>
<h1 id="CompletableFuture-常用方法"><a href="#CompletableFuture-常用方法" class="headerlink" title="CompletableFuture 常用方法"></a>CompletableFuture 常用方法</h1><h2 id="获得结果和触发计算"><a href="#获得结果和触发计算" class="headerlink" title="获得结果和触发计算"></a>获得结果和触发计算</h2><p>获得结果：</p>
<ul>
<li>public T get() 一直等</li>
<li>public T get(long timeout,TimeUnit unit) 过时不候，到了时间没拿到结果会报异常</li>
<li>public T join()：join和get都是用来获取CompletableFuture异步之后的返回值。join是unchecked异常（即运行时异常）。get是checked异常（经过检查的异常）</li>
<li>public T getNow(T valuelfAbsent)：没有计算完，给我默认的结果。计算完，返回实际的结果。</li>
</ul>
<p>主动触发计算：</p>
<ul>
<li>public boolean complete(T value) 如果CompletableFuture没有完成，将get结果修改为value，返回值为true。如果完成了，不修改get，返回值为false.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;</span><br><span class="line">      CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;hello CompletableFuture&quot;</span>;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      System.out.println(completableFuture.getNow(<span class="string">&quot;心急吃不了热豆腐&quot;</span>));</span><br><span class="line">      System.out.println(completableFuture.get());</span><br><span class="line">      System.out.println(completableFuture.get(<span class="number">1500</span>, TimeUnit.MILLISECONDS));</span><br><span class="line">      System.out.println(completableFuture.join());</span><br><span class="line">      System.out.println(completableFuture.complete(<span class="string">&quot;未雨绸缪&quot;</span>)+<span class="string">&quot;\t&quot;</span>+completableFuture.join());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对计算结果进行处理"><a href="#对计算结果进行处理" class="headerlink" title="对计算结果进行处理"></a>对计算结果进行处理</h2><h3 id="thenApply（常用）"><a href="#thenApply（常用）" class="headerlink" title="thenApply（常用）"></a>thenApply（常用）</h3><p>两个计算结果存在依赖关系，这两个线程串行化。<br>出现异常，直接跳到whenComplete和exceptionally执行。（不再执行后续的thenApply）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        &#125;,executorService).thenApply((r)-&gt; &#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">2</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> r * <span class="number">5</span>;</span><br><span class="line">        &#125;).thenApply((r)-&gt; &#123;</span><br><span class="line">            System.out.println(r);</span><br><span class="line">            <span class="keyword">return</span> r - <span class="number">2</span>;</span><br><span class="line">        &#125;).whenComplete((v, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span>+v);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;============主线程==========&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h3><p>计算机结果存在依赖关系，两个线程串行化<br>handle出现异常，会往下一个handle走，同时也会走到whenComplete和exceptionally</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        &#125;,executorService).handle((r,e)-&gt; &#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">2</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> r * <span class="number">5</span>;</span><br><span class="line">        &#125;).handle((r,e)-&gt; &#123;</span><br><span class="line">            System.out.println(r);</span><br><span class="line">            <span class="keyword">return</span> r - <span class="number">2</span>;</span><br><span class="line">        &#125;).whenComplete((v, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span>+v);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;============主线程==========&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>exceptionally相当于try catch<br>whenComplete和handler相当于try finally<br><img src="https://img-blog.csdnimg.cn/direct/09bd133ab668407b805812264ec33c09.png" alt="在这里插入图片描述"></p>
<h2 id="对计算结果进行消费"><a href="#对计算结果进行消费" class="headerlink" title="对计算结果进行消费"></a>对计算结果进行消费</h2><p>接受任务的处理结果，消费处理。thenAccept无返回结果。（thenApply是有返回结果的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;).thenApply(r-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> r*<span class="number">8</span>;</span><br><span class="line">        &#125;).thenApply(r-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> r/<span class="number">2</span>;</span><br><span class="line">        &#125;).thenAccept(r-&gt; System.out.println(r));</span><br><span class="line">        System.out.println(CompletableFuture.supplyAsync(()-&gt;<span class="string">&quot;6666&quot;</span>).thenRun(()-&gt;&#123;&#125;).join());</span><br><span class="line">        System.out.println(CompletableFuture.supplyAsync(()-&gt;<span class="string">&quot;6666&quot;</span>).thenAccept(r-&gt; System.out.println(r)).join());</span><br><span class="line">        System.out.println(CompletableFuture.supplyAsync(()-&gt;<span class="string">&quot;6666&quot;</span>).thenApply(r-&gt;r+<span class="string">&quot;9999&quot;</span>).join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">null</span><br><span class="line">6666</span><br><span class="line">null</span><br><span class="line">66669999</span><br></pre></td></tr></table></figure>
<h2 id="对计算速度进行选用与对计算结果进行合并"><a href="#对计算速度进行选用与对计算结果进行合并" class="headerlink" title="对计算速度进行选用与对计算结果进行合并"></a>对计算速度进行选用与对计算结果进行合并</h2><p>applyToEither：谁快用谁<br>thenCombine: 两个completionStage任务都完成后，将结果交给thenCombine。先完成的先等着，等待其他分支任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1号选手&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2号选手&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; result = first.applyToEither(second, r -&gt; r + <span class="string">&quot;is winner&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; res = first.thenCombine(second, (x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(result.join());</span><br><span class="line">        System.out.println(res.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h2><p>allOf():当所有给定的CompletableFuture完成时， 返回一个新的CompletableFuture<br>anyOf():当任何一个给定的CompletableFuture完成时，返回一个新的CompletableFuture</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllOf</span><span class="params">()</span>&#123;</span><br><span class="line">       CompletableFuture&lt;String&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;future1执行完成&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       CompletableFuture&lt;String&gt; future2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;future2执行完成&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(future1, future2);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">           all.get(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="completableFuture和线程池说明"><a href="#completableFuture和线程池说明" class="headerlink" title="completableFuture和线程池说明"></a>completableFuture和线程池说明</h1><p>以thenRun和thenRunAsync为例，有什么区别？</p>
<ul>
<li>没有传入自定义线程池，默认是ForkJoinPool.</li>
<li>如果第一个执行的任务传入了一个自定义线程池，调用thenRun执行第二个任务，则第一个和第二个都是用自定义的线程池。</li>
<li>如果第一个执行的任务传入了一个自定义线程池，调用thenRunAsyn执行第二个任务，则第一个用自定义。第二个用ForkJoinPool（后面也都是ForkJoinPool）</li>
</ul>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-Java内存模型JMM</title>
    <url>/2024/01/18/JUC-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="JMM概述"><a href="#JMM概述" class="headerlink" title="JMM概述"></a>JMM概述</h1><p>Java Meory Model java内存模型。在<strong>不同的硬件和不同的操作系统上</strong>，对内存的访问方式是不一样的。这就造成了同一套java代码运行在不同的操作系统上会出问题。JMM就屏蔽掉硬件和操作系统的差异，增加java代码的可移植性。这是一方面。<br>另一方面JMM定义的一系列规则能够保证线程并发的安全性。主要是保证线程的可见性，有序性，原子性。<br>具体来说它主要就是抽象了线程和主存之间的关系。（如下图）每个线程都有一个工作内存（cpu缓存），工作内存中存放着主存（内存）的副本，一般是共享变量，比如实例变量，静态变量但是不包括局部变量。线程读写数据是直接操作工作内存的。线程不能访问其他线程的工作内存。多个线程间通信是通过主存来完成的。<br><img src="https://img-blog.csdnimg.cn/direct/f55562a92ecc4395970d87f1be4281ac.png" alt="在这里插入图片描述"></p>
<h1 id="线程三大问题"><a href="#线程三大问题" class="headerlink" title="线程三大问题"></a>线程三大问题</h1><p><strong>原子性，可见性，有序性。（简记：客源有）</strong><br>线程需要满足这三大特性，才能保证线程并发安全。而JMM就是为了实现这三大特性定义的一系列规则。</p>
<h2 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h2><p>可见性指的是当一个线程修改了共享变量后，另一个线程能够立马得到修改的这个值。但是由于CPU缓存的存在，可见性往往会存在一些问题。<br>比如说在多线程下，每个线程将变量存放在CPU缓存中，一个线程修改了变量后，放在CPU缓存中。另一个线程无法立即得到最新的值。这就造成了共享变量的数据不一致的问题。</p>
<h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>CPU在执行指令的过程中发生了线程切换，会导致一些变量数据不一致，这种问题就成为原子性问题。</p>
<h2 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h2><p>CPU在执行指令的时候，为了充分利用内部的计算单元，处理器可能会对代码进行乱序执行。CPU在并发环境下，乱序执行可能会到导致结果错误。这种问题就叫做有序性问题。</p>
<h1 id="JMM解决线程可见性，原子性，有序性问题"><a href="#JMM解决线程可见性，原子性，有序性问题" class="headerlink" title="JMM解决线程可见性，原子性，有序性问题"></a>JMM解决线程可见性，原子性，有序性问题</h1><p>定义Java内存模型并非是一件容易的事情。不能单纯的禁用CPU缓存和编译优化，这样会严重影响程序性能。JMM抽象了线程和主存之间的关系，定义了程序中变量的访问规则来解决上述问题。<br>从抽象的角度来看，JMM定义了线程和主存之间的抽象关系：<strong>线程之间的共享变量存放在主内存中</strong>，每个线程都有一个私有的工作内存，本地内存中存储了主存中共享变量的副本，线程对变量的操作都是在工作内存中进行的。（这里的工作内存是一个抽象的概念。包含了CPU缓存，寄存器以及编译器优化。主内存则指的是物理硬件的主内存。）<br><img src="https://img-blog.csdnimg.cn/direct/ad6b05e8d1cf49a78d3a2a4587ebb539.png" alt="在这里插入图片描述"></p>
<h2 id="可见性保证"><a href="#可见性保证" class="headerlink" title="可见性保证"></a>可见性保证</h2><p><strong>可见性指的是当一个线程修改了共享变量的值之后，其他线程能够立马得到这个修改</strong>。</p>
<p><strong>volatile能够保证可见性和有序性</strong>，volatile修饰的变量在本地内存中修改后会立即同步到主存中去，供其他线程访问到。<br>锁也能保证可见性，锁在释放和申请的时候都会更新缓存，从主存中获取最新的值。</p>
<h2 id="原子性保证"><a href="#原子性保证" class="headerlink" title="原子性保证"></a>原子性保证</h2><p>通过Lock和UnLock来保证。java中是synchronized关键字。synchronized关键字对应的底层jvm指令是monitorenter和moniterexit</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有序性保证"><a href="#有序性保证" class="headerlink" title="有序性保证"></a>有序性保证</h2><p>java中提供了volatile和synchronized两个关键字来保证线程之间的有序性。<strong>volatile本身就包含了指令重排的语义。而 synchronized 则是由一个变量在同一时刻只允许一个线程对其进行 lock 操作这条规则来保证有序性的</strong></p>
<h1 id="JMM核心概念-happens-before"><a href="#JMM核心概念-happens-before" class="headerlink" title="JMM核心概念-happens-before"></a>JMM核心概念-happens-before</h1><p><strong>如果一个操作happens-before另一个操作，那么第一个操作的执行结果对后续的操作是可见的。</strong><br>两个操作存在happens-before关系，并不意味着一定要按照happens-before原则指定的顺序来执行。可以对指令进行重排序，只要保证结果正确性即可。</p>
<p>参考:<br><a href="https://zhuanlan.zhihu.com/p/416172908">从线程三大特性深入理解JMM（Java 内存模型）</a><br><a href="https://zhuanlan.zhihu.com/p/126275344">happens-before是什么？JMM最最核心的概念，看完你就懂了</a></p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-Java对象内存布局（对象头，类型指针，自填充）</title>
    <url>/2024/01/26/JUC-Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%8C%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88%EF%BC%8C%E8%87%AA%E5%A1%AB%E5%85%85%EF%BC%89/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-引入问题"><a href="#1-引入问题" class="headerlink" title="1. 引入问题"></a>1. 引入问题</h1><p>有如下问题：</p>
<ol>
<li>请解释一下对象的创建过程</li>
<li>Class对象在堆还是在方法区中</li>
<li>对象在内存中的存储布局</li>
<li>对象头具体包括什么</li>
<li>对象怎么定位</li>
<li>对象怎么分配</li>
<li>Object obj &#x3D; new Object(); 在内存中占用多少个字节</li>
</ol>
<h1 id="2-堆内存布局"><a href="#2-堆内存布局" class="headerlink" title="2. 堆内存布局"></a>2. 堆内存布局</h1><h2 id="2-1-基于分代的堆的内存布局（复习）"><a href="#2-1-基于分代的堆的内存布局（复习）" class="headerlink" title="2.1 基于分代的堆的内存布局（复习）"></a>2.1 基于分代的堆的内存布局（复习）</h2><p><img src="https://img-blog.csdnimg.cn/direct/9fd6927109eb42e2af93552015da020b.png" alt="在这里插入图片描述"></p>
<p>堆：</p>
<ul>
<li>年轻代(1)<ul>
<li>伊甸园区(8)</li>
<li>s0(1)</li>
<li>s1(1)</li>
</ul>
</li>
<li>老年代(2)<br>(注：元空间在堆外内存中）</li>
</ul>
<h2 id="2-2-对象在堆中组成部分"><a href="#2-2-对象在堆中组成部分" class="headerlink" title="2.2 对象在堆中组成部分"></a>2.2 对象在堆中组成部分</h2><p><img src="https://img-blog.csdnimg.cn/direct/b9590a7c136c492c97847011a1941d2e.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/088aad98f48f4fd786342aefbc7397d2.png" alt="在这里插入图片描述"></p>
<p>对象在堆中主要由下面三个部分组成</p>
<ul>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ul>
<p>其中对象头又分为对象标志（存储对象的基本信息）和类型指针（指向类模板）。</p>
<h2 id="2-3-对象头"><a href="#2-3-对象头" class="headerlink" title="2.3 对象头"></a>2.3 对象头</h2><h3 id="2-3-1-对象标志（Mark-Word）"><a href="#2-3-1-对象标志（Mark-Word）" class="headerlink" title="2.3.1 对象标志（Mark Word）"></a>2.3.1 对象标志（Mark Word）</h3><p>对象标志用8字节64位来存储类的一些基本信息。比如：hashcode，GC分代年龄，锁标志等<br><img src="https://img-blog.csdnimg.cn/direct/ff5fd7db7eeb44e8b554462579ecad25.png" alt="在这里插入图片描述"><br>注意这里分代年龄是4位。联想之前S区的分代年龄到达了15还没被GC就会到老年区，这里为什么是15？因为底层给了4bit来计算分代年龄。这里的15 &#x3D; 2 ^ 4 - 1</p>
<h3 id="2-3-2-类型指针（Class-Pointer）"><a href="#2-3-2-类型指针（Class-Pointer）" class="headerlink" title="2.3.2 类型指针（Class Pointer）"></a>2.3.2 类型指针（Class Pointer）</h3><p>Cat object &#x3D; new Cat();<br>分析这一句代码各个量的存储位置：</p>
<ul>
<li>new Cat()：先在堆空间创建实例对象Cat。</li>
<li>object ：局部引用变量存放在栈帧中的局部变量表中</li>
<li>Cat：类模板（类元数据）存放在方法区（方法区的实现元空间放在堆外内存中）<br><strong>类型指针指向他的类模板，通过这个指针来确定该实例对象属于哪个类。</strong></li>
</ul>
<h3 id="2-3-3-补充：32位CPU和64位CPU区别"><a href="#2-3-3-补充：32位CPU和64位CPU区别" class="headerlink" title="2.3.3 补充：32位CPU和64位CPU区别"></a>2.3.3 补充：32位CPU和64位CPU区别</h3><p>32位CPU表示总线的位宽位32位，通过总线来寻址，也就是能够表示2 ^ 32 &#x3D; 4 * 2 ^ 30 &#x3D; 4G内存。<br>同理，64位能够表示8G内存。</p>
<h2 id="2-4-实例数据"><a href="#2-4-实例数据" class="headerlink" title="2.4 实例数据"></a>2.4 实例数据</h2><p>如果对象有成员属性，这里就会有数据信息。如果没有属性，就不会有数据信息。比如boolean类型的属性占1个字节。int类型占4个字节。</p>
<h3 id="2-4-1-补充：8中基本数据类型占存储空间的大小。"><a href="#2-4-1-补充：8中基本数据类型占存储空间的大小。" class="headerlink" title="2.4.1 补充：8中基本数据类型占存储空间的大小。"></a>2.4.1 补充：8中基本数据类型占存储空间的大小。</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">整数类型：byte(1字节),short(2字节), int(4字节),long(8字节)</span><br><span class="line">浮点类型：float(4字节)， double(8字节)</span><br><span class="line">字符类型：char(2字节)</span><br><span class="line">布尔类型: boolean(1个字节)</span><br></pre></td></tr></table></figure>
<h2 id="2-5-对齐填充"><a href="#2-5-对齐填充" class="headerlink" title="2.5 对齐填充"></a>2.5 对齐填充</h2><h3 id="2-5-1-为什么要对齐数据？"><a href="#2-5-1-为什么要对齐数据？" class="headerlink" title="2.5.1 为什么要对齐数据？"></a>2.5.1 为什么要对齐数据？</h3><p>为了CPU能够高效寻址 。</p>
<h1 id="3-分析对象占多少个字节"><a href="#3-分析对象占多少个字节" class="headerlink" title="3. 分析对象占多少个字节"></a>3. 分析对象占多少个字节</h1><h2 id="3-1-普通对象"><a href="#3-1-普通对象" class="headerlink" title="3.1 普通对象"></a>3.1 普通对象</h2><p>Object object &#x3D; new Object()占几个字节？<br>在64位CPU上，对象头中对象标志占8个字节，类型指针占4个字节。实例数据区无数据。对齐区12不是8的倍数了，扩充4个字节变成16。因此一共16个字节。</p>
<h2 id="3-2-数组对象（多了个length）"><a href="#3-2-数组对象（多了个length）" class="headerlink" title="3.2 数组对象（多了个length）"></a>3.2 数组对象（多了个length）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(a).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的内存布局信息：</p>
<p><img src="https://img-blog.csdnimg.cn/direct/2fce49f8a3c74471810b381699b9d51a.png" alt="在这里插入图片描述"><br>可以看到SIZE一共是24byte。<br>对象头：对象标志8字节。类型指针4字节。数组长度4字节。<br>实例数据：int 1 数据4字节。<br>对齐：前面一共20字节。填充4字节。使其满足8的倍数。</p>
<h1 id="4-回答开头的问题"><a href="#4-回答开头的问题" class="headerlink" title="4. 回答开头的问题"></a>4. 回答开头的问题</h1><ol>
<li>请解释一下对象的创建过程</li>
</ol>
<ul>
<li>new 申请一块空间，将属性赋值为初始值。（半初始化）</li>
<li>调用构造方法，对变量进行赋值。（初始化）</li>
<li>建立关联：将引用变量指向对象的地址。<ol start="2">
<li>对象在堆还是在方法区中<br>对象在堆中。对象所属类的元信息才在方法区中（比如类的方法代码，变量名，方法名，访问权限）。</li>
<li>对象在内存中的存储布局<br>对象创建后存放在堆空间中。一个对象存储结构包括对象头，实例数据，填充空间。对象头中的对象标志用来保存对象的基本信息，比如hascode, 分代年龄，锁标志等信息。对象头中的类型指针指向元空间中的类模板，表示当前对象所属的类。实例数据中存放对象中的属性值。填充字段用于字节对齐使对象存储空间为8的倍数。</li>
<li>对象头具体包括什么</li>
</ol>
</li>
<li>对象标志：hashcode,锁标志，分代年龄等</li>
<li>类型指针：指向方法区中的类。</li>
<li>数组长度（数组对象才有）<ol start="5">
<li><p>对象怎么定位<br>栈中的局部变量表中的引用变量存放的是对象的地址。通过引用变量能定位到对象。</p>
</li>
<li><p>对象怎么分配<br>如果对象不可逃逸，且属于热点数据，会直接在栈上进行分配。栈上分配的对象不用GC，直接弹出就行了。<br>如果对象占用空间很大，直接在老年代分配。<br>一般对象会先在年轻代的Eden区进行分配。</p>
</li>
<li><p>Object obj &#x3D; new Object(); 在内存中占用多少个字节<br>在内存中占用16字节，开启与不开启类型指针压缩都是16字节。</p>
</li>
</ol>
</li>
</ul>
<h1 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5. 参考链接"></a>5. 参考链接</h1><ol>
<li><a href="https://www.cnblogs.com/jajian/p/13681781.htm">Java对象的内存布局</a></li>
<li><a href="https://blog.csdn.net/qq_44300280/article/details/127816983">大厂面试题Object object &#x3D; new Object()</a></li>
</ol>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-ReentrantLock,ReentrantReadWriteLock,StampedLock</title>
    <url>/2024/01/28/JUC-ReentrantLock,ReentrantReadWriteLock,StampedLock/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>前面介绍过了synchronized关键字作用的锁升级过程<br>无锁-&gt;偏向锁-&gt;轻量锁-&gt;重锁<br>下面再介绍实现Lock接口的锁的升级过程<br><strong>无锁-&gt;独占锁（ReentrantLock，Synchronized）-&gt;读写锁(ReentranReadWriteLock)-&gt;邮戳锁(StampedLock)</strong><br>并准备了一些问题，回顾一下自己对知识的掌握程度。</p>
<ol>
<li>你知道Java里面有哪些锁?</li>
<li>你说你用过读写锁，锁饥饿问题是什么?有没有比读写锁更快的锁?</li>
<li>StampedLock知道吗?(邮戳锁&#x2F;票据锁)</li>
<li>ReentrantReadWriteLock有锁降级机制，你知道吗?</li>
</ol>
<h1 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2. ReentrantLock"></a>2. ReentrantLock</h1><p>ReentantLock是<font color='red'>可重入的独占锁</font>。默认是非公平锁。<br>可重入：当一个线程持有锁后，在内部可以继续获取锁。<br>独占：是一种悲观锁，当一个线程持有锁的时候，其他线程会阻塞。<br>公平和非公平：在公平的机制下，线程会依次排队，放到等待队列中。排队获取锁。在非公平的机制下，新来的线程通过CAS获取锁，获取不到，才会进入等待队列。</p>
<h2 id="2-1-ReentrantLock使用代码演示"><a href="#2-1-ReentrantLock使用代码演示" class="headerlink" title="2.1 ReentrantLock使用代码演示"></a>2.1 ReentrantLock使用代码演示</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----come in外层调用&quot;</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----come in内层调用&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 由于加锁次数和释放次数不一样，第二个线程始终无法获取到锁，导致一直在等待。</span></span><br><span class="line">                lock.unlock();<span class="comment">// 正常情况，加锁几次就要解锁几次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----come in外层调用&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-ReentrantLock和Synchronized比较"><a href="#2-2-ReentrantLock和Synchronized比较" class="headerlink" title="2.2 ReentrantLock和Synchronized比较"></a>2.2 ReentrantLock和Synchronized比较</h2><ol>
<li>ReentrantLock是对象，synchronzied是关键字</li>
<li>两者都是独占锁。（悲观锁）</li>
<li>ReentrantLock加锁后需要手动解锁<code>try&#123;//do something&#125;finally&#123;Lock.unlock();&#125;</code>。synchronized关键字超出同步块自动解锁。</li>
<li>ReentrantLock更灵活，可以控制是否是公平锁。synchronized只能是非公平锁。</li>
</ol>
<p>使用场景的区别：</p>
<h3 id="2-2-1-synchronized"><a href="#2-2-1-synchronized" class="headerlink" title="2.2.1 synchronized"></a>2.2.1 synchronized</h3><p>写冲突比较多，线程强冲突的场景。<br>自旋的概率比较大，会导致浪费CPU性能。</p>
<h3 id="2-2-2-ReentrantLock"><a href="#2-2-2-ReentrantLock" class="headerlink" title="2.2.2 ReentrantLock"></a>2.2.2 ReentrantLock</h3><p>synchronized锁升级是不可逆的，进入重量级锁后性能会下降。<br>ReentrantReadWriteLock（注意不是ReentrantLock）可以使用读写锁，增加性能。</p>
<h1 id="3-ReentrantReadWriteLock"><a href="#3-ReentrantReadWriteLock" class="headerlink" title="3. ReentrantReadWriteLock"></a>3. ReentrantReadWriteLock</h1><p>可重入读写锁。上面的可重入锁在<font color='red'>两个线程同时读</font>的过程中会竞争。可重入读写锁可以允许多个线程同时读取同一个资源。只允许读读共存，读写，写写之间都是互斥的。适用于读读不互斥的场景。</p>
<h2 id="3-1-具有锁降级的性质"><a href="#3-1-具有锁降级的性质" class="headerlink" title="3.1 具有锁降级的性质"></a>3.1 具有锁降级的性质</h2><p>锁降级可以理解为一种操作。具体操作为写锁持有后，在准备释放写锁的之前，当前线程继续持有读锁，然后释放写锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">writeLock.lock();</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="comment">// 锁降级:释放写锁之前先只有读锁。</span></span><br><span class="line">readLock.lock(); <span class="comment">// A 降级开始</span></span><br><span class="line">writeLock.unlock();<span class="comment">// 注意执行完这一步，其他阻塞队列的头部的读线程才能进入。</span></span><br><span class="line"><span class="comment">// 锁降级完成</span></span><br><span class="line">....</span><br><span class="line">readLock.unlock();</span><br></pre></td></tr></table></figure>
<p>这种方式的好处是：在耗时长的事务中，锁降级能够使让读操作更快进行执行不会被写操作给抢占，且后面的读操作不会被打断。<br>锁降级的代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line">        <span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDownTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(LockDownTest.class);</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>(<span class="literal">true</span>);</span><br><span class="line">    ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line">    ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *	这里仅仅是想知道锁重入的情况，是不是这个时候加入的锁会到等待队列里面排队。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            readLock.lock();</span><br><span class="line">            logger.info(<span class="string">&quot;主线程通过可重入读锁，查询数据完成.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 开始锁降级</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        logger.info(<span class="string">&quot;主线程抢到写锁...&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里的休眠是为了让下面线程能在预想的情况下加入等待队列.</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 这里就是假设等待队列里面排在前面的是读锁线程</span></span><br><span class="line">        processReadLock(<span class="number">1</span>); </span><br><span class="line">        processReadLock(<span class="number">2</span>); </span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        processWriteLock(<span class="number">4</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        processReadLock(<span class="number">3</span>); </span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 开始锁降级</span></span><br><span class="line">        readLock.lock(); <span class="comment">// A 降级开始</span></span><br><span class="line">        <span class="comment">// 锁降级完成</span></span><br><span class="line">        writeLock.unlock();<span class="comment">// 注意必须读锁锁住，写锁释放操作完才降级完成，其他读线程才能进入。</span></span><br><span class="line">        logger.info(<span class="string">&quot;主线程释放写锁（写锁降级为读锁，允许其他读操作进入）&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;sleep 10s 验证等待队列中的读操作是否能执行..&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);<span class="comment">// 睡3s验证其他的读操作能进行</span></span><br><span class="line">        logger.info(<span class="string">&quot;sleep 10s 结束&quot;</span>);</span><br><span class="line">        queryData();<span class="comment">// 还是主线程去获取读锁。验证可重入锁。</span></span><br><span class="line">        readLock.unlock(); <span class="comment">// A 降级结束</span></span><br><span class="line">        logger.info(<span class="string">&quot;主线程读锁释放&quot;</span>);</span><br><span class="line"><span class="comment">//        logger.info(&quot;过程结束..&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWriteLock</span><span class="params">(<span class="type">int</span> threadIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;线程&quot;</span> + threadIndex + <span class="string">&quot; 写锁开始竞争,阻塞中.&quot;</span>);</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            logger.info(<span class="string">&quot;线程&quot;</span> + threadIndex + <span class="string">&quot; 写锁执行中..&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">            logger.info(<span class="string">&quot;线程&quot;</span> + threadIndex + <span class="string">&quot; 写锁释放..&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processReadLock</span><span class="params">(<span class="type">int</span> threadIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;线程&quot;</span> + threadIndex + <span class="string">&quot; 读锁开始竞争,阻塞中.&quot;</span>);</span><br><span class="line">            readLock.lock();</span><br><span class="line">            logger.info(<span class="string">&quot;线程&quot;</span> + threadIndex + <span class="string">&quot; 读锁执行中..&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            logger.info(<span class="string">&quot;线程&quot;</span> + threadIndex + <span class="string">&quot; 读锁释放..&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">LockDownTest</span> <span class="variable">readWriteLockTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockDownTest</span>();</span><br><span class="line">        readWriteLockTest.test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这是公平锁的情况，结果说明：<br><img src="https://img-blog.csdnimg.cn/direct/db188fa998024537ad2c2276d5051687.png" alt="在这里插入图片描述"></p>
<h2 id="3-2-可重入读写锁缺点（引入邮戳锁）"><a href="#3-2-可重入读写锁缺点（引入邮戳锁）" class="headerlink" title="3.2 可重入读写锁缺点（引入邮戳锁）"></a>3.2 可重入读写锁缺点（引入邮戳锁）</h2><p>ReentrantReadWriteLock实现了读写分离。默认是非公平锁，每个线程是随机获取锁的。可能会导致锁饥饿的问题。<br>使用公平锁策略一定程度上能缓解这个问题，但是公平锁是牺牲系统的吞吐量为代价的。<br>引入StampedLock类的乐观锁。</p>
<h1 id="4-StampedLock"><a href="#4-StampedLock" class="headerlink" title="4. StampedLock"></a>4. StampedLock</h1><p>StampedLock邮戳锁。这种锁是一种乐观锁，允许线程在读过程中进行写操作。让读多写少的时候，写线程有机会获取写锁。减少了线程饥饿的问题。吞吐量（单位时间系统能处理的请求量）大大提高。<br>在读线程操作临界资源的时候，允许写操作进行资源修改，那么读取到的数据是错误的怎么办？<br>为了保证读线程读取数据的正确性。读取的时候是乐观读，乐观读<code>tryOptimisticRead</code>不能保证读取的数据是正确性的，所以将数据读取到局部变量中，再通过<code>lock.validate(stamp)</code>校验是否被写线程修改过，若修改过则需要上悲观锁，重新读取数据到局部变量。</p>
<h2 id="4-1-代码示例"><a href="#4-1-代码示例" class="headerlink" title="4.1 代码示例"></a>4.1 代码示例</h2><p>使用代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//乐观读，读的过程中也允许获取写锁介入</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead();</span><br><span class="line">       <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> number;</span><br><span class="line">       <span class="comment">//故意间隔4秒钟，很乐观认为读取中没有其它线程修改过number值，具体靠判断</span></span><br><span class="line">       System.out.println(<span class="string">&quot;4秒前stampedLock.validate方法值(true无修改，false有修改)&quot;</span>+<span class="string">&quot;\t&quot;</span>+stampedLock.validate(stamp));</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;正在读取... &quot;</span>+i+<span class="string">&quot; 秒&quot;</span> +</span><br><span class="line">                   <span class="string">&quot;后stampedLock.validate方法值(true无修改，false有修改)&quot;</span>+<span class="string">&quot;\t&quot;</span>+stampedLock.validate(stamp));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!stampedLock.validate(stamp))</span><br><span class="line">       &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;有人修改过------有写操作&quot;</span>);</span><br><span class="line">           <span class="comment">// 数据校验失败，升级为悲观读</span></span><br><span class="line">           stamp = stampedLock.readLock();</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;从乐观读 升级为 悲观读&quot;</span>);</span><br><span class="line">               result = number;</span><br><span class="line">               System.out.println(<span class="string">&quot;重新悲观读后result：&quot;</span>+result);</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               stampedLock.unlockRead(stamp);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; finally value: &quot;</span>+result);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-2-使用场景和注意事项"><a href="#4-2-使用场景和注意事项" class="headerlink" title="4.2 使用场景和注意事项"></a>4.2 使用场景和注意事项</h2><p>StampedLock适用于读多写少的高并发场景。通过乐观读很好的解决了写线程饥饿的问题。<br>值得注意的是：<br>StampedLock不是可重入锁</p>
<h1 id="5-无锁-独占锁-读写锁-邮戳锁总结"><a href="#5-无锁-独占锁-读写锁-邮戳锁总结" class="headerlink" title="5. 无锁-独占锁-读写锁-邮戳锁总结"></a>5. 无锁-独占锁-读写锁-邮戳锁总结</h1><p><img src="https://img-blog.csdnimg.cn/direct/ca90296d76a04e54960d81a32d89f952.png" alt="在这里插入图片描述"></p>
<ol>
<li>从无锁到独占锁：无锁状态下数据在多线程环境下不安全因此需要锁</li>
<li>独占锁到可重入读写锁：独占锁在「读读」的时候线程存在竞争关系，实际很多场景中是允许多个线程同时读的。</li>
<li>可重入读写锁到邮戳锁：可重入读写锁会导致读多写少情况下的线程饥饿问题。引入了邮戳锁，允许读的过程中进行写。但是要采取乐观读的方式，进行数据的校验。如果数据校验失败，从乐观读变为悲观读。（乐观读的过程中允许写，悲观读的过程中不允许写操作）</li>
</ol>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-中断机制和LockSupport</title>
    <url>/2024/01/15/JUC-%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E5%92%8CLockSupport/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="线程中断机制"><a href="#线程中断机制" class="headerlink" title="线程中断机制"></a>线程中断机制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>java提供了一种用于停止线程的协商机制-中断。称为中断标识协商机制。</p>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul>
<li>public void interrupt()<br>仅仅让线程的中断标志位设置为true。不进行其他操作。</li>
<li>public boolean isInterrupted()<br>获取中断标志位的状态。</li>
<li>public static boolean interrupted()<br>获取中断标志位的状态。并将中断标志位设置为false</li>
</ul>
<h2 id="如何停止中断运行的线程"><a href="#如何停止中断运行的线程" class="headerlink" title="如何停止中断运行的线程"></a>如何停止中断运行的线程</h2><h3 id="volatile变量实现"><a href="#volatile变量实现" class="headerlink" title="volatile变量实现"></a>volatile变量实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isStop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程isStop = true,自己退出&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-------hello interrupt--------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        isStop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="AtomicBoolean实现"><a href="#AtomicBoolean实现" class="headerlink" title="AtomicBoolean实现"></a>AtomicBoolean实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">atomicBoolean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (atomicBoolean.get()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-------hello------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        atomicBoolean.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="中断API-interrupt和isInterrupted"><a href="#中断API-interrupt和isInterrupted" class="headerlink" title="中断API interrupt和isInterrupted"></a>中断API interrupt和isInterrupted</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----t1 线程被中断了，程序结束&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----hello-------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1是否被中断：&quot;</span> + t1.isInterrupted());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1是否被中断：&quot;</span> + t1.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>如果线程处于正常活动状态，interrupt会将该线程中断状态位设置为true。要想该线程进行进一步处理需要自己根据中断状态为来写业务逻辑。</li>
<li>如果线程处于阻塞状态（sleep, wait, join）在别的线程调用当前线程interrupt方法，那么线程立即退出阻塞状态，并抛出InterruptException异常，并将中断标志为清除（置为false）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;中断标志位：&quot;</span>+Thread.currentThread().isInterrupted()+<span class="string">&quot; 程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();<span class="comment">//为什么要在异常处，再调用一次？？</span></span><br><span class="line">                    <span class="comment">// 阻塞状态下的线程设置中断标志位为true,会报异常。中断状态位置为false。导致死循环。因此需要再次设置为true</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;-----hello InterruptDemo3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t1.interrupt(),<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>拓展：线程有哪些状态？7种状态<br>创建，就绪（等待CPU），运行，阻塞(等待锁对象)，等待（等待事件），超时等待，结束<br>sleep不会释放锁。wait会释放锁。因此sleep进入等待状态。wait进入阻塞状态。</p>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><p>LockSupport是线程阻塞和唤醒的工具类。主要通过park阻塞和unpark唤醒。</p>
<h2 id="线程等待唤醒机制"><a href="#线程等待唤醒机制" class="headerlink" title="线程等待唤醒机制"></a>线程等待唤醒机制</h2><h3 id="Synchronized锁对象的wait和notify"><a href="#Synchronized锁对象的wait和notify" class="headerlink" title="Synchronized锁对象的wait和notify"></a>Synchronized锁对象的wait和notify</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li>必须在Synchronized同步块中</li>
<li>wait必须在之前notify。否则通知唤醒会失效。</li>
</ul>
<h3 id="Lock-condition的await和signal"><a href="#Lock-condition的await和signal" class="headerlink" title="Lock.condition的await和signal"></a>Lock.condition的await和signal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">       <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----come in&quot;</span>);</span><br><span class="line">               condition.await();</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">       <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">       <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               condition.signal();</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>
<h3 id="LockSupport的park和unpark"><a href="#LockSupport的park和unpark" class="headerlink" title="LockSupport的park和unpark"></a>LockSupport的park和unpark</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----come in&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>不需要在锁块中，本身就可以让线程同步。</li>
<li>park和unpark不需要有先后顺序。unpark相当于给了park一个凭证。unpark在park执行前也可以让park唤醒。相当于提前给了凭证。（而前面两种就不行）</li>
<li>一个park需要一个凭证。但是不同的unpark作用于一个线程只能给一个凭证。（即是连续调用多次unpark和调用一次作用是一样的）</li>
</ul>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-synchronized无锁、偏向锁、轻量级锁、重量级锁</title>
    <url>/2024/01/27/JUC-synchronized%E6%97%A0%E9%94%81%E3%80%81%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="1-synchronized实操"><a href="#1-synchronized实操" class="headerlink" title="1 synchronized实操"></a>1 synchronized实操</h1><blockquote>
<p>关键字synchronized可以用来保证多线程并发安全的<strong>原子性、可见、有序性。</strong>关键字synchronized不仅可以作用于方法还可以作用于同步代码块，能够保证作用范围中线程访问安全。</p>
</blockquote>
<p>注意：<strong>局部变量是线程安全的。线程不安全问题只存在于实例变量。</strong></p>
<p>synchronized关键字作用如下图：<br><img src="https://img-blog.csdnimg.cn/direct/61af299e52ed4e3aa8a980f92db48bf9.png" alt="在这里插入图片描述"></p>
<ul>
<li>同步方法：分为静态方法和非静态方法，对静态方法，锁作用对象是<strong>类对象</strong>。对非静态方法，锁作用对象是<strong>实例对象。</strong></li>
<li>同步方法块：通过<code>synchronized(obj)</code>来对某个对象进行加锁。如果是this表示<strong>实例对象</strong>。如果是xx.class表示作用于<strong>类对象</strong>。</li>
</ul>
<h2 id="1-1-锁作用于类对象和实例对象的区别？"><a href="#1-1-锁作用于类对象和实例对象的区别？" class="headerlink" title="1.1 锁作用于类对象和实例对象的区别？"></a>1.1 锁作用于类对象和实例对象的区别？</h2><ul>
<li>锁作用于实例对象：<font color='red'>当多个线程访问同一个实例对象的同步块的时候，存在竞争关系。</font>只能有一个线程能访问当前实例对象的锁。其他线程只能等待，直到占所有的线程释放实例对象的锁。</li>
<li>锁作用于类对象：<font color='red'>当多个线程访问同一个类的不同实例对象的同步块的时候，存在竞争关系。</font>因为锁所用于类上，虽然是不同的实例对象但是所属同一个类，只有一把类锁。因此多个线程仍然存在竞争关系。</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 类锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 实例对象锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">     	<span class="comment">// 类锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 实例对象锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;a&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 实例对象锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非静态同步方法用的是同一把锁：<font color='red'>实例对象本身</font><br>静态同步方法用的是同一把锁：<font color='red'>类本身</font><br>注意：无加锁的方法块和加锁的方法块不存在竞争关系。静态同步块和非静态同步块也不存在竞争关系，因为持有的是不同的锁。</p>
<h1 id="2-synchronized原理"><a href="#2-synchronized原理" class="headerlink" title="2 synchronized原理"></a>2 synchronized原理</h1><h2 id="2-1-synchronized对应字节码指令"><a href="#2-1-synchronized对应字节码指令" class="headerlink" title="2.1 synchronized对应字节码指令"></a>2.1 synchronized对应字节码指令</h2><h3 id="2-1-1-同步方法"><a href="#2-1-1-同步方法" class="headerlink" title="2.1.1 同步方法"></a>2.1.1 同步方法</h3><p>使用命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">javap -c -v synchronizedTest.class</span><br></pre></td></tr></table></figure>
<p>注：-c是查看字节码指令 -v是打印附加信息<br><img src="https://img-blog.csdnimg.cn/direct/3d74d470a9b6470b988ad6535ff6a625.png" alt="在这里插入图片描述"><br>在同步方法中，加了synchronized关键字，方法的flag标志有ACC_SYNCHRONIZED标志</p>
<h3 id="2-1-2-同步代码块"><a href="#2-1-2-同步代码块" class="headerlink" title="2.1.2 同步代码块"></a>2.1.2 同步代码块</h3><p>同样的使用上述命令查看字节码<br><img src="https://img-blog.csdnimg.cn/direct/9b5adc907a1746a3bb6dcad702ce5b31.png" alt="在这里插入图片描述"><br>可以看到当用<code>synchronized()</code>表示同步代码块后，字节码对应会有<code>monitorenter</code>和<code>monitorexit</code>指令，表示获取锁，释放锁。</p>
<h1 id="3-synchronized锁升级"><a href="#3-synchronized锁升级" class="headerlink" title="3 synchronized锁升级"></a>3 synchronized锁升级</h1><p>jdk1.6之前synchronized的实现都为重量锁，重量锁需要用户态切入到内核态获取锁对象，影响性能。<br>jdk1.6及其之后进行了优化，引入了偏向锁和轻量级锁（性能比重量锁更好），以及锁存储结构和锁升级，也就是说synchronized同步块会根据具体情况从无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁 升级锁。</p>
<h2 id="3-1-无锁"><a href="#3-1-无锁" class="headerlink" title="3.1 无锁"></a>3.1 无锁</h2><p>线程之间不会有锁的竞争。多线程下会造成数据的不安全。</p>
<h2 id="3-2-偏向锁"><a href="#3-2-偏向锁" class="headerlink" title="3.2 偏向锁"></a>3.2 偏向锁</h2><blockquote>
<p>顾名思义，偏向于某个线程的锁。会偏向于第一个访问锁的线程</p>
</blockquote>
<p>原理:<br>当线程进入同步块的时候，获取到锁之后，退出同步块的时候不会主动释放锁。当线程第二次进入同步代码块的时候，会判断此时持有锁的线程是不是自己（持有锁对象的线程存放在对象头中）。如果是自己正常执行。从始至终能使用锁的只有一个线程，性能很高。（java 15被废弃）<br>简言之，线程进入的时候获取锁，不会释放。下次线程来的时候直接用。<br>偏向锁只有在其他线程尝试获取偏向锁的时候才会释放。竞争的线程用CAS来替换对象头中的持有锁线程ID。</p>
<ul>
<li>如果竞争成功，仍然为偏向锁。只不过偏向新的线程。</li>
<li>如果竞争失败，升级为轻量级锁。</li>
</ul>
<h2 id="3-3-轻量级锁"><a href="#3-3-轻量级锁" class="headerlink" title="3.3 轻量级锁"></a>3.3 轻量级锁</h2><p>多个线程下，基本不会出现或者轻微的锁的竞争，那么synchronized就处于轻量级锁的状态下。这种状态允许线程出现短时间的CAS自旋空转。<br>没有抢到的锁会自旋，即不停地循环判断是否能够获取锁。获取锁的操作其实是通过CAS修改对象头中的锁标志位。<br>注：<font color='red'>轻量级锁和偏向锁有一个重要的区别是偏向锁获得锁之后不会主动释放。轻量级锁获得锁之后会主动释放。</font></p>
<h2 id="3-4-重量级锁"><a href="#3-4-重量级锁" class="headerlink" title="3.4 重量级锁"></a>3.4 重量级锁</h2><p>线程竞争锁过程中长时间的自旋是非常影响性能的。因此会用计数器记录自旋次数（默认是10次）如果超出限定次数。会将轻量级锁升级为重量级锁。<br>进入重量级锁状态，当一个线程获取锁之后。其余线程会进入阻塞状态。简言之，就是所有的控制权交给了操作系统，操作系统来负责线程的切换，会频繁的从用户态到内核态的切换，严重影响性能。</p>
<h1 id="4-synchronized锁升级总结"><a href="#4-synchronized锁升级总结" class="headerlink" title="4 synchronized锁升级总结"></a>4 synchronized锁升级总结</h1><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁都不需要额外的消耗</td>
<td>如果多个线程竞争会带来额外的锁撤销消耗</td>
<td>只有一个线程访问同步块</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高程序的相应速度</td>
<td>线程竞争一直得不到锁，会自旋消耗cpu性能</td>
<td>追求响应时间，同步块执行速度特别快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>竞争的线程会自旋，不会消耗CPU</td>
<td>线程阻塞，用户态和内核态切换时间长，响应时间慢</td>
<td>追求吞吐量，同步执行时间长</td>
</tr>
</tbody></table>
<p>简单描述锁升级过程：<br>单个线程竞争适合偏向锁。两个线程竞争锁的时候，竞争成功，会偏向另一个线程。竞争失败，升级为轻量级锁。轻量级锁适合多个线程少量竞争，CAS自旋次数有一定限制的锁争抢。当CAS自旋次数超过限度，会升级为重量级锁。</p>
<h1 id="5-思考问题"><a href="#5-思考问题" class="headerlink" title="5 思考问题"></a>5 思考问题</h1><ol>
<li><p>为什么会存在锁升级现象？<br>  JDK1.6之前sychronized只有重量级锁。重量级锁需要依靠操作系统来完成线程的切换。线程切换需要从用户态到内核态，他们分别有自己专用的内存空间，导致用户态到内核态切换很耗时，影响程序性能。<br>  <font color='red'>为了减少线程获取锁带来的性能消耗，引入了偏向锁和轻量级锁。</font></p>
</li>
<li><p>为什么每个对象都可以成为一个锁？<br>  因为每个对象的对象头里面都有一个锁标志，表示这个对象的锁的状态。深入底层理解的话，因为每个对象实例都有一个Monitor，Monitor和实例对象一起创建一起销毁。实例对象中头中有标志关联Monitor，而Monitor中owner属性存放持有锁的线程id。</p>
</li>
<li><p>锁消除是什么？<br>  锁消除是JIT即时编译器的优化手段。属于代码bug，代码虽然加锁了，但是每个线程都不会出现竞争的情况(每把锁都不相同)。比如下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                cat.test();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 每个线程进来都新new一个对象，所以每个线程的锁都不一样，相当于无锁</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">System.out.println(object.hashCode()+<span class="string">&quot;====&quot;</span>+o.hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>锁粗化是什么？<br>  也是JIT即时编译器优化手段。将相邻的锁住同一个锁对象的代码合并。比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockBigDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;222222&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;333333&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;444444&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// JTI进行锁粗化后的代码相当于：</span></span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;222222&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;333333&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;444444&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6 参考链接"></a>6 参考链接</h1><ol>
<li><a href="https://cloud.tencent.com/developer/article/1813320">锁升级：无锁、偏向锁、轻量级锁、重量级锁</a></li>
<li><a href="https://blog.csdn.net/qq_44300280/article/details/127235830">synchronized无锁、偏向锁、轻量级锁、重量级锁</a></li>
</ol>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-锁</title>
    <url>/2024/01/14/JUC-%E9%94%81/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>当一个线程在操作资源的时候，会悲观的认为有其他的线程会来抢占该资源，因此会在操作资源前进行加锁，避免其他线程抢占。<br>Synchronized关键字和Lock实现类就是悲观锁。<br>显示的锁定资源后再对资源进行操作。<br><strong>使用场景：</strong></p>
<ul>
<li>适合写操作多的场景。先加锁能够保证写操作时数据正确</li>
</ul>
<p><strong>本质：</strong><br>加锁去操作同步资源。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>当一个线程去操作资源的时候，会乐观的任务其他线程不会来抢占资源，因此不会加锁。<br>java中通过无锁编程来实现，只是在对数据进行修改的时候，判断其他线程是否对该数据进行修改过</p>
<ul>
<li>如果没有修改过，该线程直接修改数据。</li>
<li>如果修改过，该线程则根据不同的实现方式执行不同的操作，比如放弃修改，重试抢锁等等。</li>
</ul>
<p>原子操作类那些底层的是CAS(Compare And swap)算法，也就是乐观锁。<br><strong>判断规则：</strong></p>
<ul>
<li>版本号机制Version（每修改一次版本号递增，当前版本号是最大的，可以直接修改。不是最大的，意味着别人修改过了，我的修改要重新处理）</li>
<li>最常采用的是CAS算法（后面会详细讲，这里略）</li>
</ul>
<p><strong>使用场景：</strong><br>乐观锁适合读操作多的场景，不加锁读操作性能大幅提升<br><strong>本质：</strong><br>无锁去操作同步资源。</p>
<h1 id="乐观锁和悲观锁举例"><a href="#乐观锁和悲观锁举例" class="headerlink" title="乐观锁和悲观锁举例"></a>乐观锁和悲观锁举例</h1><p>悲观锁：Synchronized和Lock的实现类<br>乐观锁：原子操作的类AtomicInteger, LongAdder<br><img src="https://img-blog.csdnimg.cn/direct/82617594cb364fb69f046175f4d8e9b0.png" alt="在这里插入图片描述"></p>
<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h2 id="阿里加锁规范"><a href="#阿里加锁规范" class="headerlink" title="阿里加锁规范"></a>阿里加锁规范</h2><p>高并发时，同步调用时需要考虑加锁性能损耗。能用无锁数据结构就用无锁数据结构。能用块锁，就不要锁方法体。能用对象锁，就不要用类锁。<br>（尽可能让锁的代码块尽可能小，避免锁造成不必要的性能开销）</p>
<h2 id="Synchronized三种作用方式"><a href="#Synchronized三种作用方式" class="headerlink" title="Synchronized三种作用方式"></a>Synchronized三种作用方式</h2><p>作用于实例方法：当前实例加锁，进入实例前要获取当前实例的锁对象。<br>作用于代码块：对括号里的对象进行加锁。<br>作用于静态方法（类方法）：对当前类加锁，进去同步代码前要获得当前对象的锁。</p>
<h2 id="Synchronized作用于非静态方法和静态方法的区别（重要）"><a href="#Synchronized作用于非静态方法和静态方法的区别（重要）" class="headerlink" title="Synchronized作用于非静态方法和静态方法的区别（重要）"></a>Synchronized作用于非静态方法和静态方法的区别（重要）</h2><p><strong>类中Synchronized修饰非静态方法（对象锁）</strong></p>
<ul>
<li>加的锁为this对象锁。 </li>
<li>一个对象只有一把对象锁，因此多个线程执行一个对象的非静态同步方法时，存在竞争关系。先获得对象锁的线程先执行。（不同对象不会有竞争）</li>
<li>不同对象有不同的对象锁，线程如果持有不同对象锁，线程间无竞争的关系。</li>
</ul>
<p><strong>类中Synchronized修饰静态方法（类锁）</strong></p>
<ul>
<li>加的锁为类锁。 </li>
<li>先获得类锁的线程先执行。多个线程执行同一个类模板的不同对象的静态同步方法的时候，存在竞争关系。先获得类锁的线程先执行。（同一个对象会竞争，不同对象也会竞争）</li>
<li>不同类有不同的类锁，线程如果持有不同的类锁，线程间无竞争关系</li>
<li>一个对象的类锁和对象锁是不同的锁。一个线程持有类锁，一个线程持有对象锁，线程间无竞争关系。</li>
</ul>
<p> <strong>类中无Syncronize修饰的方法（和锁无关）</strong><br> 线程执行该方法不需要获得锁，直接执行就行了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：谈谈你对多线程锁的理解,8锁案例说明</span></span><br><span class="line"><span class="comment"> * 口诀：线程   操作  资源类</span></span><br><span class="line"><span class="comment"> * 8锁案例说明：</span></span><br><span class="line"><span class="comment"> * 1 标准访问有ab两个线程，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 2 sendEmail方法中加入暂停3秒钟，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 3 添加一个普通的hello方法，请问先打印邮件还是hello</span></span><br><span class="line"><span class="comment"> * 4 有两部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 5 有两个静态同步方法，有1部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 6 有两个静态同步方法，有2部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 7 有1个静态同步方法，有1个普通同步方法,有1部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 8 有1个静态同步方法，有1个普通同步方法,有2部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 笔记总结：</span></span><br><span class="line"><span class="comment"> * 1-2(对象锁)</span></span><br><span class="line"><span class="comment"> *  *  *  一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span></span><br><span class="line"><span class="comment"> *  *  *  其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一的一个线程去访问这些synchronized方法</span></span><br><span class="line"><span class="comment"> *  *  *  锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span></span><br><span class="line"><span class="comment"> *  3-4</span></span><br><span class="line"><span class="comment"> *  *  加个普通方法后发现和同步锁无关</span></span><br><span class="line"><span class="comment"> *  *  换成两个对象后，不是同一把锁了，情况立刻变化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  5-6（类锁） 都换成静态同步方法后，情况又变化</span></span><br><span class="line"><span class="comment"> *  三种 synchronized 锁的内容有一些差别:</span></span><br><span class="line"><span class="comment"> * 对于普通同步方法，锁的是当前实例对象，通常指this,具体的一部部手机,所有的普通同步方法用的都是同一把锁——&gt;实例对象本身，</span></span><br><span class="line"><span class="comment"> * 对于静态同步方法，锁的是当前类的Class对象，如Phone.class唯一的一个模板</span></span><br><span class="line"><span class="comment"> * 对于同步方法块，锁的是 synchronized 括号内的对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * *  7-8</span></span><br><span class="line"><span class="comment"> *  *    当一个线程试图访问同步代码时它首先必须得到锁，正常退出或抛出异常时必须释放锁。</span></span><br><span class="line"><span class="comment"> *  *  *</span></span><br><span class="line"><span class="comment"> *  *  *  所有的普通同步方法用的都是同一把锁——实例对象本身，就是new出来的具体实例对象本身,本类this</span></span><br><span class="line"><span class="comment"> *  *  *  也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。</span></span><br><span class="line"><span class="comment"> *  *  *</span></span><br><span class="line"><span class="comment"> *  *  *  所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class</span></span><br><span class="line"><span class="comment"> *  *  *  具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的</span></span><br><span class="line"><span class="comment"> *  *  *  但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//一切程序的入口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒,保证a线程先启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line"><span class="comment">//            phone.hello();</span></span><br><span class="line"><span class="comment">//            phone2.sendSMS();</span></span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字节码角度分析Synchronized"><a href="#字节码角度分析Synchronized" class="headerlink" title="字节码角度分析Synchronized"></a>字节码角度分析Synchronized</h2><h3 id="查看反汇编："><a href="#查看反汇编：" class="headerlink" title="查看反汇编："></a>查看反汇编：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -c *.java<span class="comment">// -c对代码进行反汇编。 -v (verbose)输出附加信息行号，本地变量表，反汇编</span></span><br></pre></td></tr></table></figure>
<h3 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h3><ul>
<li>实现使用的是monitorenter和monitorexit。monitorenter代表获得锁对象，monitorexit代表释放锁对象。</li>
<li>通常情况下，一个monitorenter对应两个monitorexit，正常情况下，从第一个monitorexit释放锁。异常情况下，从第二个monitorexit释放锁。</li>
</ul>
<h3 id="synchronized普通同步方法"><a href="#synchronized普通同步方法" class="headerlink" title="synchronized普通同步方法"></a>synchronized普通同步方法</h3><p>调用指令时，先检查ACC_SYNCHRONIZED（Access）标志是否被设置了，如果该方法有这个标志，代表是同步方法，访问的时候要获取锁对象。<br>方法完成时（无论是否正常介数）释放锁。</p>
<h3 id="synchronized静态同步方法"><a href="#synchronized静态同步方法" class="headerlink" title="synchronized静态同步方法"></a>synchronized静态同步方法</h3><p>调用指令时，ACC_STATIC，和ACC_SYNCHRONIZED标志。第一个表示是否静态方法，第二个表示是否同步方法。</p>
<h3 id="反编译Synchronized锁是什么"><a href="#反编译Synchronized锁是什么" class="headerlink" title="反编译Synchronized锁是什么"></a>反编译Synchronized锁是什么</h3><p><strong>为什么任何一个对象都可以成为锁？</strong><br>Java虚拟机支持方法级<br><strong>什么是管程？</strong><br>管程（Monitor）:可以看做是一个功能模块，他将共享变量和对共享变量的操作封装起来。进程可以调用管程实现进程间的并发控制。<br><strong>同步指令实现？</strong><br>Java虚拟机支持<strong>方法级的同步</strong>和<strong>方法内部指令序列的同步</strong>，这两种同步结构都是由管程（Monitor或者称为锁）来实现的。</p>
<ul>
<li>方法级的同步：通过读取ACC_SYNCHRONIZED判断是否是同步方法，如果是同步方法，执行线程要求必须持有管程（锁）。执行完毕后释放锁。</li>
<li>方法内部指令序列的同步：同步一段指令序列是通过synchronized方法块来表示。java虚拟机指令集中的monitorenter和monitorexit指令实现的。</li>
</ul>
<h3 id="Monitor的实现-OjectMonitor"><a href="#Monitor的实现-OjectMonitor" class="headerlink" title="Monitor的实现 OjectMonitor"></a>Monitor的实现 OjectMonitor</h3><p>每个对象都关联一个ObjectMonitor锁对象。他有一些属性来保证该资源的同步安全。<br><img src="https://img-blog.csdnimg.cn/direct/87c532c89f8f44bab5635d3708516170.png" alt="在这里插入图片描述"><br>ower: 持有该锁的线程<br>waitset：存放处于wait状态的线程队列<br>entrylist：存放等待锁的线程队列<br>recursions（递归）：锁的重入次数<br>count: 记录该线程获取锁的次数。<br><img src="https://img-blog.csdnimg.cn/direct/ae6945e8743347b39f3e46a1febc72aa.png" alt="在这里插入图片描述"></p>
<h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><h2 id="公平锁-先来先得"><a href="#公平锁-先来先得" class="headerlink" title="公平锁(先来先得)"></a>公平锁(先来先得)</h2><p>多个线程按照线程请求锁的先后顺序获取锁。默认都是非公平锁，公平锁需要设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);/l/<span class="literal">true</span>表示公平锁,先来先得</span><br></pre></td></tr></table></figure>




<p><strong>执行流程：</strong><br>获取锁的时候，会将线程自己添加到等待队列中并休眠。当线程使用完锁之后，会去唤醒等待队列首部的线程。线程的休眠和恢复需要从用户态转换为内核态，线程切换是比较慢的，所以公平锁的执行较慢。</p>
<h2 id="非公平锁（随机获得锁，默认）"><a href="#非公平锁（随机获得锁，默认）" class="headerlink" title="非公平锁（随机获得锁，默认）"></a>非公平锁（随机获得锁，默认）</h2><p>每个线程获取到锁的顺序是随机的，并不会按照先来先得的顺序。所有的线程会竞争获取锁。<br><strong>执行流程：</strong><br>当线程申请锁时，会通过CAS尝试获取锁。如果获取成功，就持有锁对象。如果获取失败，就进入等待队列。好处是不用遵循先到先得的原则，避免了线程的休眠和恢复过程，执行更快。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>默认是非公平锁。能够让程序执行更快（追求效率）。<br>非公平锁可能造成线程饿死的情况。</p>
<h1 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>可重入锁又叫递归锁。一个线程在<strong>外部方法</strong>中获取到锁的时候。在进入内部方法需要获取锁的时候，线程会自动获取到该锁。而不会阻塞。</p>
<h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><h3 id="隐式锁（Synchronized关键字修饰的）："><a href="#隐式锁（Synchronized关键字修饰的）：" class="headerlink" title="隐式锁（Synchronized关键字修饰的）："></a>隐式锁（Synchronized关键字修饰的）：</h3><p>线程在外部获取锁之后，内部自动获取到锁。<br><strong>实现原理</strong><br>每个锁对象ObjectMonitor都有一个<strong>count计数器</strong>和<strong>ower</strong>持有该锁对象的线程。<br>当执行monitorenter的时候：会看count计数器是否为0，如果为0说明该锁对象没有被其他线程占有，将count计数器+1，将ower设置为当前的线程。如果不为0，该线程需要等待。<br>当执行monitorexit的时候：会将count计数器减一，count为0代表可以释放。将ower清空。</p>
<h3 id="显式锁（Lock实现类）"><a href="#显式锁（Lock实现类）" class="headerlink" title="显式锁（Lock实现类）"></a>显式锁（Lock实现类）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();<span class="comment">//加锁</span></span><br><span class="line">lock.unlock();<span class="comment">//解锁</span></span><br></pre></td></tr></table></figure>
<p>加锁和释放锁的次数要一样，不然会导致该线程一直持有锁。其他线程无法获取锁。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>一个线程持有某个锁对象，有需要申请其他的锁对象。其他锁对象被另一个线程占有。在无外力干扰的情况下，一直处于僵持状态。<br>举例： A线程持有obj1锁对象，申请obj2锁对象。B线程持有obj2锁对象，申请obj1锁对象。A，B线程均被阻塞住，处于僵持状态。</p>
<h2 id="手写一个死锁的例子"><a href="#手写一个死锁的例子" class="headerlink" title="手写一个死锁的例子"></a>手写一个死锁的例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + <span class="string">&quot;拿到了obj1锁对象&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;等待obj2锁对象...&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + <span class="string">&quot;拿到了obj2锁对象&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + <span class="string">&quot;拿到了obj2锁对象&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;等待obj1锁对象...&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + <span class="string">&quot;拿到了obj1锁对象&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/direct/eab87490f8dc409a9d71968088de3e24.png" alt="在这里插入图片描述"></p>
<h2 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h2><h3 id="第一种方式命令行jps-jstack"><a href="#第一种方式命令行jps-jstack" class="headerlink" title="第一种方式命令行jps+jstack"></a>第一种方式命令行jps+jstack</h3><p>jps查看死锁线程编号 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/direct/ef155509969849eb8adeb9d264bb1603.png" alt="在这里插入图片描述"><br>jstack 查看当前时刻的线程快照</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstack <span class="number">13992</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/direct/685a70dc8758458e933ea0f619e54237.png" alt="在这里插入图片描述"></p>
<h3 id="第二种jconsole图形化界面"><a href="#第二种jconsole图形化界面" class="headerlink" title="第二种jconsole图形化界面"></a>第二种jconsole图形化界面</h3><p><img src="https://img-blog.csdnimg.cn/direct/6c752cb44dbe477693ee6d0734b37518.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/bc3282df5403455a87a2afd8d3280d2c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/f8248749f36e495a8c621a1f2389360f.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-原子操作类（AtomicLong, AtomicLongArray,AtomicReferren,AtomicLongFiledUpdater）LongAdder</title>
    <url>/2024/01/25/JUC-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 



<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>多线程下使用原子类来保证线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>volatile能解决多线程并发安全中的可见性问题，但是不能解决原子性问题。<br>atomic原子类通过CAS+volatile来保证并发安全。CAS保证原子性，volatile保证原子性。</p>
<h1 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h1><p>原子类位于java.util.concurrent.atomic包下面。可以分为以下几类，<strong>基本类型的原子类，数组类型的原子类，引用类型的原子类和对象的属性修改原子类</strong>四类。</p>
<h2 id="2-1-基本类型原子类"><a href="#2-1-基本类型原子类" class="headerlink" title="2.1 基本类型原子类"></a>2.1 基本类型原子类</h2><p><strong>AtomicBoolean, AtomicInteger, AtomicLong</strong><br>常用的API:<br>获取值，自增，自减，CAS<br><img src="https://img-blog.csdnimg.cn/direct/efa87cd1c50440deadcf422e3f17ec3d.png" alt="在这里插入图片描述"><br>使用举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=<span class="number">1000</span>; j++) &#123;</span><br><span class="line">                        myNumber.addPlusPlus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待上面50个线程全部计算完成后，再去获得最终值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;result: &quot;</span>+myNumber.atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>补充：CountDownLatch计数器，可以使一个或多个线程等待其他线程执行完毕后再执行。<br>CountDownLatch定义了一个计数器和阻塞队列，当计数器减为0就唤醒阻塞队列中的线程。使用await（）方法主动将当前线程阻塞（放入阻塞队列中）</p>
<h2 id="2-2-数组类型原子类"><a href="#2-2-数组类型原子类" class="headerlink" title="2.2 数组类型原子类"></a>2.2 数组类型原子类</h2><p><strong>AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray</strong><br>常用的API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getAndSet(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><br><span class="line">getAndIncrement(<span class="type">int</span> i)</span><br><span class="line">getAndAdd(<span class="type">int</span> i, <span class="type">int</span> delta)</span><br></pre></td></tr></table></figure>
<h2 id="2-3-引用类型原子类"><a href="#2-3-引用类型原子类" class="headerlink" title="2.3 引用类型原子类"></a>2.3 引用类型原子类</h2><p>AtomicReference<br>原子引用类<br>AtomicStampedReference<br>原子邮戳（版本号）引用类，携带版本号的的原子引用。<br>AtomicMarkableReference<br>原子标记引用类，带标记（将版本号简化为true,false的标记）的原子引用。<br>常用API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMarked</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V       expectedReference,</span></span><br><span class="line"><span class="params">                                 V       newReference,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> expectedMark,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> newMark)</span></span><br></pre></td></tr></table></figure>
<h2 id="2-4-对象的属性修改原子类"><a href="#2-4-对象的属性修改原子类" class="headerlink" title="2.4 对象的属性修改原子类"></a>2.4 对象的属性修改原子类</h2><p><strong>AtomicIntegerFiledUpdater, AtomicLongFiledUpdater, AtomicReferenceFiledUpdater</strong><br>基于反射实现的，可以对volatile属性进行更新。<strong>因此需要更新的属性必须用volatile修饰。(volatile重要用法)</strong><br>常用的API</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;U&gt; <span class="title function_">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,String fieldName)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(T obj)</span> </span><br><span class="line"><span class="keyword">static</span> AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="title function_">newUpdater</span><span class="params">(Class&lt;U&gt; tclass,Class&lt;W&gt; vclass,String fieldName)</span><span class="comment">//如果是引用属性，需要传入引用属性的字节码对象</span></span><br></pre></td></tr></table></figure>
<p>举例： AtomicIntegerFiledUpdater</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span><span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">bankName</span> <span class="operator">=</span> <span class="string">&quot;CCB&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新的对象属性必须使用 public volatile 修饰符。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//钱数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        money++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须</span></span><br><span class="line">    <span class="comment">// 使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</span></span><br><span class="line"></span><br><span class="line">    AtomicIntegerFieldUpdater&lt;BankAccount&gt; fieldUpdater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不加synchronized，保证高性能原子性，局部微创小手术</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transMoney</span><span class="params">(BankAccount bankAccount)</span></span><br><span class="line">    &#123;</span><br><span class="line">        fieldUpdater.getAndIncrement(bankAccount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例： AtomicReferenceFiledUpdater</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyVar</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">isInit</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line"></span><br><span class="line">    AtomicReferenceFieldUpdater&lt;MyVar,Boolean&gt; referenceFieldUpdater =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,<span class="string">&quot;isInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(MyVar myVar)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (referenceFieldUpdater.compareAndSet(myVar,Boolean.FALSE,Boolean.TRUE))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----- start init,need 2 seconds&quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----- over init&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----- 已经有线程在进行初始化工作。。。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-原子操作增强类LongAdder-LongAccumulator"><a href="#3-原子操作增强类LongAdder-LongAccumulator" class="headerlink" title="3. 原子操作增强类LongAdder, LongAccumulator"></a>3. 原子操作增强类LongAdder, LongAccumulator</h1><p>在高并发的情况下,使用Atomic原子类会导致线程竞争的时候CAS操作自旋消耗CPU的性能，这个时候用LongAdder性能更好，代价是空间消耗更多，以空间换时间。<br>LongAdder只能加减法，且从0开始。<br>LongAccumulator更强大，可以自定义运算。</p>
<h2 id="3-1-LongAdder为什么这么快？"><a href="#3-1-LongAdder为什么这么快？" class="headerlink" title="3.1 LongAdder为什么这么快？"></a>3.1 LongAdder为什么这么快？</h2><p>在低并发无竞争的情况下跟AtomicLong一样，对同一个base操作。<br>当高并发的情况下：<br>LongAdder的核心思想就是以空间换时间，分散热点。在Atomic原子类的基础上将value值分散到多个cell中去（cell数组），不同的线程会命中不同的cell，每个线程对自己对应的cell进行操作，减少冲突从而减少CAS自旋。最后将各个celll中的变量累加返回即可。<br><img src="https://img-blog.csdnimg.cn/direct/5297990c1ad449c5863b23b2cc552f9b.png" alt="在这里插入图片描述"></p>
<h2 id="3-2-LongAdder使用"><a href="#3-2-LongAdder使用" class="headerlink" title="3.2 LongAdder使用"></a>3.2 LongAdder使用</h2><p>常用的API<br><img src="https://img-blog.csdnimg.cn/direct/f750d0a30c564fac948037dbd4b582f7.png" alt="在这里插入图片描述"><br>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdderAPIDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">        longAdder.increment();</span><br><span class="line">        longAdder.increment();</span><br><span class="line">        longAdder.increment();</span><br><span class="line">        System.out.println(longAdder.sum());</span><br><span class="line">        <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(<span class="keyword">new</span> <span class="title class_">LongBinaryOperator</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">applyAsLong</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> left + right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>);</span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line">        longAccumulator.accumulate(<span class="number">3</span>);<span class="comment">//4</span></span><br><span class="line">        System.out.println(longAccumulator.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="4-原子操作总结"><a href="#4-原子操作总结" class="headerlink" title="4. 原子操作总结"></a>4. 原子操作总结</h1><p>AtomicLong: 原理CAS+自旋+volatile。进行计数，能够保证并发安全。在高并发下，性能急剧下降，自旋操作影响性能。<br>LongAdder: 原理CAS+Base+Cell+volatile。进行计数，能够保证并发安全。在高并发下，性能也很好。但是空间消耗略大。</p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>复习sql-内连接，左外连接，右外连接，全外连接，交叉连接</title>
    <url>/2024/01/06/%E5%86%85%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 





<h1 id="数据表准备-学生表-和-课程表"><a href="#数据表准备-学生表-和-课程表" class="headerlink" title="数据表准备 学生表 和 课程表"></a>数据表准备 学生表 和 课程表</h1><p><img src="https://img-blog.csdnimg.cn/direct/312b27d4246a4a11be97d03ce8904cd9.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/3a5d0335686f48bf8648e99fe6e3115f.png" alt="在这里插入图片描述"></p>
<h1 id="内连接-join-或-innner-join"><a href="#内连接-join-或-innner-join" class="headerlink" title="内连接 join 或 innner join"></a>内连接 join 或 innner join</h1><p>筛选出满足条件的列，where也可以实现这种功能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">JOIN</span> course <span class="keyword">ON</span> student.student_id <span class="operator">=</span> course.stu_id</span><br></pre></td></tr></table></figure>
<p>结果<br><img src="https://img-blog.csdnimg.cn/direct/2491409e4183406e9a5ba0db88cc6a23.png" alt="在这里插入图片描述"></p>
<p>注： 如果不加where, 是笛卡尔积的结果，同交叉连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">JOIN</span> course 或者</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student, course</span><br></pre></td></tr></table></figure>



<h1 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h1><h2 id="左外连接-left-join-或者-left-outer-join"><a href="#左外连接-left-join-或者-left-outer-join" class="headerlink" title="左外连接 left join 或者 left outer join"></a>左外连接 left join 或者 left outer join</h2><p>以第一个表为基础，第二个表找不到的项就设置为NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course <span class="keyword">ON</span> student.student_id <span class="operator">=</span> course.stu_id</span><br></pre></td></tr></table></figure>
<p>结果<br><img src="https://img-blog.csdnimg.cn/direct/af30551ef1884f1d859c5f65efcbd593.png" alt="在这里插入图片描述"></p>
<h2 id="右外连接-right-join-或者-right-outer-join"><a href="#右外连接-right-join-或者-right-outer-join" class="headerlink" title="右外连接 right join 或者 right outer join"></a>右外连接 right join 或者 right outer join</h2><p>以第二个表为基础，第一个表找不到的项就设置为NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> course <span class="keyword">ON</span> student.student_id <span class="operator">=</span> course.stu_id</span><br></pre></td></tr></table></figure>
<p>结果<br><img src="https://img-blog.csdnimg.cn/direct/a81d167aea5e4447bfd4019c702ef9c1.png" alt="在这里插入图片描述"></p>
<h2 id="全外连接-full-join-或者-full-outer-join（SQL-Server有，MYSQL没有全外连接）"><a href="#全外连接-full-join-或者-full-outer-join（SQL-Server有，MYSQL没有全外连接）" class="headerlink" title="全外连接 full join 或者 full outer join（SQL Server有，MYSQL没有全外连接）"></a>全外连接 full join 或者 full outer join（SQL Server有，MYSQL没有全外连接）</h2><p>左外连接+右外连接的结果。<br><img src="https://img-blog.csdnimg.cn/direct/d6fdc58e1ae94bba8476f264862fcd12.png" alt="在这里插入图片描述"></p>
<h1 id="交叉连接（笛卡尔积）"><a href="#交叉连接（笛卡尔积）" class="headerlink" title="交叉连接（笛卡尔积）"></a>交叉连接（笛卡尔积）</h1><p>表1的每一行都与表2的每一行拼接。（笛卡尔积）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> course</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/direct/3ff86e5fc79d422f968df16ffe371ee1.png" alt="在这里插入图片描述"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/Duancf/p/11453611.html">通俗易懂的join、left join、right join、full join、cross join</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib快速入门</title>
    <url>/2021/01/25/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 



<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><ol>
<li>主要用于开发2D图表</li>
<li>数据分析，基于分析，进行展示</li>
</ol>
<h2 id="二、绘图流程"><a href="#二、绘图流程" class="headerlink" title="二、绘图流程"></a>二、绘图流程</h2><ol>
<li>创建画布</li>
<li>绘制图像</li>
<li>显示图像</li>
</ol>
<h2 id="三、折线图与基础绘图功能"><a href="#三、折线图与基础绘图功能" class="headerlink" title="三、折线图与基础绘图功能"></a>三、折线图与基础绘图功能</h2><h3 id="1-图形保存"><a href="#1-图形保存" class="headerlink" title="1.图形保存"></a>1.图形保存</h3><p>​	plt.savefig()</p>
<p>​	注意：图像保存一定要放到show前面</p>
<h3 id="2-添加X轴，y轴刻度"><a href="#2-添加X轴，y轴刻度" class="headerlink" title="2.添加X轴，y轴刻度"></a>2.添加X轴，y轴刻度</h3><p>​	plt.xticks</p>
<p>​	plt.yticks</p>
<p>​	注意：第一个参数必须是数字，如果不是数字，需要进行值替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">x_ticks=<span class="built_in">range</span>(<span class="number">6</span>)</span><br><span class="line">x_ticks_name=[<span class="string">&quot;&#123;&#125;min&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x_ticks]</span><br><span class="line">y_ticks=<span class="built_in">range</span>(<span class="number">6</span>)</span><br><span class="line">plt.xticks(x_ticks[::<span class="number">2</span>],x_ticks_name[::<span class="number">2</span>])<span class="comment"># 如果要设置字符串必须要第一个参数为行向量数字</span></span><br><span class="line">plt.yticks(y_ticks[::<span class="number">2</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="3-添加网格"><a href="#3-添加网格" class="headerlink" title="3.添加网格"></a>3.添加网格</h3><p>plt.grid()</p>
<p>参数：linestyle–绘制网格方式</p>
<p>​			alpha–透明度</p>
<h3 id="4-添加描述信息"><a href="#4-添加描述信息" class="headerlink" title="4.添加描述信息"></a>4.添加描述信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.xlabel(<span class="string">&quot;时间&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;温度&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;一小时温度变化图&quot;</span>，fontsize=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-多次plot"><a href="#5-多次plot" class="headerlink" title="5.多次plot"></a>5.多次plot</h3><p>直接绘制</p>
<h3 id="6-显示图例"><a href="#6-显示图例" class="headerlink" title="6.显示图例"></a>6.显示图例</h3><p>plt.legend()</p>
<p>注意：显示之前，声明plot里面的具体值。</p>
<h3 id="7-多个坐标系图像显示"><a href="#7-多个坐标系图像显示" class="headerlink" title="7.多个坐标系图像显示"></a>7.多个坐标系图像显示</h3><p>fig,axis&#x3D;plt.subplots()</p>
<p>参数：nrows–几行</p>
<p>​			ncols–几列</p>
<p>注意：有些方法需要添加set_*</p>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig,axis=plt.subplots(nrows=<span class="number">2</span>,ncols=<span class="number">2</span>)</span><br><span class="line">axis[<span class="number">0</span>][<span class="number">0</span>].plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">axis[<span class="number">0</span>][<span class="number">1</span>].plot([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">axis[<span class="number">1</span>][<span class="number">0</span>].plot([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">axis[<span class="number">1</span>][<span class="number">1</span>].plot([<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br></pre></td></tr></table></figure>

<h2 id="四、常见图像的绘制"><a href="#四、常见图像的绘制" class="headerlink" title="四、常见图像的绘制"></a>四、常见图像的绘制</h2><ul>
<li><p>折线图 plt.plot</p>
<p>变化</p>
</li>
<li><p>散点图 plt.scatter()</p>
<p>分布规律</p>
</li>
<li><p>柱状图 plt.bar()</p>
<p>统计、对比</p>
</li>
<li><p>直方图 plt.hist()</p>
<p>分布</p>
</li>
<li><p>饼图 plt.pie()</p>
<p>占比</p>
</li>
</ul>
<h2 id="官方API"><a href="#官方API" class="headerlink" title="官方API"></a>官方API</h2><p><a href="https://matplotlib.org/stable/plot_types/index.html">https://matplotlib.org/stable/plot_types&#x2F;index.html</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>C++字符串和数字相互转换(刷题必备)</title>
    <url>/2021/12/23/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2-%E5%88%B7%E9%A2%98%E5%BF%85%E5%A4%87/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="C-数字和字符串相互转换"><a href="#C-数字和字符串相互转换" class="headerlink" title="C++数字和字符串相互转换"></a>C++数字和字符串相互转换</h1><p>C++数字和字符串相互转换，此文详细介绍了两者互相转换的方法。通过内置函数和字符串流（对象）来实现转换。</p>
<h2 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h2><h3 id="方法1：to-string-函数"><a href="#方法1：to-string-函数" class="headerlink" title="方法1：to_string()函数"></a>方法1：to_string()函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">12345</span>;</span><br><span class="line">	string num_s = <span class="built_in">to_string</span>(num);<span class="comment">//转换</span></span><br><span class="line">	cout &lt;&lt; num_s.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法2：ostringstream对象-str-函数"><a href="#方法2：ostringstream对象-str-函数" class="headerlink" title="方法2：ostringstream对象+str()函数"></a>方法2：ostringstream对象+str()函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">12345</span>;</span><br><span class="line">	ostringstream oss;<span class="comment">//字符输出流对象</span></span><br><span class="line">	oss &lt;&lt; num;<span class="comment">//将数字放入输出流对象中</span></span><br><span class="line">	string num_s = oss.<span class="built_in">str</span>();<span class="comment">//将其转换成string</span></span><br><span class="line">	cout &lt;&lt; num_s.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符串转数字"><a href="#字符串转数字" class="headerlink" title="字符串转数字"></a>字符串转数字</h2><h3 id="方法1：atoi-函数"><a href="#方法1：atoi-函数" class="headerlink" title="方法1：atoi()函数"></a>方法1：atoi()函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">	<span class="type">int</span> str_int=<span class="built_in">stoi</span>(str.<span class="built_in">c_str</span>());<span class="comment">//字符转换成int</span></span><br><span class="line">	cout &lt;&lt; str_int + <span class="number">1</span> &lt;&lt; endl;<span class="comment">//加1，是数字才能+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法2：istringstream对象"><a href="#方法2：istringstream对象" class="headerlink" title="方法2：istringstream对象"></a>方法2：istringstream对象</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str= <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">	<span class="type">int</span> str_int;</span><br><span class="line">	<span class="function">istringstream  <span class="title">iss</span><span class="params">(str)</span></span>;<span class="comment">//字符串输入流对象</span></span><br><span class="line">	iss &gt;&gt; str_int;        <span class="comment">//字符串转换成int，通过输入流，将输入流中字符串的输入到int型就可以转换。</span></span><br><span class="line">	cout &lt;&lt; str_int + <span class="number">1</span> &lt;&lt; endl;<span class="comment">//加1，是数字才能+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p> <a href="http://c.biancheng.net/view/1527.html">http://c.biancheng.net/view/1527.html</a><br> <a href="https://www.bilibili.com/read/cv8350834">https://www.bilibili.com/read/cv8350834</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>初识context</title>
    <url>/2021/06/04/%E5%88%9D%E8%AF%86context/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信在学编程过程中许多小伙伴遇到过多次context这个单词吧，可它到底是是什么意思却有点犯迷糊。今天就来总结一下。加深一下对context的理解。</p>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>context，中文翻译上下文。所谓上下文就是一段程序运行成功所需要的外部环境的集合。因此，上下文也可以叫做环境。环境中主要指的是外部的变量。举个栗子，在程序运行过程中，需要外部的变量。那么必须将外部变量一个一个输入进去，程序才能正确执行。<br>上下文切换<br>所谓上下文切换就是环境的切换。什么的环境呢？程序的环境切换。比如一个程序切换到另一个程序，系统会进行环境的保存（比如将一些变量压入栈内），然后加载新程序的环境（比如将栈内的变量弹出，最后会放到context这个集合中）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://wenku.baidu.com/view/df311707ac45b307e87101f69e3143323968f5d1.html">https://wenku.baidu.com/view/df311707ac45b307e87101f69e3143323968f5d1.html</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是随机变量</title>
    <url>/2021/06/03/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="1-随机变量定义"><a href="#1-随机变量定义" class="headerlink" title="1.随机变量定义"></a>1.随机变量定义</h2><p>先搬科学定义<br>定义 设随机变量试验的样本空间为$S$ 。$X&#x3D;X(e)$是定义在样本空间的实值单值函数。称$X&#x3D;X(e)$为随机变量。</p>
<p>解释 </p>
<p>样本空间：就是试验中可能的取值。举个栗子，预测明天的天气情况如下：</p>
<table>
<thead>
<tr>
<th>天气</th>
<th>下雨</th>
<th>多云</th>
<th>晴天</th>
</tr>
</thead>
<tbody><tr>
<td>概率</td>
<td>0.3</td>
<td>0.5</td>
<td>0.2</td>
</tr>
</tbody></table>
<p>对于该表，样本空间$S$就是{下雨、多云、晴天}集合。</p>
<p>$X&#x3D;X(e)$为实值单值函数：啥叫实值单值函数？可以理解为一个值为实数的函数。</p>
<p>对于上面表格，e为天气的某一个取值，也就是说$e \in S$，$S$为前面提到的样本空间。$X&#x3D;X(e)$表示对样本空间一个取值进行一个映射。比如我可以将下雨-&gt;(映射到)1，多云-&gt;2,晴天-&gt;3。</p>
<p><strong>所以，何为随机变量，随机变量就是对样本空间值的一个映射。本质上就是一个函数。别人问你随机变量是什么的时候，你就可以跟他说是一个函数。听起来是不是很牛逼哈哈哈。</strong></p>
<p>为什么需要定义随机变量呢？是因为下雨多云晴天这种文字在数学中根本无法运算，为了在数学中能够参与运算，就将样本空间映射到实数范围内。还是为了能够计算哇。</p>
<h2 id="2-举例"><a href="#2-举例" class="headerlink" title="2.举例"></a>2.举例</h2><p>下面举个例子说明随机变量的应用</p>
<p>投一个骰子，X表示骰子的点数。问P(X&#x3D;3)为多少？</p>
<p>很简单，高中生都知道为3点的概率是$\frac{1}{6}$。</p>
<p>我们来科学的分析一下</p>
<p>$${\rm{p}}(X &#x3D; 3){\rm{ &#x3D; P}}({ e \in S|X(e) &#x3D; 3} )\  \ \ \ \   (1)$$ </p>
<p>这是根据$X&#x3D;X(e)$随机变量的定义来写的。但此题题目中有隐含映射条件:X表示骰子的点数.说明了X函数在$e$上的映射值就为$e$,即$X(e)&#x3D;e$ ,此问中将3点映射为实数3。所以（1）式子进而等于</p>
<p>$${\rm{p}}(X &#x3D; 3){\rm{ &#x3D; P}}({ 3点} )&#x3D;\frac{1}{6}$$ </p>
<h2 id="3-写在后面"><a href="#3-写在后面" class="headerlink" title="3.写在后面"></a>3.写在后面</h2><p>才疏学浅，可能解释得不是太清楚，参考视频如下，人民大学博士讲得通俗易懂。</p>
<p>参考视频：<a href="https://www.bilibili.com/video/av78972740">https://www.bilibili.com/video/av78972740</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 14- I. 剪绳子（C++暴力+动态规划、贪心解）</title>
    <url>/2021/12/21/%E5%89%91%E6%8C%87Offer14/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><h3 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a>剑指 Offer 14- I. 剪绳子</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure>

<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><h3 id="方法1-暴力-动态规划"><a href="#方法1-暴力-动态规划" class="headerlink" title="方法1 暴力+动态规划"></a>方法1 暴力+动态规划</h3><p>这道题剪绳子，我们用动态规划的思想去做。</p>
<ul>
<li>假设动态规划 f(i)表示i长的绳子切割后最大长度 $f(i)&#x3D;max((i-k)k,f(i-k)k))其中k&#x3D;[2,i)$，k表示第一段割下来的长度</li>
<li>依次从i长的绳子里面割j长的绳子.剩下的$(i-j)$长绳子可以不再分割:最大乘积就为$(i - j) * j$。</li>
<li>也可以再次分割，最大乘积就为:$j * dp[i - j]$。两者取最大。</li>
<li>而最外面的max是因为第一段可以割不同的$j$(暴力思想)，需要不断更新。</li>
</ul>
<h3 id="方法2-贪心算法"><a href="#方法2-贪心算法" class="headerlink" title="方法2 贪心算法"></a>方法2 贪心算法</h3><ul>
<li><p>要考虑尽可能每一段都要分隔成3的长度。</p>
</li>
<li><p>将特殊情况绳长小于等于3情况的去除掉</p>
</li>
<li><p>将绳长大于4的情况，不断切割下3的绳子，可能最后剩下4，3,2，剩下的正好作为单独一段。</p>
</li>
<li><p><strong>注意：</strong>这里为什么条件是大于4，而不是大于当于4。因为如果等于4，那么4就会在被分隔成3+1 ，这两段乘积3x1&#x3D;3。我们知道4切割后最大的乘积应该是2x2&#x3D;4。因此我们这里干脆将条件设为大于4，那么最后就可能剩下一段绳子长度为4。正好符合4切割后的最大乘积4。</p>
</li>
</ul>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="方法1-暴力-动态规划-1"><a href="#方法1-暴力-动态规划-1" class="headerlink" title="方法1 暴力+动态规划"></a>方法1 暴力+动态规划</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：剑指 Offer 14- I. 剪绳子</span></span><br><span class="line"><span class="comment">* 描述：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。</span></span><br><span class="line"><span class="comment">	  请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，</span></span><br><span class="line"><span class="comment">	  此时得到的最大乘积是18</span></span><br><span class="line"><span class="comment">* 实现:暴力+动态规划 f(i)表示i长的绳子切割后最大长度 f(i)=max((i-k)*k,f(i-k)*k)) 其中k=[2,i)，表示第一段割下来的长度</span></span><br><span class="line"><span class="comment">		1.依次从i长的绳子里面割j长的绳子.剩下的(i-j)长绳子可以不再分割:最大乘积(i - j) * j。</span></span><br><span class="line"><span class="comment">		2.也可以再次分割:j * dp[i - j]。两者取最大。</span></span><br><span class="line"><span class="comment">		3.而外面max是因为第一段可以割不同的j(暴力思想)，需要不断更新。</span></span><br><span class="line"><span class="comment">* 复杂度：时间O(n^2): 循环次数 1+2+....+n-2=(n-1)*(n-2)/2</span></span><br><span class="line"><span class="comment">*		 空间 O(n)：线性辅助空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* dp = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//初始值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//依次从i长的绳子里面割j长的绳子.剩下的(i-j)长绳子可以不再分割:最大乘积(i - j) * j。</span></span><br><span class="line">		<span class="comment">//也可以再次分割:j * dp[i - j]。两者取最大。</span></span><br><span class="line">		<span class="comment">//而外面max是因为第一段可以割不同的j，需要不断更新。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>((i - j) * j, j * dp[i - j]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法2-贪心算法-1"><a href="#方法2-贪心算法-1" class="headerlink" title="方法2 贪心算法"></a>方法2 贪心算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 题目：剑指 Offer 14- I. 剪绳子</span></span><br><span class="line"><span class="comment">	* 描述：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。</span></span><br><span class="line"><span class="comment">		  请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，</span></span><br><span class="line"><span class="comment">		  此时得到的最大乘积是18</span></span><br><span class="line"><span class="comment">	* 实现:贪心算法。每一段都要分隔成3</span></span><br><span class="line"><span class="comment">	* 复杂度：时间O(logn):大约执行x次，3^x=n，所以x=log3(n)</span></span><br><span class="line"><span class="comment">	*		 空间 O(1)：常数辅助空间</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">cuttingRopeA</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">			res = res * <span class="number">3</span>;</span><br><span class="line">			n = n - <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res * n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>这道题核心是想到用动态规划的思想来做。可能第二种贪心算法在有限时间内不容易证明出来，但是第一种动态规划思想还是比较常见，应该要会掌握。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 62. 圆圈中最后剩下的数字思路推导（约瑟夫环、DP、递归）</title>
    <url>/2021/11/23/%E5%89%91%E6%8C%87Offer41%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-%E5%9B%BE%E8%A7%A3%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%B1%82%E4%B8%AD%E4%BD%8D%E6%95%B0(%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F)/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 



<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><h3 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41 数据流中的中位数"></a>剑指 Offer 41 数据流中的中位数</h3><h3 id="题目详细描述"><a href="#题目详细描述" class="headerlink" title="题目详细描述"></a>题目详细描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 的中位数是 <span class="number">3</span></span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>] 的中位数是 (<span class="number">2</span> + <span class="number">3</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><ol>
<li><h4 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h4><p>求一个数据流的中位数，咋一看很简单。我们下意识的会想到直接用排序的方法，在每次查找中位数的时候，进行排序（快排，堆排，冒泡等皆可），利用中位数下标定位并返回中位数结果。但是这种方法对于频繁的求中位数，需频繁进行排序，时间复杂度太高，会超出时间限制。</p>
</li>
<li><h4 id="堆堆求中位数方法"><a href="#堆堆求中位数方法" class="headerlink" title="堆堆求中位数方法"></a>堆堆求中位数方法</h4><h6 id="数据结构准备"><a href="#数据结构准备" class="headerlink" title="数据结构准备"></a>数据结构准备</h6><p><img src="https://img-blog.csdnimg.cn/4a5e05d2d45049b3930c82e4b67af64f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>因为要求中位数，我们将数据分为两份，分别放在两个堆中。（利用堆顶具有该数据中最大或者最小值，也就是将整个数据流的<strong>分界线</strong>找到）</p>
<ol>
<li><p>大数据堆：较大的数据，放在小顶堆（保证堆顶是大数据中最小值）</p>
</li>
<li><p>小数据堆：较小的数据，放在大顶堆（保证堆顶是小数据中最大值）<br>  <img src="https://img-blog.csdnimg.cn/359d07bf794f4789bd10ec84d312057a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>  <strong>注意大数据堆和大顶堆的区别，大数据堆指的是存放两部分中较大的数据。上面看懂了可以忘掉大顶堆小顶堆，知道大数据堆和小数据堆即可，避免混淆</strong></p>
</li>
</ul>
</li>
</ol>
<ul>
<li><h6 id="如何添加元素"><a href="#如何添加元素" class="headerlink" title="如何添加元素"></a>如何添加元素</h6><p>1.当两个堆长度相等时，向<strong>大数据</strong>堆添加元素num（向小数据堆添加也可，同理）。添加时需注意得先向<strong>小数据</strong>堆添加num，由<strong>小数据</strong>堆重新得到堆顶最大值，将该值压入大数据堆。此举是为了保证新添加的元素先进入<strong>小数据</strong>堆，再由小数据堆选拔出<strong>最大值</strong>，送入<strong>大数据</strong>堆，保证两个堆顶依然是数据流的<strong>分界线</strong>。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sMizPHmC-1637656336026)(D:\桌面\添加元素举例.png)]</p>
<p>2.当两个堆长度不等时，也就是大数据堆长度大于小数据堆。向小数据堆添加元素。同理，先向大数据堆添加，由大数据堆选拔出最小元素送入小数据堆。保证两个堆顶依然是分界线。</p>
<p>​</p>
</li>
<li><h6 id="如何获取中位数"><a href="#如何获取中位数" class="headerlink" title="如何获取中位数"></a>如何获取中位数</h6><p>1.当两个堆长度相等时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * (maxHeap.<span class="built_in">top</span>()+minHeap.<span class="built_in">top</span>());</span><br></pre></td></tr></table></figure>

<p>2.当两个堆长度不等时，也就是大数据堆长度大于小数据堆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> maxHeap.<span class="built_in">top</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结方法"><a href="#总结方法" class="headerlink" title="总结方法:"></a>总结方法:</h3><p>优先队列、堆排序</p>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 题目：剑指 Offer 41. 数据流中的中位数</span></span><br><span class="line"><span class="comment">	* 描述：</span></span><br><span class="line"><span class="comment">	* 方法：利用两个堆实现</span></span><br><span class="line"><span class="comment">	* 实现:</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; maxHeap;<span class="comment">//大顶堆，存放小数据，大的在栈顶。</span></span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;<span class="comment">//小顶堆，存放大数据，小的在栈顶。</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MedianFinderB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* </span></span><br><span class="line"><span class="comment">	* 1.建立两个堆，左边小根堆存放大值（栈顶是大值中最小的），右边大根堆存放小值（栈顶是小值中最大的）。左边堆栈顶和右边堆栈顶就是所有值的分界线。</span></span><br><span class="line"><span class="comment">	* 2.两边堆长度相等时。向左边堆添加元素，但是需要先添加到右边堆，然后将右边堆栈顶的元素转移至左边堆。</span></span><br><span class="line"><span class="comment">		保证左边堆栈顶和右边堆栈顶元素大小顺序是连续的。</span></span><br><span class="line"><span class="comment">	* 3.在两边堆长度不相等的时候（一定是左边大于右边）。向右边堆添加元素，但是需要先向左边堆添加元素，然后将左边堆</span></span><br><span class="line"><span class="comment">		栈顶最大元素移到右边堆。此时保证左边堆栈顶和右边堆栈顶元素大小顺序是连续的。</span></span><br><span class="line"><span class="comment">	* </span></span><br><span class="line"><span class="comment">	* </span></span><br><span class="line"><span class="comment">	* </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addNumB</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() == minHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">			<span class="type">int</span> minVal = minHeap.<span class="built_in">top</span>();</span><br><span class="line">			minHeap.<span class="built_in">pop</span>();</span><br><span class="line">			maxHeap.<span class="built_in">push</span>(minVal);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			maxHeap.<span class="built_in">push</span>(num);</span><br><span class="line">			<span class="type">int</span> maxVal = maxHeap.<span class="built_in">top</span>();</span><br><span class="line">			maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">			minHeap.<span class="built_in">push</span>(maxVal);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">findMedianB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() == minHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0.5</span> * (maxHeap.<span class="built_in">top</span>()+minHeap.<span class="built_in">top</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> maxHeap.<span class="built_in">top</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 65. 不用加减乘除做加法（位运算、递归、迭代）</title>
    <url>/2021/12/18/%E5%89%91%E6%8C%87Offer65/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><h3 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a>剑指 Offer 65. 不用加减乘除做加法</h3><ol>
<li><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3></li>
</ol>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: a = 1, b = 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: a = -1, b = -1</span><br><span class="line">输出: -2</span><br></pre></td></tr></table></figure>

<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>这道题不能用加减乘除来做，那么只能用位运算了。我们先考虑a和b为一位二进制数，通过查看a+b来找规律，表格如下：</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">sum</th>
<th align="center">carry</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>所以可以得到：<br>$$<br>sum&#x3D;a \bigoplus b\<br>carry&#x3D;a&amp;b<br>$$<br>因此<br>$$<br>a+b&#x3D;sum+(carry&lt;&lt;1)&#x3D;a \bigoplus b +((a&amp;b)&lt;&lt;1)(1)<br>$$<br>注意这里carry要左移一位，计算机内部最高位为符号位。carry左移1位让它变成符号位。</p>
<p>将a+b转换成$a \bigoplus b +((a&amp;b)&lt;&lt;1) $后，中间还是有$+$号，因此需要继续通过等式(1)转换，直到b等于0，才能得到结果是a（a+b如果b等于0，那么结果就是a，相当于b一旦等于0，就可以消除加号了）</p>
<p>期望在不断转换过程中b等于0，我们可以用递归方法和迭代来做。</p>
<p>有了这个规律后，将其推广至任意位数的a和b都可。所以，能够推出公式（1）为此题核心。</p>
<h3 id="方法1递归"><a href="#方法1递归" class="headerlink" title="方法1递归"></a>方法1递归</h3><p>此方法思路简单，直接看下文代码即可理解。</p>
<h3 id="方法2迭代"><a href="#方法2迭代" class="headerlink" title="方法2迭代"></a>方法2迭代</h3><p>设置sum和carry变量，利用公式进行不断进行更新迭代，直到carry等于0，结果就是sum。此方法思路简单，直接看下文代码即可理解。</p>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="方法1递归-1"><a href="#方法1递归-1" class="headerlink" title="方法1递归"></a>方法1递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：面试题65. 不用加减乘除做加法</span></span><br><span class="line"><span class="comment">* 描述：</span></span><br><span class="line"><span class="comment">* 实现:位运算+递归。1.通过sum=a^b  carry=（a &amp; b）&lt;&lt;1</span></span><br><span class="line"><span class="comment">*		     2.a+b转换为sum+carry 因为不能用加号，所以sum+carry 再次经过步骤1，可以用递归实现，递归出口当carry=0,直接返回结果sum</span></span><br><span class="line"><span class="comment">* 复杂度：时间O(1):最差情况下（例如 a =a= 0x7fffffff , b = 1时），需循环 32 次，使用 O(32) 时间。</span></span><br><span class="line"><span class="comment">*		 空间 O(1)：递归栈有O(32)常数层辅助空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sum = a ^ b;</span><br><span class="line">	<span class="type">int</span> carry = (<span class="type">unsigned</span> <span class="type">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;<span class="comment">//加unsigned int只是因为leetcode评测平台不支持负数移位</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">add</span>(sum, carry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2迭代-1"><a href="#方法2迭代-1" class="headerlink" title="方法2迭代"></a>方法2迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：面试题65. 不用加减乘除做加法</span></span><br><span class="line"><span class="comment">* 描述：</span></span><br><span class="line"><span class="comment">* 实现:位运算+迭代。1.通过sum=a^b  carry=（a &amp; b）&lt;&lt;1</span></span><br><span class="line"><span class="comment">*		     2.a+b转换为sum+carry 因为不能用加号，所以sum+carry 再次经过步骤1迭代。知道carry等于0，结果就是sum。（a+b=sum+0）</span></span><br><span class="line"><span class="comment">* 复杂度：时间O(1): 最差情况下（例如 a =a= 0x7fffffff , b = 1时），需循环 32 次，使用 O(32) 时间。</span></span><br><span class="line"><span class="comment">*		 空间 O(1)：常数辅助空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">addA</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> sum, carry;</span><br><span class="line">		<span class="keyword">while</span> (b!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sum = a ^ b;</span><br><span class="line">			carry = (<span class="type">unsigned</span> <span class="type">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;<span class="comment">//加unsigned int只是因为leetcode评测平台不支持负数移位</span></span><br><span class="line">			b = carry;</span><br><span class="line">			a = sum;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>这道题需要记住的是加法运算如何转换为位运算。两个要点</p>
<ul>
<li>通过真值表找规律（有点数字信号真值表找表达式的意思）</li>
<li>找到表达式之后还是有加号，想办法把加号继续去掉。此题采用的递归。就是不断重复该转换方法。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先（二叉搜索树性质、迭代、递归）</title>
    <url>/2021/12/25/%E5%89%91%E6%8C%87offer58/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 



<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><h3 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1bb605a5e177a826c9bd6a39ea29302d.png"></p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>这道题是一道leetcode简单题。但是一拿到题的时候有点蒙圈。题目条件限定二叉搜索树，我们就要好好理解到二叉搜索树的概念，左子树小于右子树，更要会灵活应用。</p>
<p>对于此题，我们要思考二叉搜索树中任意两节点p,q的最近公共祖先Ancestor。他们之间有什么特性？</p>
<p>很容易发现  p、q一定是parent的左右子树（将p、q任一等于Ancestor作为特例，先不考虑）。<strong>由二叉搜索树中又可以得到左子树&lt;Ancestor&lt;右子树</strong>。我们根据此性质来搜索二插树，遍历的每个节点设为root</p>
<p>有下面三种情况：</p>
<ul>
<li>p,q都小于root，那么p,q一定在root左子树上，Ancestor也在root的左子树上，因此root&#x3D;root.left，往左边搜索</li>
<li>p,q都大于root，那么p,q一定在root右子树上，Ancestor也在root的右子树上，因此root&#x3D;root.left，往右边搜索</li>
<li><strong>p，q一大一小（相对于root）或者有任意节点等于root,那么Ancestor&#x3D;root</strong></li>
</ul>
<p>迭代、递归都可以实现上面的方法，分析想到怎么利用搜索树的性质比较难，只要将这三类分类好后，代码实现不成问题。</p>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="方法1-迭代"><a href="#方法1-迭代" class="headerlink" title="方法1  迭代"></a>方法1  迭代</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</span></span><br><span class="line"><span class="comment">* 描述：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span></span><br><span class="line"><span class="comment">* 实现:迭代。根据二搜索树定义来做。</span></span><br><span class="line"><span class="comment">* 复杂度：时间O(N):二叉树退化成链表，需要O(N)</span></span><br><span class="line"><span class="comment">*		 空间 O(1)：常数辅助空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) root = root-&gt;left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) root = root-&gt;right;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2-递归"><a href="#方法2-递归" class="headerlink" title="方法2 递归"></a>方法2 递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</span></span><br><span class="line"><span class="comment">* 描述：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span></span><br><span class="line"><span class="comment">* 实现:递归（根据二叉搜索树定义来做）</span></span><br><span class="line"><span class="comment">* 复杂度：时间O(N):二叉树退化成链表，需要O(N)</span></span><br><span class="line"><span class="comment">*		 空间 O(N)：线性辅助空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestorA</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestorA</span>(root-&gt;left, p, q);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestorA</span>(root-&gt;right, p, q);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>二叉搜索树的性质我们都知道，但是灵活应用性质我们需要积累经验。</p>
<p>这道题告诉我们二叉搜索树任意两个节点的最小公共祖先节点可以判断p,q位列root节点的左右子树来快速得到。<br>索树的性质我们都知道，但是灵活应用性质我们需要积累经验。</p>
<p>这道题告诉我们二叉搜索树任意两个节点的最小公共祖先节点可以判断p,q位列root节点的左右子树来快速得到。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 43. 1～n 整数中 1 出现的次数(纵向求解、组合思想、找规律)</title>
    <url>/2021/12/22/%E5%89%91%E6%8C%87offer43/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><h3 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数"></a>剑指 Offer 43. 1～n 整数中 1 出现的次数</h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><h3 id="方法1-暴力（横向求法）"><a href="#方法1-暴力（横向求法）" class="headerlink" title="方法1 暴力（横向求法）"></a>方法1 暴力（横向求法）</h3><p>暴力遍历小于等于n的所有数，针对每一个数字，求其所有位数上1的个数（对每个数字进行横向计数）。但是此方法时间复杂度随着n的增大会变大。时间复杂度过高，导致超时。这种方法不可取。</p>
<h3 id="方法2-纵向求法-数学规律（组合思想）"><a href="#方法2-纵向求法-数学规律（组合思想）" class="headerlink" title="方法2  纵向求法+数学规律（组合思想）"></a>方法2  纵向求法+数学规律（组合思想）</h3><p>这道题要求1到n中1出现的个数。我们有两种宏观思路。</p>
<ul>
<li><p>第一种是从局部，针对每一个数，判断该数所有位数（横向），将该数字中出现1的个数计算完。再去计算下一个数出现的1的个数，直到计算到n。（方法1）</p>
</li>
<li><p>第二种是针对某一位，求取小于等于n所有数字该位为1的个数和（纵向）。再将所有位置1的总和加起来，就是结果了。（方法2）</p>
<p>这道题思路主要介绍纵向求法。下面举例针对n的某一位cur来分析。</p>
<p>举例,cur为index为1上的数。要求index为1上的1个数总和，先看看小于等于n里面的数有哪些满足,分情况讨论</p>
<ol>
<li><p>cur&#x3D;$\color{red}{0}$    假设 n&#x3D;   2  3   $\color{red}{0}$   4</p>
<ul>
<li><p>（00-22） $\color{red}{1}$ （0-9）：总共有（22-0+1）*（9-0+1）种组合</p>
<p> 也即：高位23x10</p>
</li>
</ul>
</li>
<li><p>cur&#x3D;$\color{red}{1}$    假设 n&#x3D;   2  3   $\color{red}{1}$   4</p>
<ul>
<li><p>（00-22） $\color{red}{1}$ （0-9）：总共有（22-0+1）<em>（9-0+1）种组合</em></p>
<p>   也即：高位23x10</p>
</li>
<li><p>​     （23） $\color{red}{1}$ （0-4）：总共有4-0+1种组合</p>
<p>   也即：低位+1</p>
<p>所以该种情况为：高位23x10+低位+1</p>
</li>
</ul>
</li>
<li><p>cur&#x3D;$\color{red}{2}$  （2-9一样）  假设 n&#x3D;   2  3   $\color{red}{2}$   4</p>
<ul>
<li><p>（00-22） $\color{red}{1}$ （0-9）：总共有（22-0+1）<em>（9-0+1）种组合</em></p>
<p>也即：高位23x10</p>
</li>
<li><p>​     （23） $\color{red}{1}$ （0-9）：总共有9-0+1种组合</p>
<p>也即：10</p>
<p>所以该种情况为：高位23x10+10&#x3D;（高位+1）x10</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="方法1-暴力（横向求法）-1"><a href="#方法1-暴力（横向求法）-1" class="headerlink" title="方法1 暴力（横向求法）"></a>方法1 暴力（横向求法）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：剑指 Offer 43. 1～n 整数中 1 出现的次数</span></span><br><span class="line"><span class="comment">* 描述：输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</span></span><br><span class="line"><span class="comment">* 实现: 暴力（超出时间限制）</span></span><br><span class="line"><span class="comment">* 复杂度：时间O(n)</span></span><br><span class="line"><span class="comment">*		 空间 O(1)：常数辅助空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		t = i;</span><br><span class="line">		<span class="keyword">while</span> (t&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (t % <span class="number">10</span> == <span class="number">1</span>)count++;</span><br><span class="line">			t = t / <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法2-纵向求法-数学规律（组合思想）-1"><a href="#方法2-纵向求法-数学规律（组合思想）-1" class="headerlink" title="方法2 纵向求法+数学规律（组合思想）"></a>方法2 纵向求法+数学规律（组合思想）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：剑指 Offer 43. 1～n 整数中 1 出现的次数</span></span><br><span class="line"><span class="comment">* 描述：输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</span></span><br><span class="line"><span class="comment">* 实现: 数学找规律</span></span><br><span class="line"><span class="comment">* 复杂度：时间O(logn):循环求n的个数logn。再次logn求解res。一共2xlogn.</span></span><br><span class="line"><span class="comment">*		 空间 O(1)：常数辅助空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countDigitOneA</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>,t=n,bitNum=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> low, high;</span><br><span class="line">	<span class="type">int</span> cur;</span><br><span class="line">	<span class="comment">//计算n有多少位</span></span><br><span class="line">	<span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		t = t / <span class="number">10</span>;</span><br><span class="line">		bitNum++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bitNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		low = n % <span class="built_in">long</span>(<span class="built_in">pow</span>(<span class="number">10</span>, i));</span><br><span class="line">		high = n / <span class="built_in">long</span>(<span class="built_in">pow</span>(<span class="number">10</span>,i+<span class="number">1</span>));<span class="comment">//防止溢出</span></span><br><span class="line"></span><br><span class="line">		cur = <span class="built_in">int</span>(n / (<span class="built_in">pow</span>(<span class="number">10</span>, i))) % <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (cur == <span class="number">0</span>) res += (high*<span class="built_in">pow</span>(<span class="number">10</span>, i));</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) res += (high*<span class="built_in">pow</span>(<span class="number">10</span>, i)+low+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> res += ((high+<span class="number">1</span>) * <span class="built_in">pow</span>(<span class="number">10</span>, i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>这道题横向思考我们很容易想到。也就是针对某个数先把他所有位数上的1都求了。</p>
<p>但是纵向思路我们不容易想到。也就是针对某一位，先把所有满足数的1的求了。再求其他位上出现的所有1.</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 62. 圆圈中最后剩下的数字思路推导（约瑟夫环、DP、递归）</title>
    <url>/2021/12/11/%E5%89%91%E6%8C%87offer45%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%EF%BC%88%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p> 一、题目</p>
<h2 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure>



<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>

<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><h3 id="1-方法1-暴力组合法"><a href="#1-方法1-暴力组合法" class="headerlink" title="1.方法1:暴力组合法"></a>1.方法1:暴力组合法</h3><p>我们可能下意识会想到用DFS求组合的方法，将所有情况暴力枚举出来。然后再比较得到最小的组合方法。</p>
<p>时间复杂度：组合O(n！)+  比较O(n) </p>
<p>空间复杂度：O(n)</p>
<p>时间复杂度太高，此方法是下策，所以我们暂时不考虑用此种方法。</p>
<h3 id="2-方法2：排序法"><a href="#2-方法2：排序法" class="headerlink" title="2.方法2：排序法"></a>2.方法2：排序法</h3><p>此题难点就是考虑将其转换成排序问题。题目要求的是数组组合成最小的数，问题就是如何将数组组合才能使其最小。</p>
<p>我们定义了一种排序规则：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">x,y是数组两个数。如果组合xy&lt;yx，那么x<span class="tag">&lt;<span class="name">y</span></span></span><br><span class="line"><span class="tag"><span class="attr">x</span>,<span class="attr">y是数组两个数</span>。<span class="attr">如果组合yx</span>&lt;<span class="attr">xy</span>，<span class="attr">那么y</span>&lt;<span class="attr">x</span></span></span><br></pre></td></tr></table></figure>

<p>定义了该规则后，将整个数组从小到大排序就能得到数组最小数组合了。</p>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="1-自己写快排（自己造轮子）"><a href="#1-自己写快排（自己造轮子）" class="headerlink" title="1.自己写快排（自己造轮子）"></a>1.自己写快排（自己造轮子）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：剑指 Offer 45. 把数组排成最小的数</span></span><br><span class="line"><span class="comment">* 描述：</span></span><br><span class="line"><span class="comment">* 方法：定义判断规则，任意两个字符串如果有xy&lt;yx，那么x就应该放在前面，然后用快速排序</span></span><br><span class="line"><span class="comment">* 实现:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">string <span class="title">minNumberA</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//利用快速排序</span></span><br><span class="line">	<span class="built_in">QuikSortA</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums);</span><br><span class="line">	string res;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">		res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">to_string</span>(a) + <span class="built_in">to_string</span>(b) &lt; <span class="built_in">to_string</span>(b) + <span class="built_in">to_string</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partitionA</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> first, <span class="type">int</span> last)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> privot = nums[first];</span><br><span class="line">	<span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">		<span class="keyword">while</span> (first &lt; last &amp;&amp; !<span class="built_in">myCompare</span>(nums[last], privot)) &#123;</span><br><span class="line">			--last;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[first] = nums[last];</span><br><span class="line">		<span class="keyword">while</span> (first &lt; last &amp;&amp; <span class="built_in">myCompare</span>(nums[first], privot)) &#123;</span><br><span class="line">			++first;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[last] = nums[first];</span><br><span class="line">	&#125;</span><br><span class="line">	nums[first] = privot;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuikSortA</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &gt;= high)<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = <span class="built_in">partitionA</span>(nums, low, high);</span><br><span class="line">	<span class="built_in">QuikSortA</span>(low, mid - <span class="number">1</span>, nums);</span><br><span class="line">	<span class="built_in">QuikSortA</span>(mid + <span class="number">1</span>, high, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-利用内置函数实现排序"><a href="#2-利用内置函数实现排序" class="headerlink" title="2.利用内置函数实现排序"></a>2.利用内置函数实现排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：剑指 Offer 45. 把数组排成最小的数</span></span><br><span class="line"><span class="comment">* 描述：</span></span><br><span class="line"><span class="comment">* 方法：同上，用内置函数sort实现快速排序</span></span><br><span class="line"><span class="comment">* 实现:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">string <span class="title">minNumberB</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	string res;</span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)-&gt;<span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">to_string</span>(a) + <span class="built_in">to_string</span>(b) &lt; <span class="built_in">to_string</span>(b) + <span class="built_in">to_string</span>(a);</span><br><span class="line">		&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</span><br><span class="line">		res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(i));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>此题核心是知道怎么转换成排序问题。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 62. 圆圈中最后剩下的数字思路推导（约瑟夫环、DP、递归）</title>
    <url>/2021/12/25/%E5%89%91%E6%8C%87offer62/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><h4 id="剑指-Offer-62-圆圈中最后剩下的数字（约瑟夫环、DP、递归）"><a href="#剑指-Offer-62-圆圈中最后剩下的数字（约瑟夫环、DP、递归）" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字（约瑟夫环、DP、递归）"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a>（约瑟夫环、DP、递归）</h4><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>这是一道典型的约瑟夫环问题。n个数字，每次删除第m个数字，求最后剩下的一个数字是多少。</p>
<p>我们用动态规划的思想去做这道题。首先假设 f(n,m)表示剩下的数字（可理解为最后一次删除后，剩下的数）。动态规划的思想就是要找f(n,m)和f(n-1,m)之间的关系，称为状态转换式。</p>
<p>先看f(n,m)中有n个数字，要每次删除m个数字。我们将其一步一步分解，看分解的子过程中有没有可以调用自身函数的小过程（递归思想）。</p>
<ul>
<li><p>f(n,m)：我们先第一次删除第m个数字即(m-1)后，下一次删除的<strong>起始元素是m</strong>（序列如下）。由于m可能大于n，所以起始元素表示为<strong>m%n</strong>。</p>
<p>0  1  2  3  4  5 … m-2    m-1（删除）  <font color="green"><strong>m</strong>(下一次起点)</font>    m+1  …  n-2     n-1</p>
</li>
<li><p><strong>之后在n-1个数字序列中，起始元素为m%n，再不断删除m个数字</strong>(序列如下)</p>
<p> <font color="red"><strong>m</strong>(下一次起点)</font>    m+1  …   n-2   n-1   0    1   2   3   4   5  …   m-2  （序列1）</p>
<p>发现此处有符合递归的性质。为了找出递推式，我们将找其和f(n-1,m)的关系。</p>
</li>
<li><p>我们先分析f(n-1,m):<strong>表示有n-1个数字，起始元素为0，再不断删除m个数字</strong>(序列如下)</p>
<p>  <font color="red">0</font>      1     2      3    4       5 … m-2    m-1（删除）  <strong>m</strong>  m+1  …  n-2（序列2） </p>
</li>
<li><p>由序列1和序列2映射关系可知，序列2加上m%n就对应到序列1<br>$$<br>f(n-1,m)+（m % n）&#x3D;序列1的功能<br>$$<br>要保证映射转换过程一直在[0,n-1]范围内，所以要取余n，因此状态转换表达式为<br>$$<br>f(n,m)&#x3D;(f(n-1,m)+(m % n) )% n&#x3D;(f(n-1,m)+m )% n<br>$$<br>初始条件为:<br>$$<br>f(1,m)&#x3D;0<br>$$</p>
</li>
</ul>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="方法-迭代、递归"><a href="#方法-迭代、递归" class="headerlink" title="方法 迭代、递归"></a>方法 迭代、递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 题目：剑指 Offer 62. 圆圈中最后剩下的数字</span></span><br><span class="line"><span class="comment">* 描述：0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</span></span><br><span class="line"><span class="comment">* 实现:dp动态规划  </span></span><br><span class="line"><span class="comment">*         f(n,m) = [ (m % n) + f(n-1 , m) ] % n =( f(n-1, m) + m)%n </span></span><br><span class="line"><span class="comment">         初始条件：f(n,1) = n-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 复杂度：递归：时间O(N)：递归需要执行N次</span></span><br><span class="line"><span class="comment">*			  空间 O(N)：递归栈空间消耗N的辅助空间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*        迭代：时间O(N)：循环消耗线性辅助空间</span></span><br><span class="line"><span class="comment">*			  空间 O(1)：常量辅助空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">return</span> (m+<span class="built_in">lastRemaining</span>(n<span class="number">-1</span>, m)) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastRemainingA</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> dp1 = <span class="number">0</span>,dp2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp2 = ((dp1 + m) % i);</span><br><span class="line">		dp1 = dp2;</span><br><span class="line">		<span class="comment">//可以将上面两句合并为：dp1=((dp1 + m) % i)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>DP动态规划要划分为小的子问题。递归式找到就很容易，麻烦就在找递推式。</p>
<p>此题中映射转换那里比较难理解。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 56 - I. 数组中数字出现的次数（位运算）-真是妙蛙种子吃着妙脆角秒进米奇妙妙屋秒到家了</title>
    <url>/2021/12/12/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><h3 id="剑指-Offer-56-I-数组中数字出现的次数-位运算的妙用"><a href="#剑指-Offer-56-I-数组中数字出现的次数-位运算的妙用" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数(位运算的妙用)"></a>剑指 Offer 56 - I. 数组中数字出现的次数(位运算的妙用)</h3><ol>
<li><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3></li>
</ol>
<p>一个整型数组 <code>nums</code> 里<strong>除两个数字之外，其他数字都出现了两次</strong>。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:  [4,1,4,6]</span><br><span class="line">输出: [1,6]或者[6,1]</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:  [1,2,10,4,1,4,3,3]</span><br><span class="line">输出: [2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>

<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><h3 id="1-方法1：排序后，暴力遍历"><a href="#1-方法1：排序后，暴力遍历" class="headerlink" title="1.方法1：排序后，暴力遍历"></a>1.方法1：排序后，暴力遍历</h3><p>这种方法思路简单，但是时间复杂度较高。排序消耗O(nlogn),遍历消耗O(n)，思路简单，但是不是最优解。</p>
<h3 id="2-方法2：位运算"><a href="#2-方法2：位运算" class="headerlink" title="2.方法2：位运算"></a>2.方法2：位运算</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol>
<li>我们知道异或运算有个特点，0和任何数异或是任何数本身，先记住这个结论。我们先将此题简化为一个整型数组中只有一个数字$x$只出现了一次，其他数字$a_i$ 都出现了两次。数组定义如下$nums&#x3D;[ a_i, a_i ,x]$对于这个简化了的题，我们如果想到用位运算异或的性质，就很好求解了，直接将数组中所有的数值做异或运算，结果就是出现了一次的数$x$。公式如下：</li>
</ol>
<p>$$<br>x&#x3D;a_i\quad xor\quad a_i\quad xor\quad x<br>$$</p>
<ol start="2">
<li><p>而这道题里面有两个数字$x,y$出现了一次。$nums&#x3D;[ a_i ,a_i, x, y]$我们将<strong>其分隔为两部分</strong>$nums1,nums2$（如何分隔下面会细说），保证x,y分别在不同的部分中。然后转换为1.中将两部分用异或位运算就可以得到$x,y$。公式如下：<br>$$<br>x&#x3D;a_i\quad xor\quad a_i\quad xor\quad x\<br>y&#x3D;a_k\quad xor\quad a_k\quad xor\quad y<br>$$</p>
<p>3.如何将$nums$ 分成$nums1和nums2$,同时还得保证$x\in nums1$   $y\in nums2$。我们知道x和y一定不相同，假设其二进制第n位不同，两者异或的结果在第n为一定为1。我们只需要找到改位置。然后拿$1&lt;&lt;n $ 去和$x,y$做<strong>与运算</strong>，根据<strong>结果0,1来将其分成两组</strong>。(两个运算结果一定一个为1，一个为0)</p>
</li>
</ol>
<p>$$<br>1&lt;&lt;n\quad &amp; \quad x\<br>   1&lt;&lt;n\quad &amp; \quad y<br>$$<br>   至于其他存在两个重复的数分组也是用这种方法，只要保证相同的数分在同一组就行。$比如a1,a1在一组。a2,a2在一组$。</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ol>
<li>时间：O(n):遍历 nums使用 O(n)时间，x⊕y 二进制位使用 O(32) &#x3D; O(1)时间。</li>
<li>空间：O(1)</li>
</ol>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="1-方法1：排序后，暴力遍历-1"><a href="#1-方法1：排序后，暴力遍历-1" class="headerlink" title="1.方法1：排序后，暴力遍历"></a>1.方法1：排序后，暴力遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">题目：剑指 Offer 56 - I. 数组中数字出现的次数</span></span><br><span class="line"><span class="string">描述：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。</span></span><br><span class="line"><span class="string">     请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</span></span><br><span class="line"><span class="string">方法：排序后，暴力遍历</span></span><br><span class="line"><span class="string">复杂度分析：时间：O(n^2):排序O(n^2)+遍历O(n)</span></span><br><span class="line"><span class="string">            空间：O(1):res,i </span></span><br><span class="line"><span class="string">坑：异或运算，必须转换成二进制异或,然后求解。</span></span><br><span class="line"><span class="string">比如4（100）xor 6(110)==2(010)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    nums.sort()</span><br><span class="line">    res, i = [], <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">            res.append(nums[i])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(nums[i])</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-方法2：位运算-1"><a href="#2-方法2：位运算-1" class="headerlink" title="2.方法2：位运算"></a>2.方法2：位运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">题目：剑指 Offer 56 - I. 数组中数字出现的次数</span></span><br><span class="line"><span class="string">描述：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。</span></span><br><span class="line"><span class="string">     请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</span></span><br><span class="line"><span class="string">方法：参考题解：位运算。通过全部异或得到(X xor Y)。在通过找到该结果第一个不同位m，通过m和nums</span></span><br><span class="line"><span class="string">    依次与运算。进行分组，结果为0在一组，结果为1在另一组。以便唯一不同的X，Y分在两组中。（因为m &amp; X 和 m&amp;Y结果必然不同,利用</span></span><br><span class="line"><span class="string">    该性质分组）</span></span><br><span class="line"><span class="string">复杂度分析：时间：O(n):线性遍历 nums使用 O(N)时间，x⊕y 二进制位使用 O(32) = O(1)时间。</span></span><br><span class="line"><span class="string">            空间：O(1)</span></span><br><span class="line"><span class="string">坑：异或运算，必须转换成二进制异或。比如4（100）异或6(110)不是等于1而是等于2(010)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleNumbersA</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    temp_res = res1 = res2 = <span class="number">0</span></span><br><span class="line">    m = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将所有nums异或，结果为X ^ Y</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        temp_res = temp_res ^ i</span><br><span class="line">    <span class="comment"># 找到X ^ Y 中第一个结果为1的位置。将该值与X,Y分别与运算，用于将X,Y分到不同组别</span></span><br><span class="line">    <span class="comment"># 分组后利用【只有一个唯一不同值的组内，全nums异或，可得到唯一不同值】性质，分别求出两个不同解</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> m &amp; temp_res == m:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            m = m &lt;&lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> m &amp; i == <span class="number">0</span>:  <span class="comment"># 用于分组</span></span><br><span class="line">            res1 = res1 ^ i  <span class="comment"># 分组后利用【只有一个唯一不同值的组内，全nums异或，可得到唯一不同值】性质，分别求出两个不同解</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res2 = res2 ^ i</span><br><span class="line">    <span class="keyword">return</span> [res1, res2]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>这道题用位运算<strong>真是妙蛙种子吃着妙脆角秒进米奇妙妙屋秒到家了</strong>。</p>
<p><strong>位运算常见性质总结:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 or 任何数等于其本身</span><br><span class="line">0 xor 任何数等于其本身（本题用到性质）</span><br><span class="line">1 and 任何数等于其本身（本题用到性质）</span><br><span class="line"></span><br><span class="line">0 and 任何数等于0</span><br><span class="line">1 or 任何数等于1</span><br><span class="line">1 xor 任何数等于本身取反</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>指针重点总结</title>
    <url>/2021/12/14/%E6%8C%87%E9%92%88%E9%87%8D%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="C-C-指针踩坑历险记-常量指针-const-ptr-，指针常量ptr-const，引用，指针传参，指针修改，指针指向的值修改等问题"><a href="#C-C-指针踩坑历险记-常量指针-const-ptr-，指针常量ptr-const，引用，指针传参，指针修改，指针指向的值修改等问题" class="headerlink" title="C&#x2F;C++指针踩坑历险记-常量指针-const ptr *，指针常量ptr * const，引用，指针传参，指针修改，指针指向的值修改等问题"></a>C&#x2F;C++指针踩坑历险记-常量指针-const ptr *，指针常量ptr * const，引用，指针传参，指针修改，指针指向的值修改等问题</h1><p>好久没写C语言了，不过一直用C++在刷题，遇到指针总有些发憷？初学指针的时候觉得指针好难，其实搞清指针的重要几个概念，指针就不难~对指针一些重点知识进行一个总结。</p>
<h2 id="指针初体验"><a href="#指针初体验" class="headerlink" title="指针初体验"></a>指针初体验</h2><p>我们知道指针本质上就是一个存放地址的变量（该变量存放地址，一串你看不懂的数字）。比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;a;<span class="comment">//就表示指向a的一个变量ptr，ptr内部存放的是一个地址（一串你看不懂的数字）</span></span><br></pre></td></tr></table></figure>

<p>下面举个例子,直观地展示一下ptr的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span>* ptr = &amp;a;<span class="comment">//ptr是一个地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%x&quot;</span>, ptr);<span class="comment">//打印ptr的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="https://img-blog.csdnimg.cn/da134d7ede0b49018e82c2858f778b30.png#pic_center" alt="在这里插入图片描述"></p>
<p>通过设置断点查看程序执行过程，也可以查看ptr存放的到底是什么</p>
<p><img src="https://img-blog.csdnimg.cn/01e45242a53c4c9e8e88e36d5a1066cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>你现在只需要知道指针就是指向一个内存块的地址，本质上就是一个变量。<br>对指针有了直观的认识之后，你肯定会想，要一个内存单元的地址有什么用呢？这个地址（0x00d3fb30）我又看不懂。我们要内存中的值（比如上面a的值3）不就行了吗?<br>其实不然，指针在函数参数传递中大有妙用。请往下看</p>
<h2 id="指针在函数”传值”中的应用"><a href="#指针在函数”传值”中的应用" class="headerlink" title="指针在函数”传值”中的应用"></a>指针在函数”传值”中的应用</h2><p>我们知道函数传参过程中，实参和形参结合，也就是形参会等于实参的值，然后函数老大就一脚把实参踹开，之后就不干实参啥事了。</p>
<p>之后在函数内部，函数老大就抓着形参不放，所有的操作都是对实参起作用，和形参无关（暂时这么理解）。下面举个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">	a = a + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数内部的a值(形参)为%d\n&quot;</span>, a);<span class="comment">//形式结合，a=b=3,然后a=a+1=4.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">add</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数外部的b值（实参）为%d\n&quot;</span>, b);<span class="comment">//实参不变，b=3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个例子，我们要记住，<strong>函数形参和实参结合时，函数内部先将实参的值赋给形参，然后再对形参进行操作。</strong></p>
<p>当形参为地址时，对形参操作也可能会影响实参，下面举例说明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>* a)</span> </span>&#123;<span class="comment">//形参为指针,a等于b的地址</span></span><br><span class="line">	*a = *a + <span class="number">1</span>;<span class="comment">//a也就是b的地址，*表示取出该地址内存中的值3，加1后存放在a地址中。即3+1=4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数内部的a地址为0x%x\n&quot;</span>, a);<span class="comment">//一个地址，和b的地址一样0x136f9c4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数内部的a地址内存里面的值为%d\n&quot;</span>, *a);<span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">add</span>(&amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数外部的b的地址为0x%x\n&quot;</span>, &amp;b);<span class="comment">//b的地址0x136f9c4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数外部的b值（实参）为%d\n&quot;</span>, b);<span class="comment">//在函数内部通过地址改变了b的值，b=4</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://img-blog.csdnimg.cn/48bfc3c79e4f49db96e028a1d874a33b.png#pic_center" alt="在这里插入图片描述"></p>
<p>通过这个地址我们需要明白两点</p>
<ol>
<li><p>当函数形参为指针类型时，表示该函数传递一个指针给形参，然后对形参进行操作。此时形参是一个指针，也就是一个地址，我们通过地址可以使实参发生变化。比如例子中改变*a使得实参b发生变化。示意图如下：<br> <img src="https://img-blog.csdnimg.cn/8bb5fce4b681413d8e073e1a8c9bedb0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>为了和传值区分，我们称上面函数传参方式为传址。其实传址本质上还是传值。</p>
</li>
</ol>
<h2 id="传址妙用"><a href="#传址妙用" class="headerlink" title="传址妙用"></a>传址妙用</h2><p>传址可以大大减少内存的消耗，试想一下如果b中存放的是一个占很大内存的对象，如果采用传值方式传递，形实结合会新开辟一块和b一样的空间，供函数内部操作。这样会很消耗内存空间。</p>
<p>但如果我们只传递b的一个地址（一串数字的大小），形实结合时，仅仅需要一小块空间就能够存放下b的地址。然后在函数内仅仅需要通过*就可以操作该地址内部的值。此举大大节约空间。但此举操作可能会影响函数外部的对象的值，使用时应该考虑清楚。</p>
<h2 id="用-对指针指向的值修改"><a href="#用-对指针指向的值修改" class="headerlink" title="用*对指针指向的值修改"></a>用*对指针指向的值修改</h2><p>毫无疑问，在函数内部用*对形参指向的值进行修改，函数外部的实参值也会变化。如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>* a)</span> </span>&#123;<span class="comment">//形参为指针,a等于b的地址</span></span><br><span class="line">	*a = *a + <span class="number">1</span>;<span class="comment">//a也就是b的地址，*表示取出该地址内存中的值3，加1后存放在a地址中。即3+1=4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数内部的a地址为0x%x\n&quot;</span>, a);<span class="comment">//一个地址，和b的地址一样0x136f9c4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数内部的a地址内存里面的值为%d\n&quot;</span>, *a);<span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">add</span>(&amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数外部的b的地址为0x%x\n&quot;</span>, &amp;b);<span class="comment">//b的地址0x136f9c4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数外部的b值（实参）为%d\n&quot;</span>, b);<span class="comment">//在函数内部通过地址改变了b的值，b=4</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果直接对形参修改（不用*）,不会对函数外部的实参值有任何影响。如下</p>
<h2 id="直接对指针本身修改"><a href="#直接对指针本身修改" class="headerlink" title="直接对指针本身修改"></a>直接对指针本身修改</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>* a)</span> </span>&#123;<span class="comment">//形参为指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line">	a = &amp;c;<span class="comment">//a的值变化了，此时a已经与函数外部的b彻底没关系了。不会影响函数外部b的值。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数内部的a地址为0x%x\n&quot;</span>, a);<span class="comment">//a为c的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数内部的a地址内存里面的值为%d\n&quot;</span>, *a);<span class="comment">//*a=10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">add</span>(&amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数外部的b的地址为0x%x\n&quot;</span>, &amp;b);<span class="comment">//b的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数外部的b值（实参）为%d\n&quot;</span>, b);<span class="comment">//b=3,未发生变化</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要正确理解 * 表示对该指针指向的内存单元的值进行操作。</p>
<p>直接对形参修改（不用*），表示对该地址修改了。原来形参还和实参指向同一块地址，<strong>形参地址一旦修改，形参就彻底和实参失去联系了。再对形参任何操作均不会对函数外部的实参值有任何影响</strong>。这点要注意，容易出错。</p>
<h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><p>所谓常量指针就是<strong>指向常量的指针</strong>,表示为<code>const int*</code> 。不能用*去修改内存中的常量。举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>* ptr = &amp;a;</span><br><span class="line">	*ptr = <span class="number">4</span>;<span class="comment">//报错：表达式必须是可修改的左值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>指针常量，<strong>表示该地址是一个常量，不能修改</strong>。表示为<code>int * const </code>.举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span>* <span class="type">const</span> ptr= &amp;a;</span><br><span class="line">	ptr = &amp;b;<span class="comment">//报错：表达式必须是可修改的左值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++中的引用，本质上就是指针常量。</p>
<h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h2><p>C++引用是C++中特有的，<strong>本质上就是指针常量，如果进行修改，一定是指向的内存变化，而不是指针本身</strong>。用&amp;表示。在引用的基础上改变，原值也要变，<strong>可以看做一个变量的别名</strong>。举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span>&amp; ptr= a;<span class="comment">//ptr就是a的别名</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptr);<span class="comment">//3</span></span><br><span class="line">	ptr = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptr);<span class="comment">//5</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 62. 圆圈中最后剩下的数字思路推导（约瑟夫环、DP、递归）</title>
    <url>/2021/12/25/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> ]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 56 - II. 数组中数字出现的次数 II（二进制求和模运算）</title>
    <url>/2021/12/16/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0II/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 



<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><h3 id="剑指-Offer-56-II-数组中数字出现的次数-II-位运算的妙用"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II-位运算的妙用" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II(位运算的妙用)"></a>剑指 Offer 56 - II. 数组中数字出现的次数 II(位运算的妙用)</h3><ol>
<li><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3></li>
</ol>
<p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><h3 id="方法1：hashMap统计个数，遍历返回"><a href="#方法1：hashMap统计个数，遍历返回" class="headerlink" title="方法1：hashMap统计个数，遍历返回"></a>方法1：hashMap统计个数，遍历返回</h3><p>比较常规的思路就是通过hashMap统计个数，然后遍历返回即可。思路简单，但这种方法显示没有充分利用题中的<strong>条件其他数字都出现了三次</strong>。所以一定不是最优解。</p>
<h3 id="方法2：位运算"><a href="#方法2：位运算" class="headerlink" title="方法2：位运算"></a>方法2：位运算</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>其他数字出现了三次，这是我们解题的突破点。</p>
<p>做这种数字题，我们要有位运算的思想在，所以我们绞尽脑汁往位运算那边去靠。我们试想一下，如果将所有数字转换为二进制，然后观察一下会有什么规律呢？如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums=[4,4,4,5,5,5,3]</span><br><span class="line">出现3次：4,5</span><br><span class="line">*          4:0100b</span><br><span class="line">*          4:0100b</span><br><span class="line">*          4:0100b</span><br><span class="line">*          5:0101b</span><br><span class="line">*          5:0101b</span><br><span class="line">*          5:0101b</span><br><span class="line">出现1次：3</span><br><span class="line">*          3:0011b</span><br></pre></td></tr></table></figure>

<p>我们发现4,5这两个重复的数字每一位之和必定是3的倍数，道理很简单，因为相同的数字出现了3次，多个相同的数之和肯定是3的倍数。</p>
<p>利用这个规律，每位和是三的倍数，我们将所有数字每位求和，然后模3，就是出现一次数字的对应位。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums=[4,4,4,5,5,5,3]</span><br><span class="line">出现3次：4,5</span><br><span class="line">*          4:0100b</span><br><span class="line">*          4:0100b</span><br><span class="line">*          4:0100b</span><br><span class="line">*          5:0101b</span><br><span class="line">*          5:0101b</span><br><span class="line">*          5:0101b</span><br><span class="line">*          3:0011b</span><br><span class="line">每位进行sum%3结果就是要求的数，如下：</span><br><span class="line">*          3:0011b</span><br></pre></td></tr></table></figure>



<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><h5 id="时间O-N"><a href="#时间O-N" class="headerlink" title="时间O(N)"></a>时间O(N)</h5><p>两次遍历O(32)*O(N)</p>
<h5 id="空间O-1"><a href="#空间O-1" class="headerlink" title="空间O(1)"></a>空间O(1)</h5><p>常数辅助遍历O(1)</p>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="方法1：hashMap统计个数，遍历返回-1"><a href="#方法1：hashMap统计个数，遍历返回-1" class="headerlink" title="方法1：hashMap统计个数，遍历返回"></a>方法1：hashMap统计个数，遍历返回</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：剑指 Offer 56 - II. 数组中数字出现的次数 II</span></span><br><span class="line"><span class="comment">     * 描述：在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字</span></span><br><span class="line"><span class="comment">     * 方法：哈希表存储</span></span><br><span class="line"><span class="comment">     * 复杂度：时间O(N):两次遍历数组O(2*n)</span></span><br><span class="line"><span class="comment">     *        空间O(N):线性哈希表O(N)，和常数辅助遍历j,i,O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line"><span class="comment">//            j=hashMap.get(i)==null?1:hashMap.get(i)+1;//可以优化，因为我们只要计数为1的key,超过1的key我们可以直接设置为-1。减少get操作。</span></span><br><span class="line">            j=hashMap.get(i)==<span class="literal">null</span>?<span class="number">1</span>:-<span class="number">1</span>;<span class="comment">//优化减少get操作。</span></span><br><span class="line"></span><br><span class="line">            hashMap.put(i,j);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : hashMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.get(i)==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法1小优化，避免计数"><a href="#方法1小优化，避免计数" class="headerlink" title="方法1小优化，避免计数"></a>方法1小优化，避免计数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：剑指 Offer 56 - II. 数组中数字出现的次数 II</span></span><br><span class="line"><span class="comment"> * 描述：在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字</span></span><br><span class="line"><span class="comment"> * 方法：哈希表存储,上面方法优化。将hashMap分为符合条件的和不符合条件的，减少计数</span></span><br><span class="line"><span class="comment"> * 复杂度：时间O(N):两次遍历数组O(2*n)</span></span><br><span class="line"><span class="comment"> *        空间O(N):线性哈希表O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">singleNumberB</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Boolean&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">        hashMap.put(i,hashMap.containsKey(i));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : hashMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap.get(i)==<span class="literal">false</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="方法2：位运算-1"><a href="#方法2：位运算-1" class="headerlink" title="方法2：位运算"></a>方法2：位运算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：剑指 Offer 56 - II. 数组中数字出现的次数 II</span></span><br><span class="line"><span class="comment"> * 描述：在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字</span></span><br><span class="line"><span class="comment"> * 方法：位运算如下</span></span><br><span class="line"><span class="comment"> *          4:0100b</span></span><br><span class="line"><span class="comment"> *          4:0100b</span></span><br><span class="line"><span class="comment"> *          4:0100b</span></span><br><span class="line"><span class="comment"> *          3:0011b</span></span><br><span class="line"><span class="comment"> *        sum:0011(每位求和模3就是结果，可以拓展到其他数字出现了n次)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度：时间O(N):两次遍历O(32)*O(N)</span></span><br><span class="line"><span class="comment"> *        空间O(1):常数辅助遍历O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">singleNumberA</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum;<span class="comment">//所有数字某个位置之和</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;<span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">32</span>; j++) &#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += ( (nums[i] &gt;&gt; j) &amp; <span class="number">1</span>);<span class="comment">//用&quot;&amp;1&quot; 和每位测试是1或0</span></span><br><span class="line">        &#125;</span><br><span class="line">        res +=( (sum%<span class="number">3</span>) &lt;&lt; j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>这道题用位运算可以<strong>拓展到其他数字重复n次</strong>，具有一定的通解性。本质上利用转换为二进制之后，通过取余运算，找到独一无二的数。</p>
<p>位运算常见性质总结:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 or 任何数等于其本身</span><br><span class="line">0 xor 任何数等于其本身（本题用到性质）</span><br><span class="line">1 and 任何数等于其本身（本题用到性质）</span><br><span class="line"></span><br><span class="line">0 and 任何数等于0</span><br><span class="line">1 or 任何数等于1</span><br><span class="line">1 xor 任何数等于本身取反</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔的非递归实现(借助堆栈模拟递归)</title>
    <url>/2021/12/14/%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-%E5%80%9F%E5%8A%A9%E5%A0%86%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="汉诺塔的非递归实现"><a href="#汉诺塔的非递归实现" class="headerlink" title="汉诺塔的非递归实现"></a>汉诺塔的非递归实现</h1><p>借助堆栈以非递归（循环）方式求解汉诺塔的问题（n，a，b，c）。即将n个盘子从起始柱(标记为“a”)通过借助柱（标记为“b”)移动到目标杜(标记为“c”)，并保证每个移动符合汉诺塔问题的要求。<br><img src="https://img-blog.csdnimg.cn/67e591ba0acc42dca5abcf78722662bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBALS1iZWxpZXZl,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>汉诺塔问题求解的基本思路是，不断将n个盘的汉诺塔问题转换为2个n-1盘的汉诺塔问题,因此用递归实现是很自然的方法。当把n盘问题转换为n-1 盘问题时，问题的起始柱子和目标柱子也发生了变化。设n盘问题为(n，a，b，c），其中参数如实验内容中所定义,则问题的求解可转换为对(n-1,a,c,b)、（1,a,b,c）、（n-1,b,a,c)这三个问题的求解，其中(1,a.b,c)不需要递归，可直接实现。</p>
<p>在要求不用递归的情况下，可以借助自己建立的堆栈来解决问题。将待求解问题放入堆栈，然后不断将栈顶的问题分解，再将分解出的n&gt;1 的新问题放入堆栈，如此不断循环一直到堆栈为空，问题求解就可结束。</p>
<p>注意：当将分解出的上述三个问题压入堆栈时，应该按照“需要先求解的问题后压入”的顺序,也就是压入顺序为（n-1,b,a,c）.（1,a,b,c）（n-1,a,c,b)。</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>（堆栈不空）</span><br><span class="line">&#123;</span><br><span class="line">Pop 堆栈顶问题，设为(n<span class="number">&#x27;</span>,a<span class="number">&#x27;</span>, b<span class="number">&#x27;</span>, c<span class="number">&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(n<span class="number">&#x27;</span>为<span class="number">1</span>）输出：a<span class="number">&#x27;</span>-&gt;c ;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">Push</span> ( (n<span class="number">&#x27;</span><span class="number">-1</span>, b<span class="number">&#x27;</span>, a<span class="number">&#x27;</span>, c<span class="number">&#x27;</span>) ) ;</span><br><span class="line"><span class="built_in">Push</span>((<span class="number">1</span>, a, b, c)) ;</span><br><span class="line"><span class="built_in">Push</span>( (n<span class="number">&#x27;</span><span class="number">-1</span>, a<span class="number">&#x27;</span>, c<span class="number">&#x27;</span>, b<span class="number">&#x27;</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Status</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;<span class="comment">//盘数</span></span><br><span class="line">	<span class="type">char</span> a;<span class="comment">//第一个柱子;</span></span><br><span class="line">	<span class="type">char</span> b;<span class="comment">//第二个柱子;</span></span><br><span class="line">	<span class="type">char</span> c;<span class="comment">//第三个柱子;</span></span><br><span class="line">	<span class="built_in">Status</span>(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b,<span class="type">char</span> c) :<span class="built_in">n</span>(n), <span class="built_in">a</span>(a), <span class="built_in">b</span>(b), <span class="built_in">c</span>(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Status sts)</span> </span>&#123;</span><br><span class="line">	stack&lt;Status&gt; stk;</span><br><span class="line">	stk.<span class="built_in">push</span>(sts);</span><br><span class="line">	Status cur=sts;</span><br><span class="line">	<span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cur = stk.<span class="built_in">top</span>();</span><br><span class="line">		stk.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (cur.n == <span class="number">1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; cur.a &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; cur.c &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		stk.<span class="built_in">push</span>(<span class="built_in">Status</span>(cur.n <span class="number">-1</span>, cur.b, cur.a, cur.c));</span><br><span class="line">		stk.<span class="built_in">push</span>(<span class="built_in">Status</span>(<span class="number">1</span>,cur.a,cur.b,cur.c));</span><br><span class="line">		stk.<span class="built_in">push</span>(<span class="built_in">Status</span>(cur.n<span class="number">-1</span>,cur.a,cur.c,cur.b));</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">3</span>;    <span class="comment">//盘数</span></span><br><span class="line">	<span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;  <span class="comment">//第一个柱子</span></span><br><span class="line">	<span class="type">char</span> b = <span class="string">&#x27;b&#x27;</span>;  <span class="comment">//第二个柱子</span></span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;  <span class="comment">//第三个柱子</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入的盘子数为&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;移动顺序为&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">Status <span class="title">pro</span><span class="params">(n, a, b, c)</span></span>;</span><br><span class="line">	<span class="built_in">dfs</span>(pro);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>如果有所收获，不妨一键三连，祝顺利！</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>磁道扇区柱面是啥</title>
    <url>/2021/12/14/%E7%A3%81%E9%81%93%E6%89%87%E5%8C%BA%E6%9F%B1%E9%9D%A2%E6%98%AF%E5%95%A5/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h2 id="磁道、扇区、盘片"><a href="#磁道、扇区、盘片" class="headerlink" title="磁道、扇区、盘片"></a>磁道、扇区、盘片</h2><p>首先，先在大脑中建立硬盘中专业术语到实物的映射。</p>
<p>在脑海中建立硬盘的大致结构。简单来说硬盘就像一个一个盘子堆叠起来的结构。如下图。</p>
<p><img src="https://img-blog.csdnimg.cn/5677b6b1c3934215a03be0d89caacc1b.png#pic_center" alt="在这里插入图片描述"></p>
<p>在硬盘中，我们将类似每一个盘子的东西称作<strong>盘片</strong>。在这个盘片上会划分很多个同心圆，就像操场跑道一样的同心圆。如下图。<br><img src="https://img-blog.csdnimg.cn/961731fe77a149b58a9e6a0231222332.png#pic_center" alt="D:\桌面\博客\计算机基础知识补充\img\磁道-跑道.jpeg"></p>
<p>我们这一条条跑道称为<strong>磁道</strong>。将每一条跑道划分为一个一个的扇形的小块，将小块称为<strong>扇区</strong>。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/f57871be11674e728158e8892487c3b9.png#pic_center" alt="在这里插入图片描述"></p>
<p>好了，有了这些基本的结构和术语类比，相信这些术语你能凭借字面意思就能想象他们的样子了。那下面内容对你轻而易举~</p>
<h2 id="柱面、磁头"><a href="#柱面、磁头" class="headerlink" title="柱面、磁头"></a>柱面、磁头</h2><p>柱面就是<strong>每个磁道叠起来</strong>形成的一个柱面。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/a981ada3723d433aa8ccc45f8be74380.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/a65e566e207a48fabe4825463e480b7f.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="重要结论"><a href="#重要结论" class="headerlink" title="重要结论"></a>重要结论</h2><ul>
<li>柱面数 &#x3D; 一个盘面的磁道数</li>
<li>磁头数 &#x3D; 盘面数</li>
<li>一个盘面容量 &#x3D; 512（一个扇区容量） x 一个磁道的扇区数 x 一个盘面的磁道数 </li>
<li>磁盘容量&#x3D;512 x 一个磁道扇区数 x 一个盘面的磁道数x磁头数</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/m0_37329910/article/details/85833252">图解磁盘</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>常识</tag>
      </tags>
  </entry>
  <entry>
    <title>从JVM角度对java中引用的理解</title>
    <url>/2023/12/01/%E4%BB%8EJVM%E8%A7%92%E5%BA%A6%E5%AF%B9java%E4%B8%AD%E5%BC%95%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<p>学java这么久了，对java引用越来越深刻，好好梳理一下下面三个问题，带着问题进行理解。</p>
<h1 id="什么是引用？引用存放在jvm哪个区域？"><a href="#什么是引用？引用存放在jvm哪个区域？" class="headerlink" title="什么是引用？引用存放在jvm哪个区域？"></a>什么是引用？引用存放在jvm哪个区域？</h1><p><strong>引用是一种变量类型。引用类型占四个字节。</strong><br>变量类型分为基本类型和引用类型。<br>我们知道java中有8种基本数据类型+Sring引用类型：byte,short,int,long,float,double,char,boolean。<br>引用类型一般为实例对象的引用。可以理解为该对象存放的地址。注意引用和对象时不一样的。<br>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">instanceVariable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> instanceVariableInt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">localVariable</span> <span class="operator">=</span> <span class="built_in">this</span>.instanceVariable;  <span class="comment">// 假设程序刚执行完这一行</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的new Object（）为实例对象，存放在堆中。instanceVariable 为引用类型，作为实例的一部分也存放在堆内存中。<br>上图的localVariable 也是引用类型，他是局部变量的引用类型，存放在虚拟机栈的栈帧中。<br><img src="https://img-blog.csdnimg.cn/direct/a3fbcaa25fe447c1a5ca08baa8731619.png" alt="在这里插入图片描述"></p>
<p>参考：<a href="https://www.zhihu.com/question/387738123">java 成员变量中的引用类型变量如何保存？</a></p>
<h1 id="引用和地址区别？"><a href="#引用和地址区别？" class="headerlink" title="引用和地址区别？"></a>引用和地址区别？</h1><p>java地址：java规范中没有地址的概念。如果不讨论jvm的实现，就没有这种概念。<br>深入理解：如果深入研究。地址和引用的差异是由GC造成的。特别是引用具有重新定位对象的能力。而地址是基本不会变的。<br>举例：<br>假设内存中有一个实例对象object，地址为10050。在GC之后，指向object的引用仍将指向object。但是object并不在原来的位置了。</p>
<p>参考：<a href="https://stackoverflow.com/questions/68814098">https://stackoverflow.com/questions/68814098</a></p>
<h1 id="java函数是值传递还是引用传递？"><a href="#java函数是值传递还是引用传递？" class="headerlink" title="java函数是值传递还是引用传递？"></a>java函数是值传递还是引用传递？</h1><p>java中参数列表中有两种数据类型，一种是基本数据类型一种是引用数据类型。在java函数中实参和形参之间的传递是值传递！（引用对象传递的是引用值，并不是说传递的是引用就是引用传递）</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型在实参传递给形参的过程中，实参将值复制给形参，形参是存放在栈帧中的局部变量表中的，无论如何修改只会修改形参的值，不会影响到传入的实参。</p>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>引用数据类型传参的过程中，实参传递给形参的是引用数据类型的值。对形参引用数据类型本身操作是不会影响到实参的。但是对形参引用指向的内存数据进行操作。会影响到实参。因为实参和形参引用指向的是同一块内存（存放的是对象）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adds</span><span class="params">(Integer i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">        val += <span class="number">3</span>;</span><br><span class="line">        i = <span class="keyword">new</span> <span class="title class_">Integer</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line">        adds(j);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出值为：&quot;</span> + j.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答案：0<br>分析：形参 i是引用数据类型，函数中对形参i进行了变换，引用类型i发生了变化，但是该引用指向的数据没有发生变化。因此主函数中的实参j指向的内存不变，值也不变。见下图：<br><img src="https://img-blog.csdnimg.cn/direct/157b919b299643c8a6293d9160dea488.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器GPU温度过高挂掉排查记录</title>
    <url>/2023/12/31/%E6%9C%8D%E5%8A%A1%E5%99%A8GPU%E6%B8%A9%E5%BA%A6%E8%BF%87%E9%AB%98%E6%8C%82%E6%8E%89%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/> 

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>印象深刻的跨年日，2023年最后一天在实验室维修服务器。</p>
<h1 id="服务器GPU挂掉"><a href="#服务器GPU挂掉" class="headerlink" title="服务器GPU挂掉"></a>服务器GPU挂掉</h1><p>跑深度学习的代码的时候发现中断了。通过命令查看：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<p>显示</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Unable to determine the device handle for GPU 0000:01:00.0: Unknown Error。</span><br></pre></td></tr></table></figure>
<p>感觉很莫名其妙。通过重启大法之后，又能用一段时间。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure>

<p>但是过了一个小时左右又会挂掉。不能从根本解决问题。那么到底为什么GPU会自己挂掉呢？</p>
<h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>通过查看日志定位错误原因：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nvidia-bug-report.sh</span><br></pre></td></tr></table></figure>
<p>在当前目录下生成了nvidia-bug-report.log日志文件。查看到日志文件的内容如下：</p>
<p><img src="https://img-blog.csdnimg.cn/direct/2bc36a8dfe0440419e23398b100fa4f6.jpeg" alt="在这里插入图片描述"><br>网上查找一下这个报错码79<a href="https://forums.developer.nvidia.com/t/gpu-has-fallen-of-the-bus/122124">https://forums.developer.nvidia.com/t/gpu-has-fallen-of-the-bus/122124</a>发现要么是电源问题，要么是温度过高问题。<br><img src="https://img-blog.csdnimg.cn/direct/99125333e9ce445db970c236be10efe2.jpeg" alt="在这里插入图片描述"></p>
<h1 id="重现问题，查看温度日志"><a href="#重现问题，查看温度日志" class="headerlink" title="重现问题，查看温度日志"></a>重现问题，查看温度日志</h1><p>如果判断是否是GPU温度过高呢？需要打一个温度日志，再运行一下代码，看GPU温度是否超过了shutdown 温度（GPU温度过高会自动掉线保护GPU）。命令如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nvidia-smi -q -l 2 -d TEMPERATURE -f nvidiatemp.log </span><br></pre></td></tr></table></figure>
<p>代码继续跑，等待问题重现后查看温度日志就可以确定是否是温度过高导致GPU自动掉线了。<br>果然，当GPU掉线后，查看温度日志：<br><img src="https://img-blog.csdnimg.cn/direct/5825b648c3424fa8932764e30b9471be.png" alt="在这里插入图片描述"><br>上图中CurrentTemp表示当前温度，Shutdown Temp表示超过这个温度GPU会自动掉线。Target Temp表示目标温度（GPU比较合适的温度）。<br>找到问题了！就是温度过热导致GPU掉线！</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>温度过热？<br>多半是散热不行，果然，发现一个风扇明显转的较慢。猜测可能是那个风扇坏掉了。<br>于是将显卡风扇拆下来。通过拨动发现其中一个风扇没另一个风扇灵活。拆开发现转轴有点杂质，增大了风扇阻力，清理了一下,上了点润滑油。（当然直接换风扇最为方便！！！免得担心风扇被拆坏掉）<br><img src="https://img-blog.csdnimg.cn/direct/0d5ceb2d59eb491f997f1d488a1f47fd.jpeg" alt="在这里插入图片描述"></p>
<p>装上后发现能正常工作，温度再也没有超负荷过！问题完美解决！</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://forums.developer.nvidia.com/t/gpu-has-fallen-of-the-bus/122124%5D">gpu-has-fallen-of-the-bus</a></p>
]]></content>
      <categories>
        <category>解决方法</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
</search>
