<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>坚韧的长线「串联」散落的珍珠</title>
  
  <subtitle>liusir的博客</subtitle>
  <link href="https://liuhsir.top/atom.xml" rel="self"/>
  
  <link href="https://liuhsir.top/"/>
  <updated>2024-01-24T14:04:54.785Z</updated>
  <id>https://liuhsir.top/</id>
  
  <author>
    <name>--believe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JUC-CAS</title>
    <link href="https://liuhsir.top/2024/01/24/JUC-CAS/"/>
    <id>https://liuhsir.top/2024/01/24/JUC-CAS/</id>
    <published>2024-01-24T14:04:25.000Z</published>
    <updated>2024-01-24T14:04:54.785Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="1-CAS概述"><a href="#1-CAS概述" class="headerlink" title="1. CAS概述"></a>1. CAS概述</h1><p>CAS(Compare ans swap&#x2F;set) 比较并交换，实现并发的一种底层技术。它将预期的值和内存中的值比较，如果相同，就更新内存中的值。如果不匹配，一直重试（自旋）。Java.util.concurrent.atomic包下的原子类都使用了CAS算法</p><h1 id="2-CAS原理"><a href="#2-CAS原理" class="headerlink" title="2. CAS原理"></a>2. CAS原理</h1><p>CAS具体的操作是将预期的值和内存中真实的值进行比较，如果相同就更新值。如果不相同就重试（自旋）。<br>CAS是通过Unsafe的compareAndSwap方法实现的，底层实现是CPU原子指令cmpxchg，不会造成数据不一致的问题。<br>CAS依靠底层硬件实现的无锁原子算法。比synchronized重量级锁性能更好。</p><h1 id="3-CAS与自旋锁"><a href="#3-CAS与自旋锁" class="headerlink" title="3. CAS与自旋锁"></a>3. CAS与自旋锁</h1><h2 id="3-1-前置知识：原子引用类AtomicReference"><a href="#3-1-前置知识：原子引用类AtomicReference" class="headerlink" title="3.1 前置知识：原子引用类AtomicReference"></a>3.1 前置知识：原子引用类AtomicReference</h2><p>将自定义的类型变成原子类，能够进行cas操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">    AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="type">User</span> <span class="variable">z3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;z3&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">li4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;li4&quot;</span>,<span class="number">28</span>);</span><br><span class="line">    atomicReference.set(z3);</span><br><span class="line">    System.out.println(atomicReference.compareAndSet(z3, li4)+<span class="string">&quot;\t&quot;</span>+atomicReference.get().toString());</span><br><span class="line">    System.out.println(atomicReference.compareAndSet(z3, li4)+<span class="string">&quot;\t&quot;</span>+atomicReference.get().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-CAS实现一个自旋锁：A线程持有锁，B线程自旋等待直到A释放锁。"><a href="#3-2-CAS实现一个自旋锁：A线程持有锁，B线程自旋等待直到A释放锁。" class="headerlink" title="3.2 CAS实现一个自旋锁：A线程持有锁，B线程自旋等待直到A释放锁。"></a>3.2 CAS实现一个自旋锁：A线程持有锁，B线程自旋等待直到A释放锁。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：实现一个自旋锁,复习CAS思想</span></span><br><span class="line"><span class="comment"> * 自旋锁好处：循环比较获取没有类似wait的阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现</span></span><br><span class="line"><span class="comment"> * 当前有线程持有锁，所以只能通过自旋等待，直到A释放锁后B随后抢到。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----come in 等待锁&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 拿到锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;----task over,释放锁...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SpinLockDemo</span> <span class="variable">spinLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLockDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.lock();</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            spinLockDemo.unLock();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停500毫秒,线程A先于B启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.lock();</span><br><span class="line"></span><br><span class="line">            spinLockDemo.unLock();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心思想：</strong></p><ul><li>加锁：开始的时候，内存中的值为NULL，一旦有线程进入，预期值为NULL,和真实值匹配将内存设置为当前线程值。(此时其他线程进来后预期值NULL，但是真实值已经被修改所以会自旋，这为加锁)</li><li>解锁： 释放锁之后，重新设置内存的值为NULL，让其他线程能够进入从而修改</li></ul><p><strong>运行结果：</strong><br><img src="https://img-blog.csdnimg.cn/direct/b737fcfa4df640c2b978134c70f8ac82.png" alt="在这里插入图片描述"></p><h1 id="CAS和synchronized比较"><a href="#CAS和synchronized比较" class="headerlink" title="CAS和synchronized比较"></a>CAS和synchronized比较</h1><p>CAS线程不会阻塞，线程一直自旋。<br>Synchronized会阻塞，会进行线程的上下文切换非常耗费资源。</p><h1 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h1><h2 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h2><p>CAS如果预测值和真实值不一样，将一直自旋。导致循环CPU开销大。</p><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题顾名思义就是将线程1在进行CAS操作的时候，另一个线程2已经将A修改为B又快速修改回A，导致一个线程并未发现中间修改过仍能正常进行CAS比较和修改。</p><h2 id="ABA问题解决方案"><a href="#ABA问题解决方案" class="headerlink" title="ABA问题解决方案"></a>ABA问题解决方案</h2><p>原子时间戳引用：给每次修改都加上一个时间戳(版本号)，CAS操作的时候不仅要比较预测值和真实值，还要比较预测版本号和真实版本号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>().compareAndSet(V   expectedReference,</span><br><span class="line">                                 V   newReference,</span><br><span class="line">                                 <span class="type">int</span> expectedStamp,</span><br><span class="line">                                 <span class="type">int</span> newStamp)</span><br></pre></td></tr></table></figure><h1 id="CAS注意事项"><a href="#CAS注意事项" class="headerlink" title="CAS注意事项"></a>CAS注意事项</h1><p>CAS只能保证原子性，不能保证变量的可见性。要配合volatile使用，保证共享变量的可见性。<br>CAS适用于并发量不高，多核CPU的情况。并发量增高，CAS自旋会导致消耗CPU资源。这时候用LongAdder</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;1-CAS概述&quot;&gt;&lt;a href=&quot;#1-CAS概述&quot; class=&quot;headerlink&quot; title=&quot;1. CAS概述&quot;&gt;&lt;/a&gt;1. CAS概述&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="JUC" scheme="https://liuhsir.top/categories/JUC/"/>
    
    
    <category term="JUC" scheme="https://liuhsir.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC-JMM与volatile</title>
    <link href="https://liuhsir.top/2024/01/23/JUC-JMM%E4%B8%8Evolatile/"/>
    <id>https://liuhsir.top/2024/01/23/JUC-JMM%E4%B8%8Evolatile/</id>
    <published>2024-01-23T08:14:25.000Z</published>
    <updated>2024-01-23T08:29:35.026Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="volatile简介及作用"><a href="#volatile简介及作用" class="headerlink" title="volatile简介及作用"></a>volatile简介及作用</h1><p>volatile是JVM提供的轻量级的同步机制。volatile关键字能够保证并发编程的三大特性中的可见性，有序性。但是不能保证原子性。<br>保证可见性：<br>经过volatile修饰的变量，在本地内存中修改之后，会立即刷回主内存中。当主内存中的共享变量修改之后，其他线程的本地内存会立即同步获取到这个最新的值。<br>保证有序性：<br>通过禁止指令重排优化来保证有序性。禁止指令重排优化是通过内存屏障来实现的。</p><h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>内存屏障就是CPU或者编译器对内存随机访问的一个同步点，使得对该点之前的操作在该点之后的操作之前。避免代码重排序。<br>内存屏障粗分类：</p><ul><li>读屏障：在读操作之前插入读屏障，让工作内存中的缓存失效，进而从主存中获取最新的数据。</li><li>写屏障：在写操作之后插入写屏障，让工作内存中的缓存立即写入到主内存中去。</li></ul><p>内存屏障细分类：<br>LoadLoad: 保证load1在load2之前执行。<br>StoreStore:保证store1保存在store2保存之前。<br>LoadStore:保证load1读取数据在store1写入数据之前。<br>StoreLoad:保证store保存数据在load读取数据之前。<br><img src="https://img-blog.csdnimg.cn/direct/c30c00405bba415f94aff52fc85a602a.png" alt="在这里插入图片描述"></p><h2 id="JMM针对编译器制定的volatile重排序的规则表："><a href="#JMM针对编译器制定的volatile重排序的规则表：" class="headerlink" title="JMM针对编译器制定的volatile重排序的规则表："></a>JMM针对编译器制定的volatile重排序的规则表：</h2><p><img src="https://img-blog.csdnimg.cn/direct/cd3e1b8af0a84ba2a7144cced49973fb.png" alt="在这里插入图片描述"></p><ul><li>当第一个操作为volatile读时，无论第二个操作是什么，都不能重排序。</li><li>当第二个操作为volatile写时，无论第一个操作是什么，都不能重排。</li><li>当第一个操作是volatile写时，第二个操作是读时，不能重排。</li></ul><h2 id="JMM在指令序列中插入屏障来禁止指令重排"><a href="#JMM在指令序列中插入屏障来禁止指令重排" class="headerlink" title="JMM在指令序列中插入屏障来禁止指令重排"></a>JMM在指令序列中插入屏障来禁止指令重排</h2><ul><li>在volatile写操作的前面加StoreStore屏障</li><li>在volatile写操作的后面加StoreLoad屏障</li><li>在volatile读操作的后面加LoadLoad屏障</li><li>在volatile读操作的后面加LoadStore屏障</li></ul><h1 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h1><p>单一赋值可以，复合赋值是禁止的。一般用来保存某个状态，判断业务是否结束。比如boolean值的flag。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="volatile可见性"><a href="#volatile可见性" class="headerlink" title="volatile可见性"></a>volatile可见性</h2><p>volaile修饰的变量具有可见性。<br>对于写操作，本地内存中修改后，会立即刷回主存中。<br>对于读操作，本地内存会从主存中获取最新的值。</p><h2 id="volatile有序性（禁止指令重排）"><a href="#volatile有序性（禁止指令重排）" class="headerlink" title="volatile有序性（禁止指令重排）"></a>volatile有序性（禁止指令重排）</h2><p>JMM在指令序列中通过插入内存屏障来禁止指令重排，保证有序性。<br>对于volatile写操作：在volatile写操作之前插入StoreStore指令，在volatile写操作之后插入StoreLoad指令来保证指令的有序。<br>对于volatile写操作：在volatile读操作之后插入LoadLoad指令和LoadStore指令，保证指令的有序。<br>参考：<br>1.《Java并发编程的艺术》<br>2.  <a href="https://blog.csdn.net/qq_44300280/article/details/127476199">JMM与volatile</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;volatile简介及作用&quot;&gt;&lt;a href=&quot;#volatile简介及作用&quot; class=&quot;headerlink&quot; title=&quot;volatile简介及作用&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="JUC" scheme="https://liuhsir.top/categories/JUC/"/>
    
    
    <category term="JUC" scheme="https://liuhsir.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC-Java内存模型JMM</title>
    <link href="https://liuhsir.top/2024/01/18/JUC-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/"/>
    <id>https://liuhsir.top/2024/01/18/JUC-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM/</id>
    <published>2024-01-18T10:18:25.000Z</published>
    <updated>2024-01-20T13:49:06.170Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="JMM概述"><a href="#JMM概述" class="headerlink" title="JMM概述"></a>JMM概述</h1><p>Java Meory Model java内存模型。在<strong>不同的硬件和不同的操作系统上</strong>，对内存的访问方式是不一样的。这就造成了同一套java代码运行在不同的操作系统上会出问题。JMM就屏蔽掉硬件和操作系统的差异，增加java代码的可移植性。这是一方面。<br>另一方面JMM定义的一系列规则能够保证线程并发的安全性。主要是保证线程的可见性，有序性，原子性。<br>具体来说它主要就是抽象了线程和主存之间的关系。（如下图）每个线程都有一个工作内存（cpu缓存），工作内存中存放着主存（内存）的副本，一般是共享变量，比如实例变量，静态变量但是不包括局部变量。线程读写数据是直接操作工作内存的。线程不能访问其他线程的工作内存。多个线程间通信是通过主存来完成的。<br><img src="https://img-blog.csdnimg.cn/direct/f55562a92ecc4395970d87f1be4281ac.png" alt="在这里插入图片描述"></p><h1 id="线程三大问题"><a href="#线程三大问题" class="headerlink" title="线程三大问题"></a>线程三大问题</h1><p><strong>原子性，可见性，有序性。（简记：客源有）</strong><br>线程需要满足这三大特性，才能保证线程并发安全。而JMM就是为了实现这三大特性定义的一系列规则。</p><h2 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h2><p>可见性指的是当一个线程修改了共享变量后，另一个线程能够立马得到修改的这个值。但是由于CPU缓存的存在，可见性往往会存在一些问题。<br>比如说在多线程下，每个线程将变量存放在CPU缓存中，一个线程修改了变量后，放在CPU缓存中。另一个线程无法立即得到最新的值。这就造成了共享变量的数据不一致的问题。</p><h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>CPU在执行指令的过程中发生了线程切换，会导致一些变量数据不一致，这种问题就成为原子性问题。</p><h2 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a>有序性问题</h2><p>CPU在执行指令的时候，为了充分利用内部的计算单元，处理器可能会对代码进行乱序执行。CPU在并发环境下，乱序执行可能会到导致结果错误。这种问题就叫做有序性问题。</p><h1 id="JMM解决线程可见性，原子性，有序性问题"><a href="#JMM解决线程可见性，原子性，有序性问题" class="headerlink" title="JMM解决线程可见性，原子性，有序性问题"></a>JMM解决线程可见性，原子性，有序性问题</h1><p>定义Java内存模型并非是一件容易的事情。不能单纯的禁用CPU缓存和编译优化，这样会严重影响程序性能。JMM抽象了线程和主存之间的关系，定义了程序中变量的访问规则来解决上述问题。<br>从抽象的角度来看，JMM定义了线程和主存之间的抽象关系：<strong>线程之间的共享变量存放在主内存中</strong>，每个线程都有一个私有的工作内存，本地内存中存储了主存中共享变量的副本，线程对变量的操作都是在工作内存中进行的。（这里的工作内存是一个抽象的概念。包含了CPU缓存，寄存器以及编译器优化。主内存则指的是物理硬件的主内存。）<br><img src="https://img-blog.csdnimg.cn/direct/ad6b05e8d1cf49a78d3a2a4587ebb539.png" alt="在这里插入图片描述"></p><h2 id="可见性保证"><a href="#可见性保证" class="headerlink" title="可见性保证"></a>可见性保证</h2><p><strong>可见性指的是当一个线程修改了共享变量的值之后，其他线程能够立马得到这个修改</strong>。</p><p><strong>volatile能够保证可见性和有序性</strong>，volatile修饰的变量在本地内存中修改后会立即同步到主存中去，供其他线程访问到。<br>锁也能保证可见性，锁在释放和申请的时候都会更新缓存，从主存中获取最新的值。</p><h2 id="原子性保证"><a href="#原子性保证" class="headerlink" title="原子性保证"></a>原子性保证</h2><p>通过Lock和UnLock来保证。java中是synchronized关键字。synchronized关键字对应的底层jvm指令是monitorenter和moniterexit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有序性保证"><a href="#有序性保证" class="headerlink" title="有序性保证"></a>有序性保证</h2><p>java中提供了volatile和synchronized两个关键字来保证线程之间的有序性。<strong>volatile本身就包含了指令重排的语义。而 synchronized 则是由一个变量在同一时刻只允许一个线程对其进行 lock 操作这条规则来保证有序性的</strong></p><h1 id="JMM核心概念-happens-before"><a href="#JMM核心概念-happens-before" class="headerlink" title="JMM核心概念-happens-before"></a>JMM核心概念-happens-before</h1><p><strong>如果一个操作happens-before另一个操作，那么第一个操作的执行结果对后续的操作是可见的。</strong><br>两个操作存在happens-before关系，并不意味着一定要按照happens-before原则指定的顺序来执行。可以对指令进行重排序，只要保证结果正确性即可。</p><p>参考:<br><a href="https://zhuanlan.zhihu.com/p/416172908">从线程三大特性深入理解JMM（Java 内存模型）</a><br><a href="https://zhuanlan.zhihu.com/p/126275344">happens-before是什么？JMM最最核心的概念，看完你就懂了</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;JMM概述&quot;&gt;&lt;a href=&quot;#JMM概述&quot; class=&quot;headerlink&quot; title=&quot;JMM概述&quot;&gt;&lt;/a&gt;JMM概述&lt;/h1&gt;&lt;p&gt;Java Meory</summary>
      
    
    
    
    <category term="JUC" scheme="https://liuhsir.top/categories/JUC/"/>
    
    
    <category term="JUC" scheme="https://liuhsir.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC-中断机制和LockSupport</title>
    <link href="https://liuhsir.top/2024/01/15/JUC-%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E5%92%8CLockSupport/"/>
    <id>https://liuhsir.top/2024/01/15/JUC-%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E5%92%8CLockSupport/</id>
    <published>2024-01-15T14:28:35.000Z</published>
    <updated>2024-01-15T14:30:40.362Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="线程中断机制"><a href="#线程中断机制" class="headerlink" title="线程中断机制"></a>线程中断机制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>java提供了一种用于停止线程的协商机制-中断。称为中断标识协商机制。</p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li>public void interrupt()<br>仅仅让线程的中断标志位设置为true。不进行其他操作。</li><li>public boolean isInterrupted()<br>获取中断标志位的状态。</li><li>public static boolean interrupted()<br>获取中断标志位的状态。并将中断标志位设置为false</li></ul><h2 id="如何停止中断运行的线程"><a href="#如何停止中断运行的线程" class="headerlink" title="如何停止中断运行的线程"></a>如何停止中断运行的线程</h2><h3 id="volatile变量实现"><a href="#volatile变量实现" class="headerlink" title="volatile变量实现"></a>volatile变量实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isStop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程isStop = true,自己退出&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-------hello interrupt--------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        isStop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AtomicBoolean实现"><a href="#AtomicBoolean实现" class="headerlink" title="AtomicBoolean实现"></a>AtomicBoolean实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">atomicBoolean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (atomicBoolean.get()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-------hello------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        atomicBoolean.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="中断API-interrupt和isInterrupted"><a href="#中断API-interrupt和isInterrupted" class="headerlink" title="中断API interrupt和isInterrupted"></a>中断API interrupt和isInterrupted</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----t1 线程被中断了，程序结束&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----hello-------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1是否被中断：&quot;</span> + t1.isInterrupted());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;t1是否被中断：&quot;</span> + t1.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>如果线程处于正常活动状态，interrupt会将该线程中断状态位设置为true。要想该线程进行进一步处理需要自己根据中断状态为来写业务逻辑。</li><li>如果线程处于阻塞状态（sleep, wait, join）在别的线程调用当前线程interrupt方法，那么线程立即退出阻塞状态，并抛出InterruptException异常，并将中断标志为清除（置为false）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;中断标志位：&quot;</span>+Thread.currentThread().isInterrupted()+<span class="string">&quot; 程序停止&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();<span class="comment">//为什么要在异常处，再调用一次？？</span></span><br><span class="line">                    <span class="comment">// 阻塞状态下的线程设置中断标志位为true,会报异常。中断状态位置为false。导致死循环。因此需要再次设置为true</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;-----hello InterruptDemo3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; t1.interrupt(),<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure></li></ul><p>拓展：线程有哪些状态？7种状态<br>创建，就绪（等待CPU），运行，阻塞(等待锁对象)，等待（等待事件），超时等待，结束<br>sleep不会释放锁。wait会释放锁。因此sleep进入等待状态。wait进入阻塞状态。</p><h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><p>LockSupport是线程阻塞和唤醒的工具类。主要通过park阻塞和unpark唤醒。</p><h2 id="线程等待唤醒机制"><a href="#线程等待唤醒机制" class="headerlink" title="线程等待唤醒机制"></a>线程等待唤醒机制</h2><h3 id="Synchronized锁对象的wait和notify"><a href="#Synchronized锁对象的wait和notify" class="headerlink" title="Synchronized锁对象的wait和notify"></a>Synchronized锁对象的wait和notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----come in&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock)&#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li>必须在Synchronized同步块中</li><li>wait必须在之前notify。否则通知唤醒会失效。</li></ul><h3 id="Lock-condition的await和signal"><a href="#Lock-condition的await和signal" class="headerlink" title="Lock.condition的await和signal"></a>Lock.condition的await和signal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">       <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----come in&quot;</span>);</span><br><span class="line">               condition.await();</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----被唤醒&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">       <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">       <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               condition.signal();</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><h3 id="LockSupport的park和unpark"><a href="#LockSupport的park和unpark" class="headerlink" title="LockSupport的park和unpark"></a>LockSupport的park和unpark</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----come in&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ----被唤醒&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t ----发出通知&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>不需要在锁块中，本身就可以让线程同步。</li><li>park和unpark不需要有先后顺序。unpark相当于给了park一个凭证。unpark在park执行前也可以让park唤醒。相当于提前给了凭证。（而前面两种就不行）</li><li>一个park需要一个凭证。但是不同的unpark作用于一个线程只能给一个凭证。（即是连续调用多次unpark和调用一次作用是一样的）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;线程中断机制&quot;&gt;&lt;a href=&quot;#线程中断机制&quot; class=&quot;headerlink&quot; title=&quot;线程中断机制&quot;&gt;&lt;/a&gt;线程中断机制&lt;/h1&gt;&lt;h2 id=&quot;概</summary>
      
    
    
    
    <category term="JUC" scheme="https://liuhsir.top/categories/JUC/"/>
    
    
    <category term="JUC" scheme="https://liuhsir.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC-锁</title>
    <link href="https://liuhsir.top/2024/01/14/JUC-%E9%94%81/"/>
    <id>https://liuhsir.top/2024/01/14/JUC-%E9%94%81/</id>
    <published>2024-01-14T10:18:25.000Z</published>
    <updated>2024-01-15T02:07:10.123Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>当一个线程在操作资源的时候，会悲观的任务有其他的线程会来抢占该资源，因此会在操作资源前进行加锁，避免其他线程抢占。<br>Synchronized关键字和Lock实现类就是悲观锁。<br>显示的锁定资源后再对资源进行操作。<br><strong>使用场景：</strong></p><ul><li>适合写操作多的场景。先加锁能够保证写操作时数据正确</li></ul><p><strong>本质：</strong><br>加锁去操作同步资源。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>当一个线程去操作资源的时候，会乐观的任务其他线程不会来抢占资源，因此不会加锁。<br>java中通过无锁编程来实现，只是在对数据进行修改的时候，判断其他线程是否对该数据进行修改过</p><ul><li>如果没有修改过，该线程直接修改数据。</li><li>如果修改过，该线程则根据不同的实现方式执行不同的操作，比如放弃修改，重试抢锁等等。</li></ul><p>原子操作类那些底层的是CAS(Compare And swap)算法，也就是乐观锁。<br><strong>判断规则：</strong></p><ul><li>版本号机制Version（每修改一次版本号递增，当前版本号是最大的，可以直接修改。不是最大的，意味着别人修改过了，我的修改要重新处理）</li><li>最常采用的是CAS算法（后面会详细讲，这里略）</li></ul><p><strong>使用场景：</strong><br>乐观锁适合读操作多的场景，不加锁读操作性能大幅提升<br><strong>本质：</strong><br>无锁去操作同步资源。</p><h1 id="乐观锁和悲观锁举例"><a href="#乐观锁和悲观锁举例" class="headerlink" title="乐观锁和悲观锁举例"></a>乐观锁和悲观锁举例</h1><p>乐观锁：Synchronized和Lock的实现类<br>悲观锁：原子操作的类<br><img src="https://img-blog.csdnimg.cn/direct/82617594cb364fb69f046175f4d8e9b0.png" alt="在这里插入图片描述"></p><h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h2 id="阿里加锁规范"><a href="#阿里加锁规范" class="headerlink" title="阿里加锁规范"></a>阿里加锁规范</h2><p>高并发时，同步调用时需要考虑加锁性能损耗。能用无锁数据结构就用无锁数据结构。能用块锁，就不要锁方法体。能用对象锁，就不要用类锁。<br>（尽可能让锁的代码块尽可能小，避免锁造成不必要的性能开销）</p><h2 id="Synchronized三种作用方式"><a href="#Synchronized三种作用方式" class="headerlink" title="Synchronized三种作用方式"></a>Synchronized三种作用方式</h2><p>作用于实例方法：当前实例加锁，进入实例前要获取当前实例的锁对象。<br>作用于代码块：对括号里的对象进行加锁。<br>作用于静态方法（类方法）：对当前类加锁，进去同步代码前要获得当前对象的锁。</p><h2 id="Synchronized作用于非静态方法和静态方法的区别（重要）"><a href="#Synchronized作用于非静态方法和静态方法的区别（重要）" class="headerlink" title="Synchronized作用于非静态方法和静态方法的区别（重要）"></a>Synchronized作用于非静态方法和静态方法的区别（重要）</h2><p><strong>类中Synchronized修饰非静态方法（对象锁）</strong></p><ul><li>加的锁为this对象锁。 </li><li>一个对象只有一把对象锁，因此多个线程执行一个对象的非静态同步方法时，存在竞争关系。先获得对象锁的线程先执行。（不同对象不会有竞争）</li><li>不同对象有不同的对象锁，线程如果持有不同对象锁，线程间无竞争的关系。</li></ul><p><strong>类中Synchronized修饰静态方法（类锁）</strong></p><ul><li>加的锁为类锁。 </li><li>先获得类锁的线程先执行。多个线程执行同一个类模板的不同对象的静态同步方法的时候，存在竞争关系。先获得类锁的线程先执行。（同一个对象会竞争，不同对象也会竞争）</li><li>不同类有不同的类锁，线程如果持有不同的类锁，线程间无竞争关系</li><li>一个对象的类锁和对象锁是不同的锁。一个线程持有类锁，一个线程持有对象锁，线程间无竞争关系。</li></ul><p> <strong>类中无Syncronize修饰的方法（和锁无关）</strong><br> 线程执行该方法不需要获得锁，直接执行就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：谈谈你对多线程锁的理解,8锁案例说明</span></span><br><span class="line"><span class="comment"> * 口诀：线程   操作  资源类</span></span><br><span class="line"><span class="comment"> * 8锁案例说明：</span></span><br><span class="line"><span class="comment"> * 1 标准访问有ab两个线程，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 2 sendEmail方法中加入暂停3秒钟，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 3 添加一个普通的hello方法，请问先打印邮件还是hello</span></span><br><span class="line"><span class="comment"> * 4 有两部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 5 有两个静态同步方法，有1部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 6 有两个静态同步方法，有2部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 7 有1个静态同步方法，有1个普通同步方法,有1部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> * 8 有1个静态同步方法，有1个普通同步方法,有2部手机，请问先打印邮件还是短信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 笔记总结：</span></span><br><span class="line"><span class="comment"> * 1-2(对象锁)</span></span><br><span class="line"><span class="comment"> *  *  *  一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span></span><br><span class="line"><span class="comment"> *  *  *  其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一的一个线程去访问这些synchronized方法</span></span><br><span class="line"><span class="comment"> *  *  *  锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span></span><br><span class="line"><span class="comment"> *  3-4</span></span><br><span class="line"><span class="comment"> *  *  加个普通方法后发现和同步锁无关</span></span><br><span class="line"><span class="comment"> *  *  换成两个对象后，不是同一把锁了，情况立刻变化。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  5-6（类锁） 都换成静态同步方法后，情况又变化</span></span><br><span class="line"><span class="comment"> *  三种 synchronized 锁的内容有一些差别:</span></span><br><span class="line"><span class="comment"> * 对于普通同步方法，锁的是当前实例对象，通常指this,具体的一部部手机,所有的普通同步方法用的都是同一把锁——&gt;实例对象本身，</span></span><br><span class="line"><span class="comment"> * 对于静态同步方法，锁的是当前类的Class对象，如Phone.class唯一的一个模板</span></span><br><span class="line"><span class="comment"> * 对于同步方法块，锁的是 synchronized 括号内的对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * *  7-8</span></span><br><span class="line"><span class="comment"> *  *    当一个线程试图访问同步代码时它首先必须得到锁，正常退出或抛出异常时必须释放锁。</span></span><br><span class="line"><span class="comment"> *  *  *</span></span><br><span class="line"><span class="comment"> *  *  *  所有的普通同步方法用的都是同一把锁——实例对象本身，就是new出来的具体实例对象本身,本类this</span></span><br><span class="line"><span class="comment"> *  *  *  也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。</span></span><br><span class="line"><span class="comment"> *  *  *</span></span><br><span class="line"><span class="comment"> *  *  *  所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class</span></span><br><span class="line"><span class="comment"> *  *  *  具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的</span></span><br><span class="line"><span class="comment"> *  *  *  但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//一切程序的入口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒,保证a线程先启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line"><span class="comment">//            phone.hello();</span></span><br><span class="line"><span class="comment">//            phone2.sendSMS();</span></span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字节码角度分析Synchronized"><a href="#字节码角度分析Synchronized" class="headerlink" title="字节码角度分析Synchronized"></a>字节码角度分析Synchronized</h2><h3 id="查看反汇编："><a href="#查看反汇编：" class="headerlink" title="查看反汇编："></a>查看反汇编：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c *.java<span class="comment">// -c对代码进行反汇编。 -v (verbose)输出附加信息行号，本地变量表，反汇编</span></span><br></pre></td></tr></table></figure><h3 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h3><ul><li>实现使用的是monitorenter和monitorexit。monitorenter代表获得锁对象，monitorexit代表释放锁对象。</li><li>通常情况下，一个monitorenter对应两个monitorexit，正常情况下，从第一个monitorexit释放锁。异常情况下，从第二个monitorexit释放锁。</li></ul><h3 id="synchronized普通同步方法"><a href="#synchronized普通同步方法" class="headerlink" title="synchronized普通同步方法"></a>synchronized普通同步方法</h3><p>调用指令时，先检查ACC_SYNCHRONIZED（Access）标志是否被设置了，如果该方法有这个标志，代表是同步方法，访问的时候要获取锁对象。<br>方法完成时（无论是否正常介数）释放锁。</p><h3 id="synchronized静态同步方法"><a href="#synchronized静态同步方法" class="headerlink" title="synchronized静态同步方法"></a>synchronized静态同步方法</h3><p>调用指令时，ACC_STATIC，和ACC_SYNCHRONIZED标志。第一个表示是否静态方法，第二个表示是否同步方法。</p><h3 id="反编译Synchronized锁是什么"><a href="#反编译Synchronized锁是什么" class="headerlink" title="反编译Synchronized锁是什么"></a>反编译Synchronized锁是什么</h3><p><strong>为什么任何一个对象都可以成为锁？</strong><br>Java虚拟机支持方法级<br><strong>什么是管程？</strong><br>管程（Monitor）:可以看做是一个功能模块，他将共享变量和对共享变量的操作封装起来。进程可以调用管程实现进程间的并发控制。<br><strong>同步指令实现？</strong><br>Java虚拟机支持<strong>方法级的同步</strong>和<strong>方法内部指令序列的同步</strong>，这两种同步结构都是由管程（Monitor或者称为锁）来实现的。</p><ul><li>方法级的同步：通过读取ACC_SYNCHRONIZED判断是否是同步方法，如果是同步方法，执行线程要求必须持有管程（锁）。执行完毕后释放锁。</li><li>方法内部指令序列的同步：同步一段指令序列是通过synchronized方法块来表示。java虚拟机指令集中的monitorenter和monitorexit指令实现的。</li></ul><h3 id="Monitor的实现-OjectMonitor"><a href="#Monitor的实现-OjectMonitor" class="headerlink" title="Monitor的实现 OjectMonitor"></a>Monitor的实现 OjectMonitor</h3><p>每个对象都关联一个ObjectMonitor锁对象。他有一些属性来保证该资源的同步安全。<br><img src="https://img-blog.csdnimg.cn/direct/87c532c89f8f44bab5635d3708516170.png" alt="在这里插入图片描述"><br>ower: 持有该锁的线程<br>waitset：存放处于wait状态的线程队列<br>entrylist：存放等待锁的线程队列<br>recursions（递归）：锁的重入次数<br>count: 记录该线程获取锁的次数。<br><img src="https://img-blog.csdnimg.cn/direct/ae6945e8743347b39f3e46a1febc72aa.png" alt="在这里插入图片描述"></p><h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><h2 id="公平锁-先来先得"><a href="#公平锁-先来先得" class="headerlink" title="公平锁(先来先得)"></a>公平锁(先来先得)</h2><p>多个线程按照线程请求锁的先后顺序获取锁。默认都是非公平锁，公平锁需要设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);/l/<span class="literal">true</span>表示公平锁,先来先得</span><br></pre></td></tr></table></figure><p><strong>执行流程：</strong><br>获取锁的时候，会将线程自己添加到等待队列中并休眠。当线程使用完锁之后，会去唤醒等待队列首部的线程。线程的休眠和恢复需要从用户态转换为内核态，线程切换是比较慢的，所以公平锁的执行较慢。</p><h2 id="非公平锁（随机获得锁，默认）"><a href="#非公平锁（随机获得锁，默认）" class="headerlink" title="非公平锁（随机获得锁，默认）"></a>非公平锁（随机获得锁，默认）</h2><p>每个线程获取到锁的顺序是随机的，并不会按照先来先得的顺序。所有的线程会竞争获取锁。<br><strong>执行流程：</strong><br>当线程申请锁时，会通过CAS尝试获取锁。如果获取成功，就持有锁对象。如果获取失败，就进入等待队列。好处是不用遵循先到先得的原则，避免了线程的休眠和恢复过程，执行更快。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>默认是非公平锁。能够让程序执行更快（追求效率）。<br>非公平锁可能造成线程饿死的情况。</p><h1 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>可重入锁又叫递归锁。一个线程在<strong>外部方法</strong>中获取到锁的时候。在进入内部方法需要获取锁的时候，线程会自动获取到该锁。而不会阻塞。</p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><h3 id="隐式锁（Synchronized关键字修饰的）："><a href="#隐式锁（Synchronized关键字修饰的）：" class="headerlink" title="隐式锁（Synchronized关键字修饰的）："></a>隐式锁（Synchronized关键字修饰的）：</h3><p>线程在外部获取锁之后，内部自动获取到锁。<br><strong>实现原理</strong><br>每个锁对象ObjectMonitor都有一个<strong>count计数器</strong>和<strong>ower</strong>持有该锁对象的线程。<br>当执行monitorenter的时候：会看count计数器是否为0，如果为0说明该锁对象没有被其他线程占有，将count计数器+1，将ower设置为当前的线程。如果不为0，该线程需要等待。<br>当执行monitorexit的时候：会将count计数器减一，count为0代表可以释放。将ower清空。</p><h3 id="显式锁（Lock实现类）"><a href="#显式锁（Lock实现类）" class="headerlink" title="显式锁（Lock实现类）"></a>显式锁（Lock实现类）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();<span class="comment">//加锁</span></span><br><span class="line">lock.unlock();<span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p>加锁和释放锁的次数要一样，不然会导致该线程一直持有锁。其他线程无法获取锁。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>一个线程持有某个锁对象，有需要申请其他的锁对象。其他锁对象被另一个线程占有。在无外力干扰的情况下，一直处于僵持状态。<br>举例： A线程持有obj1锁对象，申请obj2锁对象。B线程持有obj2锁对象，申请obj1锁对象。A，B线程均被阻塞住，处于僵持状态。</p><h2 id="手写一个死锁的例子"><a href="#手写一个死锁的例子" class="headerlink" title="手写一个死锁的例子"></a>手写一个死锁的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + <span class="string">&quot;拿到了obj1锁对象&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;等待obj2锁对象...&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + <span class="string">&quot;拿到了obj2锁对象&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + <span class="string">&quot;拿到了obj2锁对象&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;等待obj1锁对象...&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + <span class="string">&quot;拿到了obj1锁对象&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/direct/eab87490f8dc409a9d71968088de3e24.png" alt="在这里插入图片描述"></p><h2 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h2><h3 id="第一种方式命令行jps-jstack"><a href="#第一种方式命令行jps-jstack" class="headerlink" title="第一种方式命令行jps+jstack"></a>第一种方式命令行jps+jstack</h3><p>jps查看死锁线程编号 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/direct/ef155509969849eb8adeb9d264bb1603.png" alt="在这里插入图片描述"><br>jstack 查看当前时刻的线程快照</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack <span class="number">13992</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/direct/685a70dc8758458e933ea0f619e54237.png" alt="在这里插入图片描述"></p><h3 id="第二种jconsole图形化界面"><a href="#第二种jconsole图形化界面" class="headerlink" title="第二种jconsole图形化界面"></a>第二种jconsole图形化界面</h3><p><img src="https://img-blog.csdnimg.cn/direct/6c752cb44dbe477693ee6d0734b37518.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/bc3282df5403455a87a2afd8d3280d2c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/f8248749f36e495a8c621a1f2389360f.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;乐观锁和悲观锁&quot;&gt;&lt;/a&gt;乐观锁和悲观锁&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="JUC" scheme="https://liuhsir.top/categories/JUC/"/>
    
    
    <category term="JUC" scheme="https://liuhsir.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC-CompletableFuture</title>
    <link href="https://liuhsir.top/2024/01/13/JUC-CompletableFuture/"/>
    <id>https://liuhsir.top/2024/01/13/JUC-CompletableFuture/</id>
    <published>2024-01-13T10:18:25.000Z</published>
    <updated>2024-01-13T12:20:51.505Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="Future接口理论"><a href="#Future接口理论" class="headerlink" title="Future接口理论"></a>Future接口理论</h1><p>Future接口定义了异步任务执行的一些方法，包括异步任务执行结果，异步任务执行是否中断，异步任务是否完毕等。</p><h2 id="Future接口常用实现类FutureTask异步任务"><a href="#Future接口常用实现类FutureTask异步任务" class="headerlink" title="Future接口常用实现类FutureTask异步任务"></a>Future接口常用实现类FutureTask异步任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;( () -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t -----come in&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;task over&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><h2 id="CompletableFuture对Future的改进"><a href="#CompletableFuture对Future的改进" class="headerlink" title="CompletableFuture对Future的改进"></a>CompletableFuture对Future的改进</h2><ul><li>CompletableFuture异步线程发生异常，不会影响到主线程，用来记录日志特别方便。</li><li>CompletableFuture出现的原因：Future的get方法是阻塞方法，当异步线程计算完成之前一直会阻塞，isDone()方法判断异步线程又特别消耗CPU资源。对于真正的异步处理我们希望传入回调函数，在Future结束时，自动调用该回调函数。这样我们就不用等待结果 。</li><li>CompletableFuture提供了一种观察者模式，可以让任务完成后通知监听的一方。<br><img src="https://img-blog.csdnimg.cn/direct/46ae4ec682574e16854c838b65e71c66.png" alt="在这里插入图片描述"></li></ul><h2 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h2><ul><li>CompltionStage是异步执行的一个阶段。一个阶段执行完成之后可能触发另一个阶段。</li><li>一个阶段的执行可以是一个Function,Comsumer或者Runnable。比如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stage.thenApply(x -&gt; square(x)).thenAccept(×-&gt;System.out.print(x)).thenRun(( -&gt;system.out.println())</span><br></pre></td></tr></table></figure></li><li>一个阶段可能会是另一个阶段完成后触发。也可能是其他多个阶段完成后触发。</li></ul><h2 id="CompletableFuture的方法"><a href="#CompletableFuture的方法" class="headerlink" title="CompletableFuture的方法"></a>CompletableFuture的方法</h2><p><img src="https://img-blog.csdnimg.cn/direct/1100bbdf3750483b81b7d5428cef5674.png" alt="在这里插入图片描述"><br>主要是runAsync和supplyAsnc方法。一个无返回值。一个有返回值。</p><h2 id="CompletableFuture的优点"><a href="#CompletableFuture的优点" class="headerlink" title="CompletableFuture的优点"></a>CompletableFuture的优点</h2><ul><li>异步任务执行完成后，会自动调用某个对象的方法</li><li>异步任务出异常后，会自动调用某个对象的方法</li><li>主线程设置好回调后，不用关心异步任务的执行。异步任务之间可以顺序执行。</li></ul><h2 id="案例-前言"><a href="#案例-前言" class="headerlink" title="案例 - 前言"></a>案例 - 前言</h2><p>join和get的区别。get必须处理异常。join不需要处理异常<br>jdk8新特性： lambda表达式，stream流，chain链式调用，函数式编程<br><img src="https://img-blog.csdnimg.cn/direct/a6fefc53a2d64744936879b48974201f.png" alt="在这里插入图片描述"><br>有参数，有返回值：Function<br>有参数，无返回值：Consume, BiConsumer（两个参数）<br>无参数，有返回值：Supplier<br>无参数，无返回值：Runnable</p><h2 id="案例-从电商网站的比价需求"><a href="#案例-从电商网站的比价需求" class="headerlink" title="案例-从电商网站的比价需求"></a>案例-从电商网站的比价需求</h2><p>原来的写法，<strong>串行的方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * step by step 一家家搜查</span></span><br><span class="line"><span class="comment"> * List&lt;NetMall&gt; -----&gt;map------&gt; List&lt;String&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPrice</span><span class="params">(List&lt;NetMall&gt; list,String productName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//《mysql》 in taobao price is 90.43</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">            .stream()</span><br><span class="line">            .map(netMall -&gt;</span><br><span class="line">                    String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">                            netMall.getNetMallName(),</span><br><span class="line">                            netMall.calcPrice(productName)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用CompletableFuture，<strong>异步的方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * List&lt;NetMall&gt; -----&gt;List&lt;CompletableFuture&lt;String&gt;&gt;------&gt; List&lt;String&gt;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> productName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByCompletableFuture</span><span class="params">(List&lt;NetMall&gt; list,String productName)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> list.stream().map(netMall -&gt;</span><br><span class="line">               CompletableFuture.supplyAsync(() -&gt; String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">               netMall.getNetMallName(),</span><br><span class="line">               netMall.calcPrice(productName))))</span><br><span class="line">               .collect(Collectors.toList())</span><br><span class="line">               .stream()</span><br><span class="line">               .map(s -&gt; s.join())</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>耗时：比串行的方式快得多！！！</p><h1 id="CompletableFuture-常用方法"><a href="#CompletableFuture-常用方法" class="headerlink" title="CompletableFuture 常用方法"></a>CompletableFuture 常用方法</h1><h2 id="获得结果和触发计算"><a href="#获得结果和触发计算" class="headerlink" title="获得结果和触发计算"></a>获得结果和触发计算</h2><p>获得结果：</p><ul><li>public T get() 一直等</li><li>public T get(long timeout,TimeUnit unit) 过时不候，到了时间没拿到结果会报异常</li><li>public T join()：join和get都是用来获取CompletableFuture异步之后的返回值。join是unchecked异常（即运行时异常）。get是checked异常（经过检查的异常）</li><li>public T getNow(T valuelfAbsent)：没有计算完，给我默认的结果。计算完，返回实际的结果。</li></ul><p>主动触发计算：</p><ul><li>public boolean complete(T value) 如果CompletableFuture没有完成，将get结果修改为value，返回值为true。如果完成了，不修改get，返回值为false.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;</span><br><span class="line">      CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;hello CompletableFuture&quot;</span>;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      System.out.println(completableFuture.getNow(<span class="string">&quot;心急吃不了热豆腐&quot;</span>));</span><br><span class="line">      System.out.println(completableFuture.get());</span><br><span class="line">      System.out.println(completableFuture.get(<span class="number">1500</span>, TimeUnit.MILLISECONDS));</span><br><span class="line">      System.out.println(completableFuture.join());</span><br><span class="line">      System.out.println(completableFuture.complete(<span class="string">&quot;未雨绸缪&quot;</span>)+<span class="string">&quot;\t&quot;</span>+completableFuture.join());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对计算结果进行处理"><a href="#对计算结果进行处理" class="headerlink" title="对计算结果进行处理"></a>对计算结果进行处理</h2><h3 id="thenApply（常用）"><a href="#thenApply（常用）" class="headerlink" title="thenApply（常用）"></a>thenApply（常用）</h3><p>两个计算结果存在依赖关系，这两个线程串行化。<br>出现异常，直接跳到whenComplete和exceptionally执行。（不再执行后续的thenApply）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        &#125;,executorService).thenApply((r)-&gt; &#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">2</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> r * <span class="number">5</span>;</span><br><span class="line">        &#125;).thenApply((r)-&gt; &#123;</span><br><span class="line">            System.out.println(r);</span><br><span class="line">            <span class="keyword">return</span> r - <span class="number">2</span>;</span><br><span class="line">        &#125;).whenComplete((v, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span>+v);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;============主线程==========&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h3><p>计算机结果存在依赖关系，两个线程串行化<br>handle出现异常，会往下一个handle走，同时也会走到whenComplete和exceptionally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        &#125;,executorService).handle((r,e)-&gt; &#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">2</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> r * <span class="number">5</span>;</span><br><span class="line">        &#125;).handle((r,e)-&gt; &#123;</span><br><span class="line">            System.out.println(r);</span><br><span class="line">            <span class="keyword">return</span> r - <span class="number">2</span>;</span><br><span class="line">        &#125;).whenComplete((v, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果：&quot;</span>+v);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;============主线程==========&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>exceptionally相当于try catch<br>whenComplete和handler相当于try finally<br><img src="https://img-blog.csdnimg.cn/direct/09bd133ab668407b805812264ec33c09.png" alt="在这里插入图片描述"></p><h2 id="对计算结果进行消费"><a href="#对计算结果进行消费" class="headerlink" title="对计算结果进行消费"></a>对计算结果进行消费</h2><p>接受任务的处理结果，消费处理。thenAccept无返回结果。（thenApply是有返回结果的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;).thenApply(r-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> r*<span class="number">8</span>;</span><br><span class="line">        &#125;).thenApply(r-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> r/<span class="number">2</span>;</span><br><span class="line">        &#125;).thenAccept(r-&gt; System.out.println(r));</span><br><span class="line">        System.out.println(CompletableFuture.supplyAsync(()-&gt;<span class="string">&quot;6666&quot;</span>).thenRun(()-&gt;&#123;&#125;).join());</span><br><span class="line">        System.out.println(CompletableFuture.supplyAsync(()-&gt;<span class="string">&quot;6666&quot;</span>).thenAccept(r-&gt; System.out.println(r)).join());</span><br><span class="line">        System.out.println(CompletableFuture.supplyAsync(()-&gt;<span class="string">&quot;6666&quot;</span>).thenApply(r-&gt;r+<span class="string">&quot;9999&quot;</span>).join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">null</span><br><span class="line">6666</span><br><span class="line">null</span><br><span class="line">66669999</span><br></pre></td></tr></table></figure><h2 id="对计算速度进行选用与对计算结果进行合并"><a href="#对计算速度进行选用与对计算结果进行合并" class="headerlink" title="对计算速度进行选用与对计算结果进行合并"></a>对计算速度进行选用与对计算结果进行合并</h2><p>applyToEither：谁快用谁<br>thenCombine: 两个completionStage任务都完成后，将结果交给thenCombine。先完成的先等着，等待其他分支任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; first = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1号选手&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; second = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2号选手&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; result = first.applyToEither(second, r -&gt; r + <span class="string">&quot;is winner&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;String&gt; res = first.thenCombine(second, (x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(result.join());</span><br><span class="line">        System.out.println(res.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h2><p>allOf():当所有给定的CompletableFuture完成时， 返回一个新的CompletableFuture<br>anyOf():当任何一个给定的CompletableFuture完成时，返回一个新的CompletableFuture</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllOf</span><span class="params">()</span>&#123;</span><br><span class="line">       CompletableFuture&lt;String&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;future1执行完成&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       CompletableFuture&lt;String&gt; future2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;future2执行完成&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(future1, future2);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           all.get(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="completableFuture和线程池说明"><a href="#completableFuture和线程池说明" class="headerlink" title="completableFuture和线程池说明"></a>completableFuture和线程池说明</h1><p>以thenRun和thenRunAsync为例，有什么区别？</p><ul><li>没有传入自定义线程池，默认是ForkJoinPool.</li><li>如果第一个执行的任务传入了一个自定义线程池，调用thenRun执行第二个任务，则第一个和第二个都是用自定义的线程池。</li><li>如果第一个执行的任务传入了一个自定义线程池，调用thenRunAsyn执行第二个任务，则第一个用自定义。第二个用ForkJoinPool（后面也都是ForkJoinPool）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;Future接口理论&quot;&gt;&lt;a href=&quot;#Future接口理论&quot; class=&quot;headerlink&quot; title=&quot;Future接口理论&quot;&gt;&lt;/a&gt;Future接口</summary>
      
    
    
    
    <category term="JUC" scheme="https://liuhsir.top/categories/JUC/"/>
    
    
    <category term="JUC" scheme="https://liuhsir.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>复习sql-内连接，左外连接，右外连接，全外连接，交叉连接</title>
    <link href="https://liuhsir.top/2024/01/06/%E5%86%85%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5/"/>
    <id>https://liuhsir.top/2024/01/06/%E5%86%85%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5/</id>
    <published>2024-01-06T02:18:25.000Z</published>
    <updated>2024-01-24T07:30:23.292Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="数据表准备-学生表-和-课程表"><a href="#数据表准备-学生表-和-课程表" class="headerlink" title="数据表准备 学生表 和 课程表"></a>数据表准备 学生表 和 课程表</h1><p><img src="https://img-blog.csdnimg.cn/direct/312b27d4246a4a11be97d03ce8904cd9.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/direct/3a5d0335686f48bf8648e99fe6e3115f.png" alt="在这里插入图片描述"></p><h1 id="内连接-join-或-innner-join"><a href="#内连接-join-或-innner-join" class="headerlink" title="内连接 join 或 innner join"></a>内连接 join 或 innner join</h1><p>筛选出满足条件的列，where也可以实现这种功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">JOIN</span> course <span class="keyword">ON</span> student.student_id <span class="operator">=</span> course.stu_id</span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/direct/2491409e4183406e9a5ba0db88cc6a23.png" alt="在这里插入图片描述"></p><p>注： 如果不加where, 是笛卡尔积的结果，同交叉连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">JOIN</span> course 或者</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student, course</span><br></pre></td></tr></table></figure><h1 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h1><h2 id="左外连接-left-join-或者-left-outer-join"><a href="#左外连接-left-join-或者-left-outer-join" class="headerlink" title="左外连接 left join 或者 left outer join"></a>左外连接 left join 或者 left outer join</h2><p>以第一个表为基础，第二个表找不到的项就设置为NULL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course <span class="keyword">ON</span> student.student_id <span class="operator">=</span> course.stu_id</span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/direct/af30551ef1884f1d859c5f65efcbd593.png" alt="在这里插入图片描述"></p><h2 id="右外连接-right-join-或者-right-outer-join"><a href="#右外连接-right-join-或者-right-outer-join" class="headerlink" title="右外连接 right join 或者 right outer join"></a>右外连接 right join 或者 right outer join</h2><p>以第二个表为基础，第一个表找不到的项就设置为NULL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> course <span class="keyword">ON</span> student.student_id <span class="operator">=</span> course.stu_id</span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/direct/a81d167aea5e4447bfd4019c702ef9c1.png" alt="在这里插入图片描述"></p><h2 id="全外连接-full-join-或者-full-outer-join（SQL-Server有，MYSQL没有全外连接）"><a href="#全外连接-full-join-或者-full-outer-join（SQL-Server有，MYSQL没有全外连接）" class="headerlink" title="全外连接 full join 或者 full outer join（SQL Server有，MYSQL没有全外连接）"></a>全外连接 full join 或者 full outer join（SQL Server有，MYSQL没有全外连接）</h2><p>左外连接+右外连接的结果。<br><img src="https://img-blog.csdnimg.cn/direct/d6fdc58e1ae94bba8476f264862fcd12.png" alt="在这里插入图片描述"></p><h1 id="交叉连接（笛卡尔积）"><a href="#交叉连接（笛卡尔积）" class="headerlink" title="交叉连接（笛卡尔积）"></a>交叉连接（笛卡尔积）</h1><p>表1的每一行都与表2的每一行拼接。（笛卡尔积）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> course</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/direct/3ff86e5fc79d422f968df16ffe371ee1.png" alt="在这里插入图片描述"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/Duancf/p/11453611.html">通俗易懂的join、left join、right join、full join、cross join</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 





&lt;h1 id=&quot;数据表准备-学生表-和-课程表&quot;&gt;&lt;a href=&quot;#数据表准备-学生表-和-课程表&quot; class=&quot;headerlink&quot; title=&quot;数据表准备 学生表 </summary>
      
    
    
    
    <category term="数据库" scheme="https://liuhsir.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="https://liuhsir.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>服务器GPU温度过高挂掉排查记录</title>
    <link href="https://liuhsir.top/2023/12/31/%E6%9C%8D%E5%8A%A1%E5%99%A8GPU%E6%B8%A9%E5%BA%A6%E8%BF%87%E9%AB%98%E6%8C%82%E6%8E%89%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/"/>
    <id>https://liuhsir.top/2023/12/31/%E6%9C%8D%E5%8A%A1%E5%99%A8GPU%E6%B8%A9%E5%BA%A6%E8%BF%87%E9%AB%98%E6%8C%82%E6%8E%89%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/</id>
    <published>2023-12-31T10:18:25.000Z</published>
    <updated>2024-01-06T12:26:42.865Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>印象深刻的跨年日，2023年最后一天在实验室维修服务器。</p><h1 id="服务器GPU挂掉"><a href="#服务器GPU挂掉" class="headerlink" title="服务器GPU挂掉"></a>服务器GPU挂掉</h1><p>跑深度学习的代码的时候发现中断了。通过命令查看：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>显示</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to determine the device handle for GPU 0000:01:00.0: Unknown Error。</span><br></pre></td></tr></table></figure><p>感觉很莫名其妙。通过重启大法之后，又能用一段时间。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure><p>但是过了一个小时左右又会挂掉。不能从根本解决问题。那么到底为什么GPU会自己挂掉呢？</p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>通过查看日志定位错误原因：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-bug-report.sh</span><br></pre></td></tr></table></figure><p>在当前目录下生成了nvidia-bug-report.log日志文件。查看到日志文件的内容如下：</p><p><img src="https://img-blog.csdnimg.cn/direct/2bc36a8dfe0440419e23398b100fa4f6.jpeg" alt="在这里插入图片描述"><br>网上查找一下这个报错码79<a href="https://forums.developer.nvidia.com/t/gpu-has-fallen-of-the-bus/122124">https://forums.developer.nvidia.com/t/gpu-has-fallen-of-the-bus/122124</a>发现要么是电源问题，要么是温度过高问题。<br><img src="https://img-blog.csdnimg.cn/direct/99125333e9ce445db970c236be10efe2.jpeg" alt="在这里插入图片描述"></p><h1 id="重现问题，查看温度日志"><a href="#重现问题，查看温度日志" class="headerlink" title="重现问题，查看温度日志"></a>重现问题，查看温度日志</h1><p>如果判断是否是GPU温度过高呢？需要打一个温度日志，再运行一下代码，看GPU温度是否超过了shutdown 温度（GPU温度过高会自动掉线保护GPU）。命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi -q -l 2 -d TEMPERATURE -f nvidiatemp.log </span><br></pre></td></tr></table></figure><p>代码继续跑，等待问题重现后查看温度日志就可以确定是否是温度过高导致GPU自动掉线了。<br>果然，当GPU掉线后，查看温度日志：<br><img src="https://img-blog.csdnimg.cn/direct/5825b648c3424fa8932764e30b9471be.png" alt="在这里插入图片描述"><br>上图中CurrentTemp表示当前温度，Shutdown Temp表示超过这个温度GPU会自动掉线。Target Temp表示目标温度（GPU比较合适的温度）。<br>找到问题了！就是温度过热导致GPU掉线！</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>温度过热？<br>多半是散热不行，果然，发现一个风扇明显转的较慢。猜测可能是那个风扇坏掉了。<br>于是将显卡风扇拆下来。通过拨动发现其中一个风扇没另一个风扇灵活。拆开发现转轴有点杂质，增大了风扇阻力，清理了一下,上了点润滑油。（当然直接换风扇最为方便！！！免得担心风扇被拆坏掉）<br><img src="https://img-blog.csdnimg.cn/direct/0d5ceb2d59eb491f997f1d488a1f47fd.jpeg" alt="在这里插入图片描述"></p><p>装上后发现能正常工作，温度再也没有超负荷过！问题完美解决！</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://forums.developer.nvidia.com/t/gpu-has-fallen-of-the-bus/122124%5D">gpu-has-fallen-of-the-bus</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;印象深刻的跨年日，2023年最后一天在实验室</summary>
      
    
    
    
    <category term="解决方法" scheme="https://liuhsir.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="硬件" scheme="https://liuhsir.top/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>从JVM角度对java中引用的理解</title>
    <link href="https://liuhsir.top/2023/12/01/%E4%BB%8EJVM%E8%A7%92%E5%BA%A6%E5%AF%B9java%E4%B8%AD%E5%BC%95%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://liuhsir.top/2023/12/01/%E4%BB%8EJVM%E8%A7%92%E5%BA%A6%E5%AF%B9java%E4%B8%AD%E5%BC%95%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2023-12-01T11:18:25.000Z</published>
    <updated>2024-01-15T09:09:50.133Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <p>学java这么久了，对java引用越来越深刻，好好梳理一下下面三个问题，带着问题进行理解。</p><h1 id="什么是引用？引用存放在jvm哪个区域？"><a href="#什么是引用？引用存放在jvm哪个区域？" class="headerlink" title="什么是引用？引用存放在jvm哪个区域？"></a>什么是引用？引用存放在jvm哪个区域？</h1><p><strong>引用是一种变量类型。引用类型占四个字节。</strong><br>变量类型分为基本类型和引用类型。<br>我们知道java中有8种基本数据类型+Sring引用类型：byte,short,int,long,float,double,char,boolean。<br>引用类型一般为实例对象的引用。可以理解为该对象存放的地址。注意引用和对象时不一样的。<br>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">instanceVariable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> instanceVariableInt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">localVariable</span> <span class="operator">=</span> <span class="built_in">this</span>.instanceVariable;  <span class="comment">// 假设程序刚执行完这一行</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的new Object（）为实例对象，存放在堆中。instanceVariable 为引用类型，作为实例的一部分也存放在堆内存中。<br>上图的localVariable 也是引用类型，他是局部变量的引用类型，存放在虚拟机栈的栈帧中。<br><img src="https://img-blog.csdnimg.cn/direct/a3fbcaa25fe447c1a5ca08baa8731619.png" alt="在这里插入图片描述"></p><p>参考：<a href="https://www.zhihu.com/question/387738123">java 成员变量中的引用类型变量如何保存？</a></p><h1 id="引用和地址区别？"><a href="#引用和地址区别？" class="headerlink" title="引用和地址区别？"></a>引用和地址区别？</h1><p>java地址：java规范中没有地址的概念。如果不讨论jvm的实现，就没有这种概念。<br>深入理解：如果深入研究。地址和引用的差异是由GC造成的。特别是引用具有重新定位对象的能力。而地址是基本不会变的。<br>举例：<br>假设内存中有一个实例对象object，地址为10050。在GC之后，指向object的引用仍将指向object。但是object并不在原来的位置了。</p><p>参考：<a href="https://stackoverflow.com/questions/68814098">https://stackoverflow.com/questions/68814098</a></p><h1 id="java函数是值传递还是引用传递？"><a href="#java函数是值传递还是引用传递？" class="headerlink" title="java函数是值传递还是引用传递？"></a>java函数是值传递还是引用传递？</h1><p>java中参数列表中有两种数据类型，一种是基本数据类型一种是引用数据类型。在java函数中实参和形参之间的传递是值传递！（引用对象传递的是引用值，并不是说传递的是引用就是引用传递）</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型在实参传递给形参的过程中，实参将值复制给形参，形参是存放在栈帧中的局部变量表中的，无论如何修改只会修改形参的值，不会影响到传入的实参。</p><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>引用数据类型传参的过程中，实参传递给形参的是引用数据类型的值。对形参引用数据类型本身操作是不会影响到实参的。但是对形参引用指向的内存数据进行操作。会影响到实参。因为实参和形参引用指向的是同一块内存（存放的是对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adds</span><span class="params">(Integer i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">        val += <span class="number">3</span>;</span><br><span class="line">        i = <span class="keyword">new</span> <span class="title class_">Integer</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line">        adds(j);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出值为：&quot;</span> + j.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>答案：0<br>分析：形参 i是引用数据类型，函数中对形参i进行了变换，引用类型i发生了变化，但是该引用指向的数据没有发生变化。因此主函数中的实参j指向的内存不变，值也不变。见下图：<br><img src="https://img-blog.csdnimg.cn/direct/157b919b299643c8a6293d9160dea488.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;p&gt;学java这么久了，对java引用越来越深刻，好好梳理一下下面三个问题，带着问题进行理解。&lt;/p&gt;
&lt;h1 id=&quot;什么是引用？引用存放在jvm哪个区域？&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Java基础" scheme="https://liuhsir.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java基础" scheme="https://liuhsir.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>第五章Netty第二节协议设计：自定义编解码器</title>
    <link href="https://liuhsir.top/2022/12/24/%E7%AC%AC%E4%BA%94%E7%AB%A0Netty%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/"/>
    <id>https://liuhsir.top/2022/12/24/%E7%AC%AC%E4%BA%94%E7%AB%A0Netty%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-12-24T14:32:35.000Z</published>
    <updated>2023-12-25T06:50:15.851Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="协议设计与解析"><a href="#协议设计与解析" class="headerlink" title="协议设计与解析"></a>协议设计与解析</h1><h2 id="为什么需要协议"><a href="#为什么需要协议" class="headerlink" title="为什么需要协议"></a>为什么需要协议</h2><p>TCP&#x2F;IP消息传输是基于二进制流的方式，没有边界。<br>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则。<br>例如：在网络上传输</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下雨天留客天留我不留</span><br></pre></td></tr></table></figure><p>是中文中一句著名的无标点符号的句子，没有标点符号，有很多种拆解方式，不同拆解有不同的意思。这就是说明了标点符号的重要性，也就是消息边界的重要性。<br>网络中的协议，也就是给网络传输的信息加上「标点符号」。下面一种协议较为常用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定长字节表示内容长度 + 实际内容</span><br></pre></td></tr></table></figure><p>netty中通过LengthFieldBasedFrameDecoder来实现。</p><h2 id="redis协议举例"><a href="#redis协议举例" class="headerlink" title="redis协议举例"></a>redis协议举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">byte</span>[] LINE = &#123;<span class="number">13</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">    bootstrap.group(worker);</span><br><span class="line">    bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="comment">// 会在连接 channel 建立成功后，会触发 active 事件</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    set(ctx);</span><br><span class="line">                    get(ctx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*2&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;get&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;bbb&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>).sync();</span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    worker.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http协议举例"><a href="#http协议举例" class="headerlink" title="http协议举例"></a>http协议举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.advance.c2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.DefaultFullHttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpResponseStatus;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHttp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());<span class="comment">// Codec:coder &amp; decoder缩写，编解码器</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123;<span class="comment">// 只关注HttpRequest消息</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 获取请求</span></span><br><span class="line">                            log.debug(msg.uri());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 返回响应</span></span><br><span class="line">                            <span class="type">DefaultFullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span></span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"></span><br><span class="line">                            <span class="type">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">                            response.headers().setInt(CONTENT_LENGTH, bytes.length);<span class="comment">// 如果不设置响应头长度，浏览器会一直转圈圈</span></span><br><span class="line">                            response.content().writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 写回响应</span></span><br><span class="line">                            ctx.writeAndFlush(response);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">/*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;</span></span><br><span class="line"><span class="comment">                        @Override</span></span><br><span class="line"><span class="comment">                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">                            log.debug(&quot;&#123;&#125;&quot;, msg.getClass());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                            if (msg instanceof HttpRequest) &#123; // 请求行，请求头</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                            &#125; else if (msg instanceof HttpContent) &#123; //请求体</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                            &#125;</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;);*/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>流程总结：</p><ul><li>实例化ServerBootstrap</li><li>添加channel，添加group(处理的线程池)</li><li>添加childHandler：ChannelInitalizer</li><li>pipeline中添加LoggingHandler</li><li>pipeline中添加HttpServerCodec（http协议的编解码器）</li><li>pipeline中添加SimpleChannelInboundHandler接受http请求，响应数据</li><li>绑定端口</li><li>sync方法同步执行完</li><li>通过try catch  finally关闭boss组和worker组。</li></ul><h2 id="自定义协议要素"><a href="#自定义协议要素" class="headerlink" title="自定义协议要素"></a>自定义协议要素</h2><p>如果我们自定义一个协议需要哪些信息呢？</p><ul><li>魔数：用来在第一时间判定是否是无效数据包，比如java字节码开头是CAFEBABE</li><li>版本号:标识协议的版本号，支持协议升级</li><li>序列化算法:消息正文到底采用哪种序列化反序列化方式。例如：Json,jdk等</li><li>指令类型：跟业务相关，是登录，注册，单聊，群聊等</li><li>请求序号：为了双工通信，提供异步能力</li><li>正文长度</li><li>消息正文</li></ul><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>根据上面的要素，设计一个登录请求消息和登录响应消息。使用netty完成收发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">//@ChannelHandler.Sharable // 继承自ByteToMessageCodec（注释中说了不能共享），所谓共享就是并发下是线程安全的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);<span class="comment">//为了给下一个handler用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(</span><br><span class="line">        <span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MessageCodec</span>()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// encode</span></span><br><span class="line"><span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//        channel.writeOutbound(message);//测试编码，要写入outbound，outbound对应写出，写出的时候编码。</span></span><br><span class="line"><span class="comment">// decode</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>, message, buf);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s2</span> <span class="operator">=</span> buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">s1.retain(); <span class="comment">// 引用计数 2</span></span><br><span class="line">channel.writeInbound(s1); <span class="comment">// release 1</span></span><br><span class="line">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure><h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><p><img src="https://img-blog.csdnimg.cn/direct/6f57e9d5cee9402e8d46b06e2a0f7d44.png" alt="在这里插入图片描述"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>在解码decode的时候，避免传过来的数据是不完整的，需要在codec前面加一个LengthFieldBasedFrameDecoder验证数据的完整性（长度偏移，长度等）</li><li>在测试decode的时候，对数据进行分片了，要注意加上s1.retain(); &#x2F;&#x2F; 引用计数 2。不然会引用数变为0ByteBuf被清理掉。出现IllegalReferenceCountException错误。</li></ul><h2 id="Sharable"><a href="#Sharable" class="headerlink" title="@Sharable"></a>@Sharable</h2><ul><li>当handler不保存状态的时候，就可以安全的在多线程下共享。（加了这个表明handler是线程安全的）​</li></ul><ul><li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制，即明确了不能加@Sharable。换为继承自MessageToMessageCodeC父类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;协议设计与解析&quot;&gt;&lt;a href=&quot;#协议设计与解析&quot; class=&quot;headerlink&quot; title=&quot;协议设计与解析&quot;&gt;&lt;/a&gt;协议设计与解析&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="Netty" scheme="https://liuhsir.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://liuhsir.top/tags/Netty/"/>
    
    <category term="NIO" scheme="https://liuhsir.top/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>第五章Netty第一节 粘包和半包</title>
    <link href="https://liuhsir.top/2022/12/23/%E7%AC%AC%E4%BA%94%E7%AB%A0Netty%E7%AC%AC%E4%B8%80%E8%8A%82%E7%B2%98%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85/"/>
    <id>https://liuhsir.top/2022/12/23/%E7%AC%AC%E4%BA%94%E7%AB%A0Netty%E7%AC%AC%E4%B8%80%E8%8A%82%E7%B2%98%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85/</id>
    <published>2022-12-23T14:29:25.000Z</published>
    <updated>2023-12-24T03:46:34.118Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h1><h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><p>现象：发送abc  def,接受到abcdef</p><p>原因：</p><ul><li>应用层：接收方ByteBuf设置太大（Netty默认是1024）</li><li>传输层滑动窗口： 假设发送方256 bytes表示一个完整的报文，接收方的滑动窗口来不及处理且滑动窗口足够大，导致多个报文在一个滑动窗口中，导致粘包。（TCP协议）</li><li>Nagle算法：会造成粘包。Nagle算法是TCP协议中的一种机制，有时候发送一个字节，也需要加入TCP头和IP头，有点浪费网络。为了提高网络利用率，会将少量数据进行延迟发送，积攒起来一起发送。会造成粘包现象。</li></ul><h2 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h2><p>现象：发送abcdef,接受abc def<br>原因：</p><ul><li>应用层：接收方的ByteBuf小于实际发送的数据，导致一个数据报文被拆分了。</li><li>传输层滑动窗口：假设接收方的滑动窗口大小为128bytes，这时候发送方发了256bytes，滑动窗口接受不过来，让发送方只能先发128bytes，等待ACK后，才能发送剩余的数据。造成一个完整的报文被拆分开。（传输层TCP协议）</li><li>MSS(max segment size)限制：当发送的数据超出MSS限制后，会将数据切分后发送，会造成半包。<br>本质上是因为TCP协议是基于字节流的（首部没有长度），消息没有边界，所以会造成粘包和半包现象。UDP是面向报文的（首部有长度），所以不会有粘包和半包现象。</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="方法1-短链接"><a href="#方法1-短链接" class="headerlink" title="方法1 短链接"></a>方法1 短链接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;conneted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 短链接相当于发送一个数据就断开一次。只能解决粘包。接受的ByteBuf还是有限的，还是会有半包问题。</p></blockquote><h2 id="方法2-固定长度"><a href="#方法2-固定长度" class="headerlink" title="方法2 固定长度"></a>方法2 固定长度</h2><p>客户端和服务端商量好发送的数据包具有固定长度。如果不够长，就用占位符占位。<br>让所有的数据包长度固定（假设长度为10字节），服务端加入FixedLengthFrameDecoder进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; r.nextInt(<span class="number">8</span>); j++) &#123;</span><br><span class="line">                                    bytes[j] = (<span class="type">byte</span>) c;</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                                buffer.writeBytes(bytes);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 缺点是数据包的大小不好把握。长度只能定的太大，占位符就会多。浪费空间。因此长度最好定位最大的数据包的长度。仅仅适用于提前知道数据包的长度的情况。</p></blockquote><h2 id="方法3-固定分隔符"><a href="#方法3-固定分隔符" class="headerlink" title="方法3 固定分隔符"></a>方法3 固定分隔符</h2><p>客户端和服务端商量好发送的数据包具有特定的分隔符。服务端用LineBasedFrameDecoder处理,自动将接受到的消息用\n进行分隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure><p>客户端在每条消息之后，加入\n分隔符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果本身传输的数据中有分隔符，会解析错误</p></blockquote><h2 id="方法4-预设长度（推荐）"><a href="#方法4-预设长度（推荐）" class="headerlink" title="方法4 预设长度（推荐）"></a>方法4 预设长度（推荐）</h2><p>在发送消息前，先约定用定长字节表示接下来数据的长度。服务端用LengthFieldBasedFrameDecoder来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整(长度占用字节后偏移多少个才是真正的数据)，剥离字节数（用于接受的数据去除长度占用的字节信息）</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.advance.c1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBufAllocator;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.embedded.EmbeddedChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLengthFieldDecoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(</span><br><span class="line">                        <span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>,<span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  4 个字节的内容长度， 实际内容</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        send(buffer, <span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">        send(buffer, <span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">        channel.writeInbound(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(ByteBuf buffer, String content)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = content.getBytes(); <span class="comment">// 实际内容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> bytes.length; <span class="comment">// 实际内容长度</span></span><br><span class="line">        buffer.writeInt(length);</span><br><span class="line">        buffer.writeByte(<span class="number">1</span>);</span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;粘包与半包&quot;&gt;&lt;a href=&quot;#粘包与半包&quot; class=&quot;headerlink&quot; title=&quot;粘包与半包&quot;&gt;&lt;/a&gt;粘包与半包&lt;/h1&gt;&lt;h2 id=&quot;粘包&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Netty" scheme="https://liuhsir.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://liuhsir.top/tags/Netty/"/>
    
    <category term="NIO" scheme="https://liuhsir.top/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>第四章Netty第四节案例实现echo server</title>
    <link href="https://liuhsir.top/2022/12/23/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E5%9B%9B%E8%8A%82%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0echoserver/"/>
    <id>https://liuhsir.top/2022/12/23/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E5%9B%9B%E8%8A%82%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0echoserver/</id>
    <published>2022-12-23T09:29:25.000Z</published>
    <updated>2023-12-23T09:24:04.103Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>实现一个echo server。通俗的说就是客户端发送什么就会接受到什么。echo的意思“回声”。</p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">               .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">               .channel(NioServerSocketChannel.class)</span><br><span class="line">               .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                       ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                               <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                               System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                               <span class="comment">// 建议使用 ctx.alloc() 创建 ByteBuf</span></span><br><span class="line">                               <span class="type">ByteBuf</span> <span class="variable">response</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                               response.writeBytes(buffer);</span><br><span class="line">                               ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">                               <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                               buffer.release();<span class="comment">// 没有向后传递了，所以应该释放？</span></span><br><span class="line">                               <span class="comment">// 思考：需要释放 response 吗</span></span><br><span class="line">                               response.release();<span class="comment">// 没有向后传递了，所以应该释放？</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).bind(<span class="number">8090</span>);</span><br></pre></td></tr></table></figure><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">       <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">               .group(group)</span><br><span class="line">               .channel(NioSocketChannel.class)</span><br><span class="line">               .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                       ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                       ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                               <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                               System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                               <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                               buffer.release();<span class="comment">//可以释放。不释放，tail会释放。能自己释放还是自己释放。</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8090</span>).sync().channel();</span><br><span class="line">       channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">           group.shutdownGracefully();</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">               <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">                   channel.close();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               channel.writeAndFlush(line);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>客户端打印输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hey</span><br><span class="line">hey</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;实现一个echo server。通俗的说就是</summary>
      
    
    
    
    <category term="Netty" scheme="https://liuhsir.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://liuhsir.top/tags/Netty/"/>
    
    <category term="NIO" scheme="https://liuhsir.top/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>初学Netty SeverBootstrap和Bootstrap踩坑</title>
    <link href="https://liuhsir.top/2022/12/23/NettySeverBootstrap%E5%92%8CBootstrap%E8%B8%A9%E5%9D%91/"/>
    <id>https://liuhsir.top/2022/12/23/NettySeverBootstrap%E5%92%8CBootstrap%E8%B8%A9%E5%9D%91/</id>
    <published>2022-12-23T08:37:25.000Z</published>
    <updated>2023-12-23T08:37:56.933Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="错误描述no-further-information-127-0-0-1-8090"><a href="#错误描述no-further-information-127-0-0-1-8090" class="headerlink" title="错误描述no further information: &#x2F;127.0.0.1:8090"></a>错误描述no further information: &#x2F;127.0.0.1:8090</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: no further information: /127.0.0.1:8090</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>看到问题很明显，连接失败？刚开始以为是ip+端口号写错了，检查发现没有错误。<br>后来才发现server端ServerBootstrap写错成了客户端的BootStrap<br>将</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br></pre></td></tr></table></figure><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>SeverBootstrap和Bootstrap都是Netty的启动类，他们的主要作用就是配置相关参数（IP,端口等）并启动整个Netty服务。<br>ServerBootstrap:<strong>用于服务端的启动</strong><br>Boostrap：<strong>用于客户端的启动</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;错误描述no-further-information-127-0-0-1-8090&quot;&gt;&lt;a href=&quot;#错误描述no-further-information-127-</summary>
      
    
    
    
    <category term="Netty" scheme="https://liuhsir.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://liuhsir.top/tags/Netty/"/>
    
    <category term="NIO" scheme="https://liuhsir.top/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>第四章Netty第三节handler&amp;pipeline&amp;ByteBuf</title>
    <link href="https://liuhsir.top/2022/12/22/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E4%B8%89%E8%8A%82handler&amp;pipeline&amp;ByteBuf/"/>
    <id>https://liuhsir.top/2022/12/22/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E4%B8%89%E8%8A%82handler&amp;pipeline&amp;ByteBuf/</id>
    <published>2022-12-22T15:29:25.000Z</published>
    <updated>2023-12-22T15:29:52.973Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="Handler-Pipeline"><a href="#Handler-Pipeline" class="headerlink" title="Handler &amp; Pipeline"></a>Handler &amp; Pipeline</h1><h2 id="Pipeline中执行顺序"><a href="#Pipeline中执行顺序" class="headerlink" title="Pipeline中执行顺序"></a>Pipeline中执行顺序</h2><p>ChannelHandler用来处理Channel上的各种事件，分为入站和出站。ChannelHandler被连成一串就是pipeline.</p><ul><li>入站处理器通常是ChannelInBoundHanderAdapter的子类，主要用来读取客户端的数据，写回结果</li><li>出站处理器通常是ChannelOutboundHandlerAdapter的子类，主要对写回结果进行加工。<br>打个比喻，channel是产品的加工车间。pipeline是车间中的流水线，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品。<br>服务端：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">3</span>);</span><br><span class="line">                    ctx.channel().write(msg); <span class="comment">// 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">4</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">5</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">6</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 6</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>客户单：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">        future.channel().writeAndFlush(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>结果打印：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表<br><img src="https://img-blog.csdnimg.cn/direct/5fb50836ab9446faa304ccb9e67b6889.png" alt="在这里插入图片描述"></li></ul><ol><li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong></li></ol><ul><li>如果注释掉 1 处代码，则仅会打印 1</li><li>如果注释掉 2 处代码，则仅会打印 1 2</li></ul><ol start="2"><li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行</li></ol><ul><li>如果注释掉 3 处代码，则仅会打印 1 2 3</li></ul><ol start="3"><li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong></li></ol><ul><li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li></ul><ol start="4"><li>ctx.channel().write(msg) vs ctx.write(msg)</li></ol><ul><li>都是触发出站处理器的执行</li><li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li><li>ctx.write(msg) 是从当前节点找上一个出站处理器</li><li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器</li><li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己<br>下图为服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序<br><img src="https://img-blog.csdnimg.cn/direct/763d46a86fd342939f8aff11bde47d84.png" alt="在这里插入图片描述"></li></ul><h2 id="EmbededChannel调试"><a href="#EmbededChannel调试" class="headerlink" title="EmbededChannel调试"></a>EmbededChannel调试</h2><p>主要方法：</p><ul><li>channel.writeInbound</li><li>channel.writeOutbound<br>通过new EmbededChannel，调用上面方法，能够触发pipeline中的channel事件，handler执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">ChannelInboundHandlerAdapter</span> <span class="variable">ch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelInboundHandlerAdapter</span> <span class="variable">ch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelOutboundHandlerAdapter</span> <span class="variable">ch3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelOutboundHandlerAdapter</span> <span class="variable">ch4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(ch1, ch2, ch3, ch4);</span><br><span class="line"><span class="comment">//        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes()));// 让inbound事件触发</span></span><br><span class="line">        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;hello&quot;</span>.getBytes()));<span class="comment">// 让outbound事件触发</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:0 capacity:10</span><br></pre></td></tr></table></figure><p>创建默认的ByteBuf(池化基于直接内存)，初始容量为10（可扩充，对应一个最大容量）</p><h3 id="直接内存-vs-堆内存"><a href="#直接内存-vs-堆内存" class="headerlink" title="直接内存 vs 堆内存"></a>直接内存 vs 堆内存</h3><p>直接内存（默认）：将数据存放在操作系统的堆外内存中。直接内存的分配和释放不受JVM的垃圾回收控制，减少了GC开销。直接内存创建和销毁的代价高，但是读写性能好（零拷贝技术减少了内核态和用户态数据的复制），配合池化功能一起用。<br>堆内存：堆内存由JVM自动管理和回收。某些情况下可能导致GC的开销和延迟。<br>创建池化基于堆的buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>创建池化基于直接内存的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="池化-vs-非池化"><a href="#池化-vs-非池化" class="headerlink" title="池化 vs 非池化"></a>池化 vs 非池化</h3><p>池化的最大意义在于减少创建buffer的时间和重用byteBuf。具体如下：</p><ul><li>没有池化，每次都得创建新的byteBuf实例，速度慢</li><li>有了池化，池中提前创建好byteBuf，用完了放回池子，可以重用。</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能。</li></ul><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>ByteBuf由四部分组成<br> <img src="https://img-blog.csdnimg.cn/direct/26846cbdac5b466493c9a9e35e296af9.png" alt="在这里插入图片描述"><br> 两个指针，分别时读指针和写指针（注意：NIO中的bytebuffer读写指针共用的）</p><h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><p> 方法列表，省略一些不重要的方法</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td>用一字节 01|00 代表 true|false</td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian，即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian，即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 ByteBuffer</td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td></td></tr><tr><td>大端方式写入（网络传输中习惯大端）：将第一个字节（从左到右）写入高位（大端）：符合人的正常思维，即 0x00 00 02 50，写入后 00 00 02 50</td><td></td><td></td></tr><tr><td>小端方式写入：将第一个字节（从左到右）写入低位（小端）：即 0x00 00 02 50，写入后 50 02 00 00</td><td></td><td></td></tr></tbody></table><p>先写入 4 个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:4 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>再写入一个 int 整数，也是 4 个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">5</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:8 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">6</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>扩容规则是</p><ul><li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li><li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10&#x3D;1024（2^9&#x3D;512 已经不够了）</li><li>扩容不能超过 max capacity 会报错</li></ul><p>结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>例如读了 4 次，每次一个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>如果需要重复读取 int 整数 5，怎么办？</p><p>可以在 read 前先做个标记 mark</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.markReaderIndex();</span><br><span class="line">System.out.println(buffer.readInt());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">read index:8 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 06                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时要重复读取的话，重置到标记位置 reset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.resetReaderIndex();</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>这时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p><h2 id="retain-release"><a href="#retain-release" class="headerlink" title="retain &amp; release"></a>retain &amp; release</h2><p>由于Nettty由堆外内存的byteBuf实现，堆外内存最好是手动来释放，而不是GC垃圾回收。</p><ul><li>UnpooledHeapByteBuf使用的是JVM内存，只需要等GC回收即可</li><li>UnpooledDirectByteBuf使用的是操作系统的堆外内存，需要特殊的方法来回收内存</li><li>PooledByteBuf和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty这里使用了<strong>引用计数法</strong>来控制回收内存，每个ByteBuf都实现了ReferenceCounted接口</p><ul><li>每个ByteBuf对象的初始计数为1</li><li>调用release方法计数减1，如果计数为0， ByteBuf内存被回收。</li><li>调用retain方法计数加1，表示调用者没用完之前，其他handler即使调用了release也不会造成回收。</li><li>当计数为0时，底层内存会被回收。这时即使ByteBuf对象还在，当各个方法均无法正常使用。</li></ul><p>谁来负责release呢？<br>基本规则是，<strong>谁是最后使用者，谁负责release</strong></p><ol><li>入站ByteBuf处理原则</li></ol><ul><li>对原始ByteBuf不做处理，调用ctx.fireChannelRead(msg)向后传递，无需release</li><li>将原始ByteBuf转换为其他类型的Java对象，这时ByteBuf没用了，必须release</li><li>如果不调用ctx.fireChannelRead（msg）向后传递，那么也必须release</li><li>注意各种异常，如果ByteBuf没有成功传递到后一个ChannelHandler，必须release</li><li>假设消息一直往后传，那么TailContext会负责释放未处理消息（原始的ByteBuf）</li></ul><ol start="2"><li>出站ByteBuf处理原则</li></ol><ul><li>出站消息最终会转为ByteBuf输出， 一直向前传，由headContext flush后release</li></ul><ol start="3"><li>异常处理原则</li></ol><ul><li>有时候不清楚ByteBuf被引用了多少次，但又必须释放，可以循环调用release直接返回true</li></ul><p>TailContext 释放未处理消息逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ReferenceCounted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ReferenceCounted) msg).release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>「零拷贝」的体现之一。对原始的ByteBuf进行切片成多个ByteBuf,切片后的ByteBuf并没有发生内存复制，还是使用原来的内存，只是切片后的ByteBuf维护独立的read,write指针。<br>在这里插入图片描述<br><img src="https://img-blog.csdnimg.cn/direct/670831f56d434965bcce46f1ac75e8e6.png" alt="在这里插入图片描述"><br>例，原始 ByteBuf 进行一些初始操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">origin</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">origin.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">slice</span> <span class="operator">=</span> origin.slice();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class="line"><span class="comment">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 04                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时的 slice 不受影响，因为它有独立的读写指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>如果 slice 的内容发生了更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice.setByte(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 05                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 05                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h2 id="duplicate"><a href="#duplicate" class="headerlink" title="duplicate"></a>duplicate</h2><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的<br><img src="https://img-blog.csdnimg.cn/direct/bf397080795948269cfe5313c7a5d837.png" alt="在这里插入图片描述"></p><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始ByteBuf无关。</p><h2 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h2><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝<br>有两个 ByteBuf 如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT</span><br><span class="line">    .buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class="line">buf3.writeBytes(buf1);</span><br><span class="line">buf3.writeBytes(buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这种方法好不好？回答是不太好，因为进行了数据的内存复制操作</p><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line"><span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">buf3.addComponents(<span class="literal">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure><p>结果是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p><ul><li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li><li>缺点，复杂了很多，多次操作会带来性能的损耗</li></ul><h2 id="ByteBuf优势"><a href="#ByteBuf优势" class="headerlink" title="ByteBuf优势"></a>ByteBuf优势</h2><ul><li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li><li>可以自动扩容</li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;Handler-Pipeline&quot;&gt;&lt;a href=&quot;#Handler-Pipeline&quot; class=&quot;headerlink&quot; title=&quot;Handler &amp;amp</summary>
      
    
    
    
    <category term="Netty" scheme="https://liuhsir.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://liuhsir.top/tags/Netty/"/>
    
    <category term="NIO" scheme="https://liuhsir.top/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>第四章Netty第二节入门案例+channel,future,promise介绍</title>
    <link href="https://liuhsir.top/2022/12/21/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B+%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>https://liuhsir.top/2022/12/21/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B+%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-12-21T14:40:25.000Z</published>
    <updated>2023-12-23T02:49:58.469Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>开发一个简单的服务器端和客户端</p><ul><li>客户端向服务器端发送 hello, world</li><li>服务器仅接收，不返回<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.1</span><span class="number">.39</span>.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()); <span class="comment">// 5</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; <span class="comment">// 6</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>代码解读：</p><ol><li>1处创建NIOEventLoopGroup,可以简单理解为线程池+selector</li><li>2处选择服务socket实现类，其中NIOServerSocketChannel表示基于NIO的服务端实现。其他还有<br> <img src="https://img-blog.csdnimg.cn/direct/6ff3e7c3f5a345daa65b5247055416dd.png" alt="在这里插入图片描述"></li><li>3处，为啥方法骄傲childHandler，是接下来处理器都是给socketChannel用的，而不是给ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端socketChannel建立连接后，执行initChannel以便添加更多的处理器。</li><li>4 处，ServerSocketChannel 绑定的监听端口</li><li>5处，socketChannel的处理器，解码ByteBuf&#x3D;&gt;String</li><li>6处，socketChannel的业务处理器，使用上一个处理器的处理结果</li></ol><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">// 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>) <span class="comment">// 4</span></span><br><span class="line">    .sync() <span class="comment">// 5</span></span><br><span class="line">    .channel() <span class="comment">// 6</span></span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>); <span class="comment">// 7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码解读：<br>1.1处，创建NIOEventLoopGroup,同server<br>2. 2处， 选择客户的socket实现类，NIOSocketChannel表示基于NIO的客户端实现类。其他实现还有<br>    <img src="https://img-blog.csdnimg.cn/direct/0b6c72fccf8f450183a66563d5c1a12b.png" alt="在这里插入图片描述"></p><ol start="3"><li>3处，添加socketChannel的处理器，ChannelInitializer处理器（仅执行一次），它的作用是待客户端socketChannel建立连接后，执行initChannel以便添加跟多的处理器。</li><li>4 处，指定要连接的服务器和端口</li><li>5处，Netty中很多方法都是异步的，如connect，这时需要使用sync方法等待connect建立连接完毕。</li><li>6处，获取channel对象，它即为通道抽象，可以进行数据读写。</li><li>7处，写入消息并清空缓冲区</li><li>8处，建立连接后，消息会经过通道handler处理，这里是将string&#x3D;&gt;ByteBuf发出。</li><li>数据经过网络传输，到达服务端，服务端5和6处的handlerx先后被触发走完一个流程。</li></ol><h1 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h1><p><img src="https://img-blog.csdnimg.cn/direct/6d5c3a5fef8648b49375212543b7f063.png" alt="在这里插入图片描述"><br>注意：</p><ul><li>把channel理解为数据的通道</li><li>把msg理解为流动的数据，最开始输入的是ByteBuf,但经过pipeLine的加工，会变成其他类型的对象，最后输出又变成ByteBuf</li><li>把handler理解为数据的处理工序<ul><li>工序有多道，合在一起就是pipeline.pipeline负责发布事件（读，读取完成。。。）传播给每个handler,handler对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li><li>handler分Inbound和outbound两类</li></ul></li><li>把eventloop理解为处理数据的工人<ul><li>工人可以管理多个channel的io操作。并且一旦工人负责了某个channel就要负责到底（绑定）</li><li>工人既可以执行io操作，也可以进行任务处理。每位工人有任务队列，队列里可以堆放多个channel待处理的任务，把任务分为普通任务和定时任务。</li><li>工人按照pipeline顺序，依次按照handler的规划（代码）处理数据，可以为每一道工序执行不同的工人。</li></ul></li></ul><h1 id="组件-EventLoop"><a href="#组件-EventLoop" class="headerlink" title="组件-EventLoop"></a>组件-EventLoop</h1><h2 id="事件循环对象-EventLoop"><a href="#事件循环对象-EventLoop" class="headerlink" title="事件循环对象 EventLoop"></a>事件循环对象 EventLoop</h2><p>本质上是一个单线程执行器同时维护了一个selector，里面有run方法处理channel上源源不断的io事件。<br>继承关系：</p><ul><li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li><li>另一条线是继承自 netty 自己的 OrderedEventExecutor<ul><li>提供了boolean inEventLoop（Thread thread）方法判断一个线程是否属于此EventLoop</li><li>提供了parent方法来看看自己属于哪个EventLoopGroup</li></ul></li></ul><h2 id="事件循环组-EventLoopGroup"><a href="#事件循环组-EventLoopGroup" class="headerlink" title="事件循环组 EventLoopGroup"></a>事件循环组 EventLoopGroup</h2><p>是一组EventLoop,channel一般会调用EventLoopGroup的register方法来绑定一个EventLoop，后续这个channel上的io事件都由此EventLoop来处理（保证了io事件处理时的线程安全）<br>继承自 netty 自己的 EventExecutorGroup</p><ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop<br>以一个简单的实现为例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span></span><br><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br></pre></td></tr></table></figure>输出<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br></pre></td></tr></table></figure>也可以使用 for 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (EventExecutor eventLoop : group) &#123;</span><br><span class="line">    System.out.println(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br></pre></td></tr></table></figure><h2 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h2><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h2 id="演示NioEventLoop处理io事件"><a href="#演示NioEventLoop处理io事件" class="headerlink" title="演示NioEventLoop处理io事件"></a>演示NioEventLoop处理io事件</h2><p>服务端两个Nio worker工人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></table></figure><p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">            .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>))</span><br><span class="line">            .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .channel(NioSocketChannel.class).connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">            .sync()</span><br><span class="line">            .channel();</span><br><span class="line"></span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;wangwu&quot;</span>.getBytes()));</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;wangwu&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure><p>最后输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        </span><br><span class="line">22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         </span><br></pre></td></tr></table></figure><p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定<br><img src="https://img-blog.csdnimg.cn/direct/b3f1397a312d4b67832c876e92fc29b8.png" alt="在这里插入图片描述"><br>再增加两个非 nio 工人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">normalWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span>  &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">            ch.pipeline().addLast(normalWorkers,<span class="string">&quot;myhandler&quot;</span>,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></table></figure><p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED</span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br></pre></td></tr></table></figure><p>可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</p><p><img src="https://img-blog.csdnimg.cn/direct/e042e537e8964fd98f021ab003cebbf9.png" alt="在这里插入图片描述"></p><h2 id="handler-执行中如何换人？"><a href="#handler-执行中如何换人？" class="headerlink" title="handler 执行中如何换人？"></a>handler 执行中如何换人？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是，直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRead(m);<span class="comment">// 用新的线程去执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/direct/20bcc43f138e4fe898ad8f49be748977.png" alt="在这里插入图片描述"></p><ul><li>如果两个handler绑定的是同一个线程，那么在当前线程中直接调用</li><li>否则，提交给一个新的线程调用。</li></ul><h2 id="演示-NioEventLoop-处理普通任务"><a href="#演示-NioEventLoop-处理普通任务" class="headerlink" title="演示 NioEventLoop 处理普通任务"></a>演示 NioEventLoop 处理普通任务</h2><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1. 创建事件循环组</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>); <span class="comment">// io 事件，普通任务，定时任务</span></span><br><span class="line">         <span class="comment">// 3. 执行普通任务。submit和execute都可以。将这个任务加到事件循环组中的一个线程去执行不会造成阻塞。实现了异步</span></span><br><span class="line">group.next().submit(() -&gt; &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">log.debug(<span class="string">&quot;main&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">19:52:29 [DEBUG] [main] c.i.n.c.TestEventLoop - main</span><br><span class="line">19:52:30 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestEventLoop - ok</span><br></pre></td></tr></table></figure><p>可以用来执行耗时较长的任务，不会被阻塞。</p><h2 id="演示-NioEventLoop-处理定时任务"><a href="#演示-NioEventLoop-处理定时任务" class="headerlink" title="演示 NioEventLoop 处理定时任务"></a>演示 NioEventLoop 处理定时任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建事件循环组</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>); <span class="comment">// io 事件，普通任务，定时任务</span></span><br><span class="line"><span class="comment">// 4. 执行定时任务</span></span><br><span class="line">group.next().scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;main&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">19:53:32 [DEBUG] [main] c.i.n.c.TestEventLoop - main</span><br><span class="line">19:53:32 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestEventLoop - ok</span><br><span class="line">19:53:33 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestEventLoop - ok</span><br><span class="line">19:53:34 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestEventLoop - ok</span><br></pre></td></tr></table></figure><p>可以用来执行定时任务。</p><h1 id="组件-Channel"><a href="#组件-Channel" class="headerlink" title="组件-Channel"></a>组件-Channel</h1><h2 id="channel的主要方法"><a href="#channel的主要方法" class="headerlink" title="channel的主要方法"></a>channel的主要方法</h2><ul><li>close() 可以用来关闭 channel</li><li>closeFuture() 用来处理 channel 的关闭<ul><li>sync 方法作用是同步等待 channel 关闭</li><li>而 addListener 方法是异步等待 channel 关闭</li></ul></li><li>pipeline() 方法添加处理器</li><li>write() 方法将数据写入到缓冲区中，但没有将数据发出。</li><li>writeAndFlush() 方法将数据写入缓存去，并立刻将缓冲区数据刷出。会立即将数据发出。</li></ul><h2 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 异步非阻塞的。异步：main线程发起调用，真正执行连接是另一个线程-Nio线程。如果没有sync，是无阻塞的，会直接向下执行。连接都还没建立好，信息不知道发送到哪里去。</span></span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">channelFuture.sync().channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>说明：<br>1处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象<br>注意：connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象。加了sync才能变成同步，一直阻塞直到建立连接。然后执行后面的才能正确发送数据。<br>实验如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.sync(); <span class="comment">// 2 会阻塞直到返回结果</span></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li><li>执行到 2 时，sync 方法是同步等待连接建立完成</li><li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code><br>除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    System.out.println(future.channel()); <span class="comment">// 2 连接建立好了会调用该方法</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 或者用下面的方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 使用 addListener(回调对象) 方法异步处理结果</span></span><br><span class="line"><span class="comment">channelFuture.addListener(new ChannelFutureListener() &#123;</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    // 在 nio 线程连接建立好之后，会调用 operationComplete</span></span><br><span class="line"><span class="comment">    public void operationComplete(ChannelFuture future) throws Exception &#123;</span></span><br><span class="line"><span class="comment">        Channel channel = future.channel();</span></span><br><span class="line"><span class="comment">        log.debug(&quot;&#123;&#125;&quot;, channel);</span></span><br><span class="line"><span class="comment">        channel.writeAndFlush(&quot;hello, world&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>核心：channelFuture.addListener（）。注意带有future,promise的类型都可以和addListener方法配套使用的。<br>说明：这种方法不同于上面的同步的方法，同步的方法是有main线程完成打印的操作。而这里main线程直接将任务交给其他线程以异步的方式执行，当连接建立完成后自动完成打印操作。</li></ul><h2 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h2><p>用法基本同上面的channelFuture。closeFuture是用来处理关闭之后的操作的，一般用来关闭EventLoopGroup。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        NioEventLoopGroup group <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">                    channel.close(); <span class="comment">// close 异步操作 1s 之后</span></span><br><span class="line"><span class="comment">//                    log.debug(&quot;处理关闭之后的操作&quot;); // 不能在这里善后</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;input&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        <span class="comment">// 1.同步关闭的方法</span></span><br><span class="line">        <span class="comment">/*log.debug(&quot;waiting close...&quot;);</span></span><br><span class="line"><span class="comment">        closeFuture.sync();</span></span><br><span class="line"><span class="comment">        log.debug(&quot;处理关闭之后的操作&quot;);*/</span></span><br><span class="line">        <span class="comment">// 2.异步处理的方法</span></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组件-Future-Promise"><a href="#组件-Future-Promise" class="headerlink" title="组件-Future&amp;Promise"></a>组件-Future&amp;Promise</h1><p>在异步处理的时候，经常用到这两个接口。</p><p>netty中的Future和JDK中的Future同名。Netty的Future是继承自JDK的Future。Promise是对Netty中的Future进行拓展（Extend）。</p><ul><li>JDK中的Future只能同步等待任务结束（或成功或失败）才能得到结果。</li><li>netty Future可以同步等待任务结束得到结果，也可以异步（addListener）得到结果。但都要等任务结束</li><li>netty Promise不仅有netty Future的功能，而且可以「主动创建」一个Promise,作为两个线程间传递结果的容器。</li></ul><table><thead><tr><th>功能&#x2F;名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h2 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h2><p>只能通过同步等待任务结束，future.get()会阻塞，直到拿到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 线程池</span></span><br><span class="line">      <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">      <span class="comment">// 2. 提交任务</span></span><br><span class="line">      Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">              log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">              Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 3. 主线程通过 future 来获取结果</span></span><br><span class="line">      log.debug(<span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">      log.debug(<span class="string">&quot;结果是 &#123;&#125;&quot;</span>, future.get());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">22:29:50 [DEBUG] [pool-1-thread-1] c.i.n.c.TestJdkFuture - 执行计算</span><br><span class="line">22:29:50 [DEBUG] [main] c.i.n.c.TestJdkFuture - 等待结果</span><br><span class="line">22:29:51 [DEBUG] [main] c.i.n.c.TestJdkFuture - 结果是 50</span><br></pre></td></tr></table></figure><h2 id="netty-Future"><a href="#netty-Future" class="headerlink" title="netty Future"></a>netty Future</h2><p>可以通过同步(get方法会阻塞)也可以通过异步（addListener不会阻塞，交给另外的线程处理）获得结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> group.next();</span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        log.debug(&quot;等待结果&quot;);</span></span><br><span class="line"><span class="comment">//        log.debug(&quot;结果是 &#123;&#125;&quot;, future.get()); // 1. 同步的方式</span></span><br><span class="line">        <span class="comment">//2. 异步的方式</span></span><br><span class="line">        future.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Integer&gt;&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;接收结果:&#123;&#125;&quot;</span>, future.getNow());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>上面异步的方式输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22:34:24 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestNettyFuture - 执行计算</span><br><span class="line">22:34:25 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.c.TestNettyFuture - 接收结果:70</span><br></pre></td></tr></table></figure><h2 id="netty-Promise-常用的"><a href="#netty-Promise-常用的" class="headerlink" title="netty Promise(常用的)"></a>netty Promise(常用的)</h2><p>Promise 继承自（extend）netty的Future。不仅有Future的功能，而且能主动创建，作为线程 间存放数据的容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 准备 EventLoop 对象</span></span><br><span class="line">       <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>().next();</span><br><span class="line">       <span class="comment">// 2. 可以主动创建 promise, 结果容器</span></span><br><span class="line">       DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="comment">// 3. 任意一个线程执行计算，计算完毕后向 promise 填充结果</span></span><br><span class="line">           log.debug(<span class="string">&quot;开始计算...&quot;</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               promise.setSuccess(<span class="number">80</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               promise.setFailure(e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;).start();</span><br><span class="line">       <span class="comment">// 4. 接收结果的线程</span></span><br><span class="line">       log.debug(<span class="string">&quot;等待结果...&quot;</span>);</span><br><span class="line">       log.debug(<span class="string">&quot;结果是: &#123;&#125;&quot;</span>, promise.get());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">22:37:03 [DEBUG] [main] c.i.n.c.TestNettyPromise - 等待结果...</span><br><span class="line">22:37:03 [DEBUG] [Thread-0] c.i.n.c.TestNettyPromise - 开始计算...</span><br><span class="line">22:37:04 [DEBUG] [main] c.i.n.c.TestNettyPromise - 结果是: 80</span><br></pre></td></tr></table></figure><p>后续netty一般都用Promise</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;开发一个简单的服务器端和客户端&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    <category term="Netty" scheme="https://liuhsir.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://liuhsir.top/tags/Netty/"/>
    
    <category term="NIO" scheme="https://liuhsir.top/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>炼丹小技巧1：通过TensorBoard查看loss走向判断模型是否收敛</title>
    <link href="https://liuhsir.top/2022/12/21/%E7%82%BC%E4%B8%B9%E5%B0%8F%E6%8A%80%E5%B7%A71%EF%BC%9A%E9%80%9A%E8%BF%87TensorBoard%E6%9F%A5%E7%9C%8Bloss%E8%B5%B0%E5%90%91%E5%88%A4%E6%96%AD%E6%A8%A1%E5%9E%8B%E6%98%AF%E5%90%A6%E6%94%B6%E6%95%9B/"/>
    <id>https://liuhsir.top/2022/12/21/%E7%82%BC%E4%B8%B9%E5%B0%8F%E6%8A%80%E5%B7%A71%EF%BC%9A%E9%80%9A%E8%BF%87TensorBoard%E6%9F%A5%E7%9C%8Bloss%E8%B5%B0%E5%90%91%E5%88%A4%E6%96%AD%E6%A8%A1%E5%9E%8B%E6%98%AF%E5%90%A6%E6%94%B6%E6%95%9B/</id>
    <published>2022-12-21T14:29:25.000Z</published>
    <updated>2023-12-28T09:38:02.043Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h1><p>我们在训练模型的时候，不知道自己的超参数epochs设置的是够正确,能否训练出一个足够好的模型？<br>通过参看loss的走向，如果loss稳定在较低值附近，就可以判断该模型已经收敛。<br>可以通过plt.show自己绘制loss的走向图，当然也可以通过TensorBoard绘制loss的走向图，更加高大上。<br>TensorBoard绘图简单原理如下：1.将要绘制的数据保存为一个文件 2.用tensorboard命令读取文件并绘制图形</p><h1 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h1><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorboard</span><br></pre></td></tr></table></figure><p>训练模型代码中保存loss值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)  <span class="comment"># 写入文件存放的位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=2*x&quot;</span>, <span class="number">2</span> * i, i)  <span class="comment">#  &quot;y=2*x&quot;为图片描述，2 * i 为纵坐标， i为step（横坐标）</span></span><br><span class="line">writer.close()  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动TensorBoard</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=logs</span><br></pre></td></tr></table></figure><p>–logdir ：读取文件所在的文件夹</p><h1 id="3-举例"><a href="#3-举例" class="headerlink" title="3.举例"></a>3.举例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">x_data = torch.Tensor([[<span class="number">1.0</span>], [<span class="number">2.0</span>], [<span class="number">3.0</span>]])</span><br><span class="line">y_data = torch.Tensor([[<span class="number">2.0</span>], [<span class="number">4.0</span>], [<span class="number">6.0</span>]])</span><br><span class="line"><span class="comment"># 终端中输入 tensorboard --logdir=./logs 启动tensorboard读取logs下文件，进行绘制</span></span><br><span class="line"><span class="comment"># epochs = 100  # 设置为100时模型还没有收敛</span></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearModel</span>(torch.nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LinearModel, self).__init__()</span><br><span class="line">        self.linear = torch.nn.Linear(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y_pred = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = LinearModel()</span><br><span class="line">loss = torch.nn.MSELoss(reduction=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">opmizier = torch.optim.SGD(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    y_pred = model(x_data)</span><br><span class="line">    l = loss(y_pred, y_data)</span><br><span class="line">    <span class="built_in">print</span>(l.item())</span><br><span class="line">    writer.add_scalar(<span class="string">&#x27;loss&#x27;</span>, l.item(), epoch)  <span class="comment"># 使用tensorboard</span></span><br><span class="line">    l.backward()</span><br><span class="line">    opmizier.step()</span><br><span class="line">    opmizier.zero_grad()</span><br><span class="line"></span><br><span class="line">writer.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w:&quot;</span>, model.linear.weight.item())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b:&quot;</span>, model.linear.bias.item())</span><br><span class="line"></span><br><span class="line">x_test = torch.tensor([<span class="number">4.0</span>])</span><br><span class="line">y_test = model(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_pred:&quot;</span>, y_test.item())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-1-epochs设置过小"><a href="#3-1-epochs设置过小" class="headerlink" title="3.1 epochs设置过小"></a>3.1 epochs设置过小</h2><p><img src="https://img-blog.csdnimg.cn/7cf0f419ed954c19b02b8f7607368fe1.png" alt="模型未收敛"></p><h2 id="3-2-epochs设置合理"><a href="#3-2-epochs设置合理" class="headerlink" title="3.2 epochs设置合理"></a>3.2 epochs设置合理</h2><p><img src="https://img-blog.csdnimg.cn/81f81430dd3149b3933edc1e3ed2597b.png" alt="模型收敛"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;1-目的&quot;&gt;&lt;a href=&quot;#1-目的&quot; class=&quot;headerlink&quot; title=&quot;1.目的&quot;&gt;&lt;/a&gt;1.目的&lt;/h1&gt;&lt;p&gt;我们在训练模型的时候，不知道</summary>
      
    
    
    
    <category term="机器学习" scheme="https://liuhsir.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="ML" scheme="https://liuhsir.top/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>java{{}}匿名内部类初始化</title>
    <link href="https://liuhsir.top/2022/12/20/java%7B%7B%7D%7D%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://liuhsir.top/2022/12/20/java%7B%7B%7D%7D%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-12-20T14:18:25.000Z</published>
    <updated>2023-12-28T09:40:21.586Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在刷题的时候看到有人写代码用了<code>&#123;&#123;&#125;&#125;</code>写法，以前没有见过，特此记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><code>&#123;&#123;&#125;&#125;</code>这种方法是对一个集合进行初始化操作，避免了对集合初始化进行一条一条的add。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()&#123;</span><br><span class="line">&#123;</span><br><span class="line">add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="comment">// 和下面功能实现一样</span></span><br><span class="line"><span class="comment">//        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span></span><br><span class="line"><span class="comment">//        list.add(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">//        list.add(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//        list.add(&quot;c&quot;);</span></span><br></pre></td></tr></table></figure><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>第一个括号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个继承于ArrayList的类，它没有名字</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()&#123;</span><br><span class="line">  <span class="comment">//在这里对这个类进行具体定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的括号表示对一个类进行具体的定义。</p><p>第二个括号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;()&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//这里是实例初始化块，可以直接调用父类的非私有方法或访问非私有成员</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 这里的括号表示实例初始化块（Instance Initialiazer Block）,也被称为非静态初始化块。</p><p>类比于静态初始块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//静态初始块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://">https://www.cnblogs.com/dengyungao/p/7524981.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在刷题的时候看到有人写代码用了&lt;code&gt;&amp;</summary>
      
    
    
    
    <category term="Java基础" scheme="https://liuhsir.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java语法" scheme="https://liuhsir.top/tags/Java%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第四章Netty第一节概述</title>
    <link href="https://liuhsir.top/2022/12/19/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E4%B8%80%E8%8A%82%E6%A6%82%E8%BF%B0/"/>
    <id>https://liuhsir.top/2022/12/19/%E7%AC%AC%E5%9B%9B%E7%AB%A0Netty%E7%AC%AC%E4%B8%80%E8%8A%82%E6%A6%82%E8%BF%B0/</id>
    <published>2022-12-19T14:22:25.000Z</published>
    <updated>2023-12-23T09:28:04.069Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="1-原生NIO存在的问题"><a href="#1-原生NIO存在的问题" class="headerlink" title="1. 原生NIO存在的问题"></a>1. 原生NIO存在的问题</h1><ol><li>NIO的类库和API繁杂，使用麻烦。需要熟练掌握Selector, ServerSocketChannel, SocketChannel, ByteBuffer等。</li><li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li></ol><h1 id="2-Netty官方说明"><a href="#2-Netty官方说明" class="headerlink" title="2. Netty官方说明"></a>2. Netty官方说明</h1><p><img src="https://img-blog.csdnimg.cn/direct/237e97df88124b25b1418dbca5c1761b.png" alt="在这里插入图片描述"></p><ol><li>Netty 是由JBOSS提供的一个Java开源框架，Netty提供异步的，基于事件驱动的网络应用程序框架，用以快速开发高性能，高可靠的网络IO程序。</li><li>Netty 可以帮助你快速、简单的开发出一个网络应用，相当于简化和流程化了 NIO 的开发过程。</li><li>Netty 是目前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，知名的 Elasticsearch 、Dubbo 框架内部都采用了 Netty。</li></ol><h1 id="3-Netty的优点"><a href="#3-Netty的优点" class="headerlink" title="3. Netty的优点"></a>3. Netty的优点</h1><ol><li>设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池.</li><li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li></ol><h1 id="4-线程模型基本介绍"><a href="#4-线程模型基本介绍" class="headerlink" title="4. 线程模型基本介绍"></a>4. 线程模型基本介绍</h1><ol><li>目前存在的线程模型：</li></ol><ul><li>传统阻塞IO服务模型</li><li>Reactor模式</li></ul><h1 id="5-Reactor模式"><a href="#5-Reactor模式" class="headerlink" title="5. Reactor模式"></a>5. Reactor模式</h1><h2 id="5-1-单Reactor单线程"><a href="#5-1-单Reactor单线程" class="headerlink" title="5.1 单Reactor单线程"></a>5.1 单Reactor单线程</h2><p><img src="https://img-blog.csdnimg.cn/direct/6310bfd5bea34cb7aa2c35d76ca2899c.png" alt="在这里插入图片描述"><br>前面的群聊实例就是这种方式：服务器端用一个线程通过多路复用搞定所有的 IO 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 NIO 案例就属于这种模型。<br>方案优缺点分析：</p><ol><li>优点：模型简单，没有多线程，进程通信，资源竞争问题。全部在一个线程中完成。</li><li>缺点：性能问题，只有一个线程，无法完全发挥多核CPU的性能</li><li>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis在业务处理的时间复杂度 O(1) 的情况</li></ol><h2 id="5-2-单Reactor多线程"><a href="#5-2-单Reactor多线程" class="headerlink" title="5.2 单Reactor多线程"></a>5.2 单Reactor多线程</h2><p><img src="https://img-blog.csdnimg.cn/direct/d0df38f203dd478088f3eb30053b8502.png" alt="在这里插入图片描述"></p><p>说明：</p><ol><li>Reactor对象通过select 监控客户端请求时间，收到事件后，通过dispatch进行分发。</li><li>如果建立连接请求，则acceptor荣国accept处理请求，然后创建handler对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由reactor分发调用连接对应的handler处理。</li><li>handler只负责响应事件，不做具体的业务处理，通过read读取数据后，分发给后面的worker线程池的某个线程处理任务。</li><li>worker线程池会分配独立线程完成真正的业务，并将结果返回给handler.</li><li>handler收到响应后，通过send将结果返回client<br> 方案优缺点分析：</li><li>优点：可以充分利用多核cpu的处理能力</li><li>缺点：多线程数据共享和访问比较复杂，reactor处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li><li>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis在业务处理的时间复杂度 O(1) 的情况</li></ol><h2 id="5-3-主从Reactor多线程"><a href="#5-3-主从Reactor多线程" class="headerlink" title="5.3 主从Reactor多线程"></a>5.3 主从Reactor多线程</h2><p><img src="https://img-blog.csdnimg.cn/direct/2bd1fe809ea04276b7c7a869731b6ba6.png" alt="在这里插入图片描述"></p><p>说明：</p><ol><li>Reactor主线程MainReactor对象通过select监听连接事件，收到事件后，通过acceptor处理连接事件。</li><li>当acceptor处理连接事件后，MainReactor将连接分配给SubReactor.</li><li>subreactor将连接加入连接队列进行监听，并创建handler进行各种事件处理</li><li>当有新事件发生时，subreactor调用对应的handler进行处理</li><li>handler通过reade读取数据，分发给后面的worker线程池处理</li><li>worker线程池分配独立的线程进行业务处理，并返回结果</li><li>handler收到响应的结果后，再通过send将结果返回给client</li><li>reactor主线程可以对应多个reactor子线程，即MainReactor可以关联多个subreactor<br> 方案优缺点分析：</li><li>优点：父线程和子线程的数据交互简单职责明确，父线程只需要接受新连接，子线程完成后续的业务处理。</li><li>缺点：编程难度高。</li><li>使用场景：这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持</li></ol><h1 id="6-Reactor模式小结"><a href="#6-Reactor模式小结" class="headerlink" title="6. Reactor模式小结"></a>6. Reactor模式小结</h1><ol><li>单Reactor单线程，前台接待员和服务员是同一个人</li><li>单Reactor多线程，1个前台接待员，多个服务员。</li><li>主从Reactor多线程，多个前台接待员，多个服务员。<br> Reactor模式优点：</li><li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</li><li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</li><li>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</li><li>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li></ol><h1 id="7-Netty模型"><a href="#7-Netty模型" class="headerlink" title="7. Netty模型"></a>7. Netty模型</h1><h2 id="7-1-Netty简单版"><a href="#7-1-Netty简单版" class="headerlink" title="7.1 Netty简单版"></a>7.1 Netty简单版</h2><p>Netty主要基于主从reactors多线程模型做了一定的改进，其中主从reactor多线程模型有多个reactor<br><img src="https://img-blog.csdnimg.cn/direct/62285359d91842e09074647489686b82.png" alt="在这里插入图片描述"><br>说明：</p><ol><li>BossGroup线程维护selector，他只关注accept</li><li>当接收到accept事件后，获取到对应的socketchannel,封装成NIOsocketChannel并注册到worker线程（事件循环），并进行维护</li><li>当worker线程监听到selector中通道发生自己感兴趣的事件后，就进行处理（hanlder）.注意handler已经加入到通道中。</li></ol><h2 id="7-2-Netty进阶版"><a href="#7-2-Netty进阶版" class="headerlink" title="7.2 Netty进阶版"></a>7.2 Netty进阶版</h2><p><img src="https://img-blog.csdnimg.cn/direct/8ed26c042902425693eabeed5abcb778.png" alt="在这里插入图片描述"></p><h2 id="7-2-Netty详细版"><a href="#7-2-Netty详细版" class="headerlink" title="7.2 Netty详细版"></a>7.2 Netty详细版</h2><p><img src="https://img-blog.csdnimg.cn/direct/54650aabe032417da26ab851a9d34033.png" alt="在这里插入图片描述">说明：</p><ol><li>Netty抽象出两组线程池BossGroup专门负责接受客户端的连接，workerGroup专门负责网络的读写</li><li>BossGroup和workerGroup类型都是NIOEventLoopGroup</li><li>NIOEventLoopGroup 相当于是一个事件循环组，这个组中包含多个事件循环，每一个事件循环都是NIOEventLoop.</li><li>NIOEventLoop表示一个不断循环的执行处理任务的线程，每个NIOEventLoop都有一个selector，用户监听绑定在其上的socket网络通讯。</li><li>NIOEventLoopGroup可以有多个线程，即可以含有多个NIOEventLoop</li><li>每个bossNIOEventLoop循环执行的步骤有三步</li></ol><ul><li>轮询accept事件</li><li>处理accept事件，与client建立连接，生成NIOsocketChannel并将其注册到某个wokerNIOEventLoop上的selector。</li><li>处理任务队列的任务，即runAllTasks</li></ul><ol start="7"><li>每个workerNIOEventLOOP循环执行的步骤</li></ol><ul><li>轮询read，write事件</li><li>处理IO事件，即read,write事件，在对应NIOSocketChannel处理</li><li>处理任务队列的任务，即runAllTasks</li></ul><ol start="8"><li>每个workerNIOEventLoop处理业务时，会使用pipeline（管道）pipeline中包含了channel，即通过pipeline可以获取到对应的管道，管道中维护了很多的处理器。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;1-原生NIO存在的问题&quot;&gt;&lt;a href=&quot;#1-原生NIO存在的问题&quot; class=&quot;headerlink&quot; title=&quot;1. 原生NIO存在的问题&quot;&gt;&lt;/a&gt;1</summary>
      
    
    
    
    <category term="Netty" scheme="https://liuhsir.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://liuhsir.top/tags/Netty/"/>
    
    <category term="NIO" scheme="https://liuhsir.top/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>第三章 第三节NIO零拷贝</title>
    <link href="https://liuhsir.top/2022/12/18/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82NIO%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <id>https://liuhsir.top/2022/12/18/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%B8%89%E8%8A%82NIO%E9%9B%B6%E6%8B%B7%E8%B4%9D/</id>
    <published>2022-12-18T08:43:25.000Z</published>
    <updated>2023-12-18T08:25:59.041Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="1-NIO与零拷贝"><a href="#1-NIO与零拷贝" class="headerlink" title="1. NIO与零拷贝"></a>1. NIO与零拷贝</h1><h2 id="1-1-零拷贝基本介绍"><a href="#1-1-零拷贝基本介绍" class="headerlink" title="1.1 零拷贝基本介绍"></a>1.1 零拷贝基本介绍</h2><ol><li>零拷贝是网络编程的关键，很多性能优化都离不开</li><li>Java程序中，常用的零拷贝有mmap(内存映射)和sendFile。</li></ol><h3 id="传统的IO数据读写"><a href="#传统的IO数据读写" class="headerlink" title="传统的IO数据读写"></a>传统的IO数据读写</h3><p> 需要三次用户态和内核态切换<br> 4次内存的拷贝<br><img src="https://img-blog.csdnimg.cn/direct/3aca32ecdbea4b52bcd88e2ef8908cec.png" alt="在这里插入图片描述"></p><h3 id="mmap优化"><a href="#mmap优化" class="headerlink" title="mmap优化"></a>mmap优化</h3><ol><li>mmap经过内存映射（userbuffer 和 kernelbuffer 共享），将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据（直接从内核空间buffer拷贝到内核空间socketbuffer）。这样，进行网络传输时，可以减少内核空间到用户空间的拷贝次数。<br>  <img src="https://img-blog.csdnimg.cn/direct/dc402123c3a64d2d84cbbf52aceb9ee1.png" alt="在这里插入图片描述"></li></ol><h3 id="sendFile优化（DMA-copy）"><a href="#sendFile优化（DMA-copy）" class="headerlink" title="sendFile优化（DMA copy）"></a>sendFile优化（DMA copy）</h3><ol><li>linux2.1 ：数据不经过用户态，直接从内核缓冲区 &#x3D;&gt; socketBuffer &#x3D;&gt; protocal engin.，由于和用户态完全无关，就减少了一次上下文切换.<br><img src="https://img-blog.csdnimg.cn/direct/395bc55550aa4ef1a44de30c275b02c8.png" alt="在这里插入图片描述"></li><li>linux2.4: 直接从内核缓冲区 &#x3D;&gt; 协议栈（拷贝到socketBuffer信息很少，忽略不计）<br>  <img src="https://img-blog.csdnimg.cn/direct/b283190e735f4eefa6e45bf4304437c5.png" alt="在这里插入图片描述"></li></ol><h3 id="零拷贝再次理解"><a href="#零拷贝再次理解" class="headerlink" title="零拷贝再次理解"></a>零拷贝再次理解</h3><ol><li>零拷贝:指的是没有CPU拷贝。通过DMA拷贝。(所谓DMA拷贝就是通过其他硬件负责数据的转移，不需要CPU参与，解放了CPU。<a href="https://blog.csdn.net/Erica_1230/article/details/106130799">DMA copy 和 CPU copy</a>)</li><li>零拷贝优势：更少的数据复制，减少上下文切换（内核态和用户态的切换）。</li></ol><h3 id="mmap-和-sendFile-的区别"><a href="#mmap-和-sendFile-的区别" class="headerlink" title="mmap 和 sendFile 的区别"></a>mmap 和 sendFile 的区别</h3><ol><li>mmap适合小数据量读写，sendFile适合大文件传输</li><li>sendFile可以利用DMA，减少cpu拷贝。mmap不能，它是用户buffer和内核buffer共享的。</li></ol><h2 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1. 2 案例"></a>1. 2 案例</h2><p>使用NIO零拷贝方式传递（channel.transeferTo）一个大文件。速度快得多。</p><h1 id="2-Java-AIO-基本介绍"><a href="#2-Java-AIO-基本介绍" class="headerlink" title="2. Java AIO 基本介绍"></a>2. Java AIO 基本介绍</h1><ol><li>JDK1.7引入了AIO,采用了Proactor模式，简化了程序编写，有效的请求才启动线程，他的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时长较长的应用。</li><li>目前AIO还没有广泛使用。netty是基于NIO的而不是AIO.</li></ol><h1 id="3-BIO-NIO-AIO-对比"><a href="#3-BIO-NIO-AIO-对比" class="headerlink" title="3. BIO NIO AIO 对比"></a>3. BIO NIO AIO 对比</h1><p><img src="https://img-blog.csdnimg.cn/direct/dfad9627ec7b470cbe56c62369dcf760.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;1-NIO与零拷贝&quot;&gt;&lt;a href=&quot;#1-NIO与零拷贝&quot; class=&quot;headerlink&quot; title=&quot;1. NIO与零拷贝&quot;&gt;&lt;/a&gt;1. NIO与零拷贝</summary>
      
    
    
    
    <category term="Netty" scheme="https://liuhsir.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://liuhsir.top/tags/Netty/"/>
    
    <category term="NIO" scheme="https://liuhsir.top/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>第三章 第二节NIO网络编程应用实例-群聊系统</title>
    <link href="https://liuhsir.top/2022/12/17/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%BA%8C%E8%8A%82NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F/"/>
    <id>https://liuhsir.top/2022/12/17/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%BA%8C%E8%8A%82NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-12-17T09:43:25.000Z</published>
    <updated>2023-12-17T14:30:44.794Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/> <h1 id="1-案例需求"><a href="#1-案例需求" class="headerlink" title="1. 案例需求"></a>1. 案例需求</h1><p>编写一个 NIO 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）实现多人群聊服务器端：可以监测用户上线，离线，并实现消息转发功能客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)<br>目的：进一步理解NIO非阻塞网络编程机制<br><img src="https://img-blog.csdnimg.cn/direct/de1f5387a10e436a82d01f9e55e4d513.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/direct/64e1c545ab0942be838f3b0788111029.png" alt="在这里插入图片描述"></p><h1 id="2-流程"><a href="#2-流程" class="headerlink" title="2. 流程"></a>2. 流程</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ol><li>监听客户端连接</li></ol><ul><li>初始化工作，实例化selector,实例化serverSocketChannel.设置非阻塞。注册ACCEPT事件</li><li>监听客户端连接请求，将socketChannel注册到selector,注册为READ事件。</li></ul><ol start="2"><li>读取客户端信息，打印输出</li></ol><ul><li>读取socketChannel信息</li></ul><ol start="3"><li>将客户端信息转发到其他的客户端</li></ol><ul><li>获取所有的keys。如果channel instanceof socketChannel &amp;&amp; 不是当前的客户端的channel，向其他客户端channel写入数据。</li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li>发送信息<br>初始化工作，实例化selector,实例化SocketChannel，连接服务器.设置非阻塞。向socketChannel写入信息</li><li>接受信息<br>selector.select()看是否有事件，有则遍历key,获取通道读取数据。<br>注意：读写数据都是通过channel。<br>三种方法获取channel:</li><li>serverSocketChannel.accept() 服务端 </li><li>socketChannel.open(new InetSocketAddress(“127.0.0.1”, PORT)); 客户端 </li><li>SocketChannel sc &#x3D; (SocketChannel) key.channel(); 通过selector的selectionKey获取（事件获取）</li></ol><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h1><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel =  ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//将该listenChannel 注册到selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;<span class="comment">//有事件处理</span></span><br><span class="line">                    <span class="comment">//遍历得到selectionKey 集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">//取出selectionkey</span></span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="comment">//监听到accept</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到seletor</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable()) &#123; <span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">//处理读 (专门写方法..)</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="comment">//取到关联的channle</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据count的值做处理</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form 客户端: &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己), 专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot; 离线了..&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self )</span> <span class="keyword">throws</span>  IOException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发数据给客户端线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//遍历 所有注册到selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span>(SelectionKey key: selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key  取出对应的 SocketChannel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span>  SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">dest</span> <span class="operator">=</span> (SocketChannel)targetChannel;</span><br><span class="line">                <span class="comment">//将msg 存储到buffer</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer 的数据写入 通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">groupChatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>; <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">//构造器, 完成初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = socketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//将channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span>(readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                       <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                       <span class="comment">//得到一个Buffer</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove(); <span class="comment">//删除当前的selectionKey, 防止重复操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        <span class="type">GroupChatClient</span> <span class="variable">chatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>();</span><br><span class="line">        <span class="comment">//启动一个线程, 每隔3秒，读取从服务器发送数据。这里启动线程是因为主线程要发送数据接受用户数据，会阻塞，因此要用新的线程处理接受消息。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 

&lt;h1 id=&quot;1-案例需求&quot;&gt;&lt;a href=&quot;#1-案例需求&quot; class=&quot;headerlink&quot; title=&quot;1. 案例需求&quot;&gt;&lt;/a&gt;1. 案例需求&lt;/h1&gt;&lt;p&gt;编写一个</summary>
      
    
    
    
    <category term="Netty" scheme="https://liuhsir.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://liuhsir.top/tags/Netty/"/>
    
    <category term="NIO" scheme="https://liuhsir.top/tags/NIO/"/>
    
  </entry>
  
</feed>
